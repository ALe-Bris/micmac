# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_mm3d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_mm3d')
    _mm3d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mm3d', [dirname(__file__)])
        except ImportError:
            import _mm3d
            return _mm3d
        try:
            _mod = imp.load_module('_mm3d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _mm3d = swig_import_helper()
    del swig_import_helper
else:
    import _mm3d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _mm3d.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _mm3d.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _mm3d.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _mm3d.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _mm3d.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _mm3d.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _mm3d.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _mm3d.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _mm3d.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _mm3d.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _mm3d.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _mm3d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _mm3d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _mm3d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _mm3d.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _mm3d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _mm3d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _mm3d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _mm3d.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _mm3d.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _mm3d.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _mm3d.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _mm3d.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _mm3d.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _mm3d.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _mm3d.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _mm3d.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _mm3d.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _mm3d.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _mm3d.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _mm3d.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _mm3d.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _mm3d.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _mm3d.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _mm3d.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _mm3d.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _mm3d.IntVector_rend(self)

    def clear(self) -> "void":
        return _mm3d.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _mm3d.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _mm3d.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _mm3d.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _mm3d.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _mm3d.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _mm3d.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _mm3d.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _mm3d.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _mm3d.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _mm3d.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _mm3d.IntVector_capacity(self)
    __swig_destroy__ = _mm3d.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _mm3d.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _mm3d.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _mm3d.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _mm3d.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _mm3d.DoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _mm3d.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _mm3d.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _mm3d.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _mm3d.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _mm3d.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _mm3d.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _mm3d.DoubleVector_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _mm3d.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _mm3d.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _mm3d.DoubleVector_size(self)

    def swap(self, v: 'DoubleVector') -> "void":
        return _mm3d.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _mm3d.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _mm3d.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _mm3d.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _mm3d.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _mm3d.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _mm3d.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _mm3d.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _mm3d.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _mm3d.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _mm3d.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _mm3d.DoubleVector_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _mm3d.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _mm3d.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _mm3d.DoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _mm3d.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _mm3d.DoubleVector_capacity(self)
    __swig_destroy__ = _mm3d.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _mm3d.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _mm3d.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _mm3d.StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _mm3d.StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _mm3d.StringVector___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _mm3d.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _mm3d.StringVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _mm3d.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _mm3d.StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _mm3d.StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _mm3d.StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _mm3d.StringVector_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _mm3d.StringVector_append(self, x)

    def empty(self) -> "bool":
        return _mm3d.StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _mm3d.StringVector_size(self)

    def swap(self, v: 'StringVector') -> "void":
        return _mm3d.StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _mm3d.StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _mm3d.StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _mm3d.StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _mm3d.StringVector_rend(self)

    def clear(self) -> "void":
        return _mm3d.StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _mm3d.StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _mm3d.StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _mm3d.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _mm3d.StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _mm3d.StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _mm3d.StringVector_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _mm3d.StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _mm3d.StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _mm3d.StringVector_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _mm3d.StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _mm3d.StringVector_capacity(self)
    __swig_destroy__ = _mm3d.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _mm3d.StringVector_swigregister
StringVector_swigregister(StringVector)

class HomolList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HomolList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HomolList, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _mm3d.HomolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _mm3d.HomolList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _mm3d.HomolList___bool__(self)

    def __len__(self) -> "std::list< cNupletPtsHomologues >::size_type":
        return _mm3d.HomolList___len__(self)

    def __getslice__(self, i: 'std::list< cNupletPtsHomologues >::difference_type', j: 'std::list< cNupletPtsHomologues >::difference_type') -> "std::list< cNupletPtsHomologues,std::allocator< cNupletPtsHomologues > > *":
        return _mm3d.HomolList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _mm3d.HomolList___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< cNupletPtsHomologues >::difference_type', j: 'std::list< cNupletPtsHomologues >::difference_type') -> "void":
        return _mm3d.HomolList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _mm3d.HomolList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< cNupletPtsHomologues >::value_type const &":
        return _mm3d.HomolList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _mm3d.HomolList___setitem__(self, *args)

    def pop(self) -> "std::list< cNupletPtsHomologues >::value_type":
        return _mm3d.HomolList_pop(self)

    def append(self, x: 'cNupletPtsHomologues') -> "void":
        return _mm3d.HomolList_append(self, x)

    def empty(self) -> "bool":
        return _mm3d.HomolList_empty(self)

    def size(self) -> "std::list< cNupletPtsHomologues >::size_type":
        return _mm3d.HomolList_size(self)

    def swap(self, v: 'HomolList') -> "void":
        return _mm3d.HomolList_swap(self, v)

    def begin(self) -> "std::list< cNupletPtsHomologues >::iterator":
        return _mm3d.HomolList_begin(self)

    def end(self) -> "std::list< cNupletPtsHomologues >::iterator":
        return _mm3d.HomolList_end(self)

    def rbegin(self) -> "std::list< cNupletPtsHomologues >::reverse_iterator":
        return _mm3d.HomolList_rbegin(self)

    def rend(self) -> "std::list< cNupletPtsHomologues >::reverse_iterator":
        return _mm3d.HomolList_rend(self)

    def clear(self) -> "void":
        return _mm3d.HomolList_clear(self)

    def get_allocator(self) -> "std::list< cNupletPtsHomologues >::allocator_type":
        return _mm3d.HomolList_get_allocator(self)

    def pop_back(self) -> "void":
        return _mm3d.HomolList_pop_back(self)

    def erase(self, *args) -> "std::list< cNupletPtsHomologues >::iterator":
        return _mm3d.HomolList_erase(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_HomolList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'cNupletPtsHomologues') -> "void":
        return _mm3d.HomolList_push_back(self, x)

    def front(self) -> "std::list< cNupletPtsHomologues >::value_type const &":
        return _mm3d.HomolList_front(self)

    def back(self) -> "std::list< cNupletPtsHomologues >::value_type const &":
        return _mm3d.HomolList_back(self)

    def assign(self, n: 'std::list< cNupletPtsHomologues >::size_type', x: 'cNupletPtsHomologues') -> "void":
        return _mm3d.HomolList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _mm3d.HomolList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _mm3d.HomolList_insert(self, *args)

    def pop_front(self) -> "void":
        return _mm3d.HomolList_pop_front(self)

    def push_front(self, x: 'cNupletPtsHomologues') -> "void":
        return _mm3d.HomolList_push_front(self, x)

    def reverse(self) -> "void":
        return _mm3d.HomolList_reverse(self)
    __swig_destroy__ = _mm3d.delete_HomolList
    __del__ = lambda self: None
HomolList_swigregister = _mm3d.HomolList_swigregister
HomolList_swigregister(HomolList)

class CpleStringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CpleStringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CpleStringVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _mm3d.CpleStringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _mm3d.CpleStringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _mm3d.CpleStringVector___bool__(self)

    def __len__(self) -> "std::vector< cCpleString >::size_type":
        return _mm3d.CpleStringVector___len__(self)

    def __getslice__(self, i: 'std::vector< cCpleString >::difference_type', j: 'std::vector< cCpleString >::difference_type') -> "std::vector< cCpleString,std::allocator< cCpleString > > *":
        return _mm3d.CpleStringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _mm3d.CpleStringVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< cCpleString >::difference_type', j: 'std::vector< cCpleString >::difference_type') -> "void":
        return _mm3d.CpleStringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _mm3d.CpleStringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< cCpleString >::value_type const &":
        return _mm3d.CpleStringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _mm3d.CpleStringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< cCpleString >::value_type":
        return _mm3d.CpleStringVector_pop(self)

    def append(self, x: 'cCpleString') -> "void":
        return _mm3d.CpleStringVector_append(self, x)

    def empty(self) -> "bool":
        return _mm3d.CpleStringVector_empty(self)

    def size(self) -> "std::vector< cCpleString >::size_type":
        return _mm3d.CpleStringVector_size(self)

    def swap(self, v: 'CpleStringVector') -> "void":
        return _mm3d.CpleStringVector_swap(self, v)

    def begin(self) -> "std::vector< cCpleString >::iterator":
        return _mm3d.CpleStringVector_begin(self)

    def end(self) -> "std::vector< cCpleString >::iterator":
        return _mm3d.CpleStringVector_end(self)

    def rbegin(self) -> "std::vector< cCpleString >::reverse_iterator":
        return _mm3d.CpleStringVector_rbegin(self)

    def rend(self) -> "std::vector< cCpleString >::reverse_iterator":
        return _mm3d.CpleStringVector_rend(self)

    def clear(self) -> "void":
        return _mm3d.CpleStringVector_clear(self)

    def get_allocator(self) -> "std::vector< cCpleString >::allocator_type":
        return _mm3d.CpleStringVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _mm3d.CpleStringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< cCpleString >::iterator":
        return _mm3d.CpleStringVector_erase(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_CpleStringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'cCpleString') -> "void":
        return _mm3d.CpleStringVector_push_back(self, x)

    def front(self) -> "std::vector< cCpleString >::value_type const &":
        return _mm3d.CpleStringVector_front(self)

    def back(self) -> "std::vector< cCpleString >::value_type const &":
        return _mm3d.CpleStringVector_back(self)

    def assign(self, n: 'std::vector< cCpleString >::size_type', x: 'cCpleString') -> "void":
        return _mm3d.CpleStringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _mm3d.CpleStringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _mm3d.CpleStringVector_insert(self, *args)

    def reserve(self, n: 'std::vector< cCpleString >::size_type') -> "void":
        return _mm3d.CpleStringVector_reserve(self, n)

    def capacity(self) -> "std::vector< cCpleString >::size_type":
        return _mm3d.CpleStringVector_capacity(self)
    __swig_destroy__ = _mm3d.delete_CpleStringVector
    __del__ = lambda self: None
CpleStringVector_swigregister = _mm3d.CpleStringVector_swigregister
CpleStringVector_swigregister(CpleStringVector)

class cXml_OneTripletList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cXml_OneTripletList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cXml_OneTripletList, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _mm3d.cXml_OneTripletList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _mm3d.cXml_OneTripletList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _mm3d.cXml_OneTripletList___bool__(self)

    def __len__(self) -> "std::list< cXml_OneTriplet >::size_type":
        return _mm3d.cXml_OneTripletList___len__(self)

    def __getslice__(self, i: 'std::list< cXml_OneTriplet >::difference_type', j: 'std::list< cXml_OneTriplet >::difference_type') -> "std::list< cXml_OneTriplet,std::allocator< cXml_OneTriplet > > *":
        return _mm3d.cXml_OneTripletList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _mm3d.cXml_OneTripletList___setslice__(self, *args)

    def __delslice__(self, i: 'std::list< cXml_OneTriplet >::difference_type', j: 'std::list< cXml_OneTriplet >::difference_type') -> "void":
        return _mm3d.cXml_OneTripletList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _mm3d.cXml_OneTripletList___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< cXml_OneTriplet >::value_type const &":
        return _mm3d.cXml_OneTripletList___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _mm3d.cXml_OneTripletList___setitem__(self, *args)

    def pop(self) -> "std::list< cXml_OneTriplet >::value_type":
        return _mm3d.cXml_OneTripletList_pop(self)

    def append(self, x: 'cXml_OneTriplet') -> "void":
        return _mm3d.cXml_OneTripletList_append(self, x)

    def empty(self) -> "bool":
        return _mm3d.cXml_OneTripletList_empty(self)

    def size(self) -> "std::list< cXml_OneTriplet >::size_type":
        return _mm3d.cXml_OneTripletList_size(self)

    def swap(self, v: 'cXml_OneTripletList') -> "void":
        return _mm3d.cXml_OneTripletList_swap(self, v)

    def begin(self) -> "std::list< cXml_OneTriplet >::iterator":
        return _mm3d.cXml_OneTripletList_begin(self)

    def end(self) -> "std::list< cXml_OneTriplet >::iterator":
        return _mm3d.cXml_OneTripletList_end(self)

    def rbegin(self) -> "std::list< cXml_OneTriplet >::reverse_iterator":
        return _mm3d.cXml_OneTripletList_rbegin(self)

    def rend(self) -> "std::list< cXml_OneTriplet >::reverse_iterator":
        return _mm3d.cXml_OneTripletList_rend(self)

    def clear(self) -> "void":
        return _mm3d.cXml_OneTripletList_clear(self)

    def get_allocator(self) -> "std::list< cXml_OneTriplet >::allocator_type":
        return _mm3d.cXml_OneTripletList_get_allocator(self)

    def pop_back(self) -> "void":
        return _mm3d.cXml_OneTripletList_pop_back(self)

    def erase(self, *args) -> "std::list< cXml_OneTriplet >::iterator":
        return _mm3d.cXml_OneTripletList_erase(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_cXml_OneTripletList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'cXml_OneTriplet') -> "void":
        return _mm3d.cXml_OneTripletList_push_back(self, x)

    def front(self) -> "std::list< cXml_OneTriplet >::value_type const &":
        return _mm3d.cXml_OneTripletList_front(self)

    def back(self) -> "std::list< cXml_OneTriplet >::value_type const &":
        return _mm3d.cXml_OneTripletList_back(self)

    def assign(self, n: 'std::list< cXml_OneTriplet >::size_type', x: 'cXml_OneTriplet') -> "void":
        return _mm3d.cXml_OneTripletList_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _mm3d.cXml_OneTripletList_resize(self, *args)

    def insert(self, *args) -> "void":
        return _mm3d.cXml_OneTripletList_insert(self, *args)

    def pop_front(self) -> "void":
        return _mm3d.cXml_OneTripletList_pop_front(self)

    def push_front(self, x: 'cXml_OneTriplet') -> "void":
        return _mm3d.cXml_OneTripletList_push_front(self, x)

    def reverse(self) -> "void":
        return _mm3d.cXml_OneTripletList_reverse(self)
    __swig_destroy__ = _mm3d.delete_cXml_OneTripletList
    __del__ = lambda self: None
cXml_OneTripletList_swigregister = _mm3d.cXml_OneTripletList_swigregister
cXml_OneTripletList_swigregister(cXml_OneTripletList)

ELISE_QT = _mm3d.ELISE_QT
GIMMI_QT = _mm3d.GIMMI_QT
QT_INSTALL_PLUGINS = _mm3d.QT_INSTALL_PLUGINS
ELISE_DEPLOY = _mm3d.ELISE_DEPLOY
PROJECT_SOURCE_DIR = _mm3d.PROJECT_SOURCE_DIR
ELISE_PTR_SIZE = _mm3d.ELISE_PTR_SIZE
BIN_AUX_SUBDIR = _mm3d.BIN_AUX_SUBDIR
ELISE_Darwin = _mm3d.ELISE_Darwin
USE_NOYAU = _mm3d.USE_NOYAU
ELISE_unix = _mm3d.ELISE_unix
ELISE_MacOs = _mm3d.ELISE_MacOs
ELISE_windows = _mm3d.ELISE_windows
ELISE_MinGW = _mm3d.ELISE_MinGW
ELISE_POSIX = _mm3d.ELISE_POSIX
BUG_CPP_Fclose = _mm3d.BUG_CPP_Fclose
ElBugHomeMPD = _mm3d.ElBugHomeMPD
Compiler_Turbo_4_5 = _mm3d.Compiler_Turbo_4_5
Compiler_Visual_5_0 = _mm3d.Compiler_Visual_5_0
Compiler_Visual_6_0 = _mm3d.Compiler_Visual_6_0
Compiler_Gpp2_7_2 = _mm3d.Compiler_Gpp2_7_2
GPP3etPlus = _mm3d.GPP3etPlus
Compiler_Visual_7_0 = _mm3d.Compiler_Visual_7_0
MACHINE_BLERIOT = _mm3d.MACHINE_BLERIOT
SUN_WS5 = _mm3d.SUN_WS5
SUN_WS6 = _mm3d.SUN_WS6
ELISE_X11 = _mm3d.ELISE_X11
ELISE_NO_VIDEO = _mm3d.ELISE_NO_VIDEO
ELISE_VW_W95NT_API = _mm3d.ELISE_VW_W95NT_API
ELISE_WXW = _mm3d.ELISE_WXW
ElUseNameSpace = _mm3d.ElUseNameSpace
SYS_MV = _mm3d.SYS_MV
SYS_RM = _mm3d.SYS_RM
SYS_CP = _mm3d.SYS_CP
SYS_CAT = _mm3d.SYS_CAT
ELISE_CAR_DIR = _mm3d.ELISE_CAR_DIR
ELISE_Current_DIR = _mm3d.ELISE_Current_DIR
ELISE_STR_DIR = _mm3d.ELISE_STR_DIR
ELISE_CAR_ENV = _mm3d.ELISE_CAR_ENV
ElTemplateInstantiation = _mm3d.ElTemplateInstantiation
ElMemberTpl = _mm3d.ElMemberTpl
SUN_WS = _mm3d.SUN_WS
STRICT_ANSI_FRIEND_TPL = _mm3d.STRICT_ANSI_FRIEND_TPL

def trace_system(cmd: 'char const *') -> "int":
    return _mm3d.trace_system(cmd)
trace_system = _mm3d.trace_system

def trace_popen(cmd: 'char const *', acces: 'char const *') -> "FILE *":
    return _mm3d.trace_popen(cmd, acces)
trace_popen = _mm3d.trace_popen

def MSBF_PROCESSOR() -> "bool":
    return _mm3d.MSBF_PROCESSOR()
MSBF_PROCESSOR = _mm3d.MSBF_PROCESSOR
Chol16Byte = _mm3d.Chol16Byte
ELISE_PTR_FORMAT = _mm3d.ELISE_PTR_FORMAT

def mm3d_init() -> "void":
    return _mm3d.mm3d_init()
mm3d_init = _mm3d.mm3d_init

def CamOrientFromFile(filename: 'std::string') -> "CamStenope *":
    return _mm3d.CamOrientFromFile(filename)
CamOrientFromFile = _mm3d.CamOrientFromFile

def createIdealCamXML(focale: 'double', aPP: 'Pt2dr', aSz: 'Pt2di', oriName: 'std::string', imgName: 'std::string', idCam: 'std::string', orient: 'ElRotation3D', prof: 'double', rayonUtile: 'double') -> "void":
    return _mm3d.createIdealCamXML(focale, aPP, aSz, oriName, imgName, idCam, orient, prof, rayonUtile)
createIdealCamXML = _mm3d.createIdealCamXML

def list2rot(l: 'DoubleVector') -> "ElRotation3D":
    return _mm3d.list2rot(l)
list2rot = _mm3d.list2rot

def quaternion2rot(a: 'double', b: 'double', c: 'double', d: 'double') -> "ElRotation3D":
    return _mm3d.quaternion2rot(a, b, c, d)
quaternion2rot = _mm3d.quaternion2rot

def rot2list(r: 'ElRotation3D') -> "std::vector< double,std::allocator< double > >":
    return _mm3d.rot2list(r)
rot2list = _mm3d.rot2list

def getFileSet(dir: 'std::string', pattern: 'std::string') -> "std::vector< std::string,std::allocator< std::string > >":
    return _mm3d.getFileSet(dir, pattern)
getFileSet = _mm3d.getFileSet

def StdGetFromSI_Xml_TopoTriplet(aNameFileObj: 'std::string const &') -> "cXml_TopoTriplet":
    return _mm3d.StdGetFromSI_Xml_TopoTriplet(aNameFileObj)
StdGetFromSI_Xml_TopoTriplet = _mm3d.StdGetFromSI_Xml_TopoTriplet

def StdGetFromSI_Xml_Ori3ImInit(aNameFileObj: 'std::string const &') -> "cXml_Ori3ImInit":
    return _mm3d.StdGetFromSI_Xml_Ori3ImInit(aNameFileObj)
StdGetFromSI_Xml_Ori3ImInit = _mm3d.StdGetFromSI_Xml_Ori3ImInit
class cTD_Camera(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTD_Camera, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cTD_Camera, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::string const &'):
        this = _mm3d.new_cTD_Camera(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Save(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cTD_Camera_Save(self, arg2)

    def Ter2Image(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.cTD_Camera_Ter2Image(self, arg2)

    def RelvtEspace(self, aPTer1: 'Pt3dr', aPIm1: 'Pt2dr', aPTer2: 'Pt3dr', aPIm2: 'Pt2dr', aPTer3: 'Pt3dr', aPIm3: 'Pt2dr') -> "std::vector< cTD_Camera,std::allocator< cTD_Camera > >":
        return _mm3d.cTD_Camera_RelvtEspace(self, aPTer1, aPIm1, aPTer2, aPIm2, aPTer3, aPIm3)

    def Focale(self) -> "double":
        return _mm3d.cTD_Camera_Focale(self)

    def R3(self) -> "double":
        return _mm3d.cTD_Camera_R3(self)

    def SzCam(self) -> "Pt2dr":
        return _mm3d.cTD_Camera_SzCam(self)

    def NewCam(self, aFoc: 'double', aR3: 'double') -> "cTD_Camera":
        return _mm3d.cTD_Camera_NewCam(self, aFoc, aR3)

    def Ter2Im(self, aPTer: 'Pt3dr') -> "Pt2dr":
        return _mm3d.cTD_Camera_Ter2Im(self, aPTer)

    def ImAndProf2Ter(self, aPTer: 'Pt2dr', aProf: 'double') -> "Pt3dr":
        return _mm3d.cTD_Camera_ImAndProf2Ter(self, aPTer, aProf)

    def ProfMoy(self) -> "double":
        return _mm3d.cTD_Camera_ProfMoy(self)

    def StepProfOnePixel(self, arg2: 'cTD_Camera') -> "double":
        return _mm3d.cTD_Camera_StepProfOnePixel(self, arg2)
    __swig_destroy__ = _mm3d.delete_cTD_Camera
    __del__ = lambda self: None
cTD_Camera_swigregister = _mm3d.cTD_Camera_swigregister
cTD_Camera_swigregister(cTD_Camera)
cvar = _mm3d.cvar


def TD_EntierAleatoire(aN: 'int') -> "int":
    return _mm3d.TD_EntierAleatoire(aN)
TD_EntierAleatoire = _mm3d.TD_EntierAleatoire
class cTD_SetAppuis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTD_SetAppuis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cTD_SetAppuis, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'std::string const &'):
        this = _mm3d.new_cTD_SetAppuis(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def PTer(self) -> "std::vector< Pt3dr,std::allocator< Pt3dr > > const &":
        return _mm3d.cTD_SetAppuis_PTer(self)

    def PIm(self) -> "std::vector< Pt2dr,std::allocator< Pt2dr > > const &":
        return _mm3d.cTD_SetAppuis_PIm(self)
    __swig_destroy__ = _mm3d.delete_cTD_SetAppuis
    __del__ = lambda self: None
cTD_SetAppuis_swigregister = _mm3d.cTD_SetAppuis_swigregister
cTD_SetAppuis_swigregister(cTD_SetAppuis)

class cTD_Im(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTD_Im, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cTD_Im, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_cTD_Im(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        FromString = staticmethod(_mm3d.cTD_Im_FromString)
    else:
        FromString = _mm3d.cTD_Im_FromString

    def ImageMoy(self, aSzW: 'int', aNbIter: 'int') -> "cTD_Im":
        return _mm3d.cTD_Im_ImageMoy(self, aSzW, aNbIter)

    def ImageReduite(self, aFact: 'double') -> "cTD_Im":
        return _mm3d.cTD_Im_ImageReduite(self, aFact)

    def Save(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cTD_Im_Save(self, arg2)

    def SaveRGB(self, arg2: 'std::string const &', arg3: 'cTD_Im', arg4: 'cTD_Im') -> "void":
        return _mm3d.cTD_Im_SaveRGB(self, arg2, arg3, arg4)

    def GetVal(self, *args) -> "double":
        return _mm3d.cTD_Im_GetVal(self, *args)

    def Ok(self, anX: 'int', anY: 'int') -> "bool":
        return _mm3d.cTD_Im_Ok(self, anX, anY)

    def Sz(self) -> "Pt2di":
        return _mm3d.cTD_Im_Sz(self)

    def SetVal(self, anX: 'int', anY: 'int', aVal: 'double') -> "void":
        return _mm3d.cTD_Im_SetVal(self, anX, anY, aVal)
    __swig_destroy__ = _mm3d.delete_cTD_Im
    __del__ = lambda self: None
cTD_Im_swigregister = _mm3d.cTD_Im_swigregister
cTD_Im_swigregister(cTD_Im)

def cTD_Im_FromString(arg2: 'std::string const &') -> "cTD_Im":
    return _mm3d.cTD_Im_FromString(arg2)
cTD_Im_FromString = _mm3d.cTD_Im_FromString


def AnalyseContextCom(argc: 'int', argv: 'char **') -> "void":
    return _mm3d.AnalyseContextCom(argc, argv)
AnalyseContextCom = _mm3d.AnalyseContextCom

def MMD_InitArgcArgv(argc: 'int', argv: 'char **', aNbArgMin: 'int'=-1) -> "void":
    return _mm3d.MMD_InitArgcArgv(argc, argv, aNbArgMin)
MMD_InitArgcArgv = _mm3d.MMD_InitArgcArgv

def NbProcSys() -> "int":
    return _mm3d.NbProcSys()
NbProcSys = _mm3d.NbProcSys

def mem_raz(arg1: 'void *', arg2: 'tFileOffset') -> "void":
    return _mm3d.mem_raz(arg1, arg2)
mem_raz = _mm3d.mem_raz

def SubstArgcArvGlob(aKSubst: 'int', aSubst: 'std::string', aProtect: 'bool'=False) -> "std::string":
    return _mm3d.SubstArgcArvGlob(aKSubst, aSubst, aProtect)
SubstArgcArvGlob = _mm3d.SubstArgcArvGlob

def GetUnikId() -> "std::string":
    return _mm3d.GetUnikId()
GetUnikId = _mm3d.GetUnikId

def Dir2Write(*args) -> "std::string":
    return _mm3d.Dir2Write(*args)
Dir2Write = _mm3d.Dir2Write

def ElExit(aLine: 'int', aFile: 'char const *', aCode: 'int', aMessage: 'std::string const &') -> "void":
    return _mm3d.ElExit(aLine, aFile, aCode, aMessage)
ElExit = _mm3d.ElExit

def AddMessErrContext(aMes: 'std::string const &') -> "void":
    return _mm3d.AddMessErrContext(aMes)
AddMessErrContext = _mm3d.AddMessErrContext

def mm_getpid() -> "int":
    return _mm3d.mm_getpid()
mm_getpid = _mm3d.mm_getpid

def SleepProcess(arg1: 'double') -> "void":
    return _mm3d.SleepProcess(arg1)
SleepProcess = _mm3d.SleepProcess
class FBool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FBool, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __eq__(self, F2: 'FBool') -> "bool":
        return _mm3d.FBool___eq__(self, F2)

    def __ne__(self, F2: 'FBool') -> "bool":
        return _mm3d.FBool___ne__(self, F2)

    def BoolCast(self) -> "bool":
        return _mm3d.FBool_BoolCast(self)
    __swig_destroy__ = _mm3d.delete_FBool
    __del__ = lambda self: None
FBool_swigregister = _mm3d.FBool_swigregister
FBool_swigregister(FBool)
INDEX_NOT_FOUND = cvar.INDEX_NOT_FOUND
FBool._True = _mm3d.cvar.FBool__True
FBool._MayBe = _mm3d.cvar.FBool__MayBe
FBool._False = _mm3d.cvar.FBool__False


def lround_up(r: 'double') -> "long":
    return _mm3d.lround_up(r)
lround_up = _mm3d.lround_up

def round_Uup(r: 'double') -> "int":
    return _mm3d.round_Uup(r)
round_Uup = _mm3d.round_Uup

def lround_down(r: 'double') -> "long":
    return _mm3d.lround_down(r)
lround_down = _mm3d.lround_down

def round_Ddown(r: 'double') -> "int":
    return _mm3d.round_Ddown(r)
round_Ddown = _mm3d.round_Ddown

def lround_ni(r: 'double') -> "long":
    return _mm3d.lround_ni(r)
lround_ni = _mm3d.lround_ni

def signed_frac(r: 'double') -> "double":
    return _mm3d.signed_frac(r)
signed_frac = _mm3d.signed_frac

def Elise_div(a: 'int', b: 'int') -> "int":
    return _mm3d.Elise_div(a, b)
Elise_div = _mm3d.Elise_div

def mod(a: 'int', b: 'int') -> "int":
    return _mm3d.mod(a, b)
mod = _mm3d.mod

def mod256(a: 'int') -> "int":
    return _mm3d.mod256(a)
mod256 = _mm3d.mod256

def mod_gen(a: 'int', b: 'int') -> "int":
    return _mm3d.mod_gen(a, b)
mod_gen = _mm3d.mod_gen

def arrondi_inf(*args) -> "double":
    return _mm3d.arrondi_inf(*args)
arrondi_inf = _mm3d.arrondi_inf

def mod_real(a: 'double', b: 'double') -> "double":
    return _mm3d.mod_real(a, b)
mod_real = _mm3d.mod_real

def Centered_mod_real(a: 'double', b: 'double') -> "double":
    return _mm3d.Centered_mod_real(a, b)
Centered_mod_real = _mm3d.Centered_mod_real
class cDecimal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDecimal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cDecimal, name)
    __repr__ = _swig_repr

    def __init__(self, aMant: 'int', aPow: 'int'):
        this = _mm3d.new_cDecimal(aMant, aPow)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def RVal(self) -> "double":
        return _mm3d.cDecimal_RVal(self)

    def Mant(self) -> "int const &":
        return _mm3d.cDecimal_Mant(self)

    def Exp(self) -> "int const &":
        return _mm3d.cDecimal_Exp(self)

    def Arrondi(self, aV: 'double') -> "double":
        return _mm3d.cDecimal_Arrondi(self, aV)

    def Mul10(self) -> "long":
        return _mm3d.cDecimal_Mul10(self)

    def Div10(self) -> "long":
        return _mm3d.cDecimal_Div10(self)
    __swig_setmethods__["mMant"] = _mm3d.cDecimal_mMant_set
    __swig_getmethods__["mMant"] = _mm3d.cDecimal_mMant_get
    if _newclass:
        mMant = _swig_property(_mm3d.cDecimal_mMant_get, _mm3d.cDecimal_mMant_set)
    __swig_setmethods__["mExp"] = _mm3d.cDecimal_mExp_set
    __swig_getmethods__["mExp"] = _mm3d.cDecimal_mExp_get
    if _newclass:
        mExp = _swig_property(_mm3d.cDecimal_mExp_get, _mm3d.cDecimal_mExp_set)
    __swig_destroy__ = _mm3d.delete_cDecimal
    __del__ = lambda self: None
cDecimal_swigregister = _mm3d.cDecimal_swigregister
cDecimal_swigregister(cDecimal)


def StdRound(*args) -> "cDecimal":
    return _mm3d.StdRound(*args)
StdRound = _mm3d.StdRound

def angle_mod_real(a: 'double', b: 'double') -> "double":
    return _mm3d.angle_mod_real(a, b)
angle_mod_real = _mm3d.angle_mod_real

def Pow(arg1: 'double', arg2: 'int') -> "double":
    return _mm3d.Pow(arg1, arg2)
Pow = _mm3d.Pow

def Pow_of_2_sup(arg1: 'int') -> "int":
    return _mm3d.Pow_of_2_sup(arg1)
Pow_of_2_sup = _mm3d.Pow_of_2_sup

def is_pow_of_2(arg1: 'int') -> "bool":
    return _mm3d.is_pow_of_2(arg1)
is_pow_of_2 = _mm3d.is_pow_of_2

def NbBitsOfFlag(aFlag: 'int') -> "int":
    return _mm3d.NbBitsOfFlag(aFlag)
NbBitsOfFlag = _mm3d.NbBitsOfFlag

def El_logDeux(arg1: 'double') -> "double":
    return _mm3d.El_logDeux(arg1)
El_logDeux = _mm3d.El_logDeux

def dup(arg1: 'char const *') -> "char *":
    return _mm3d.dup(arg1)
dup = _mm3d.dup

def cat(ch1: 'char const *', ch2: 'char const *') -> "char *":
    return _mm3d.cat(ch1, ch2)
cat = _mm3d.cat

def tab_not_log(out: 'int *', arg2: 'int const *', nb: 'int') -> "void":
    return _mm3d.tab_not_log(out, arg2, nb)
tab_not_log = _mm3d.tab_not_log

def tab_not_bit_by_bit(out: 'int *', arg2: 'int const *', nb: 'int') -> "void":
    return _mm3d.tab_not_bit_by_bit(out, arg2, nb)
tab_not_bit_by_bit = _mm3d.tab_not_bit_by_bit

def round_ni_inf(*args) -> "void":
    return _mm3d.round_ni_inf(*args)
round_ni_inf = _mm3d.round_ni_inf

def index_values_strict_neg(arg1: 'double const *', nb: 'int') -> "int":
    return _mm3d.index_values_strict_neg(arg1, nb)
index_values_strict_neg = _mm3d.index_values_strict_neg

def index_values_neg_or_null(arg1: 'double const *', nb: 'int') -> "int":
    return _mm3d.index_values_neg_or_null(arg1, nb)
index_values_neg_or_null = _mm3d.index_values_neg_or_null

def index_values_not_acos(arg1: 'double const *', nb: 'int') -> "int":
    return _mm3d.index_values_not_acos(arg1, nb)
index_values_not_acos = _mm3d.index_values_not_acos

def index_values_complex_nul(x: 'double const *', y: 'double const *', nb: 'int') -> "int":
    return _mm3d.index_values_complex_nul(x, y, nb)
index_values_complex_nul = _mm3d.index_values_complex_nul

def set_fonc_x(res: 'int *', x0: 'int', x1: 'int') -> "void":
    return _mm3d.set_fonc_x(res, x0, x1)
set_fonc_x = _mm3d.set_fonc_x

def ElAbs(v1: 'bool') -> "bool":
    return _mm3d.ElAbs(v1)
ElAbs = _mm3d.ElAbs

def ecart_frac(r: 'double') -> "double":
    return _mm3d.ecart_frac(r)
ecart_frac = _mm3d.ecart_frac

def VCube(V: 'double') -> "double":
    return _mm3d.VCube(V)
VCube = _mm3d.VCube

def VPow4(V: 'double') -> "double":
    return _mm3d.VPow4(V)
VPow4 = _mm3d.VPow4

def VPow5(V: 'double') -> "double":
    return _mm3d.VPow5(V)
VPow5 = _mm3d.VPow5

def VPow6(V: 'double') -> "double":
    return _mm3d.VPow6(V)
VPow6 = _mm3d.VPow6

def VPow7(V: 'double') -> "double":
    return _mm3d.VPow7(V)
VPow7 = _mm3d.VPow7
class cElRanGen(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElRanGen, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElRanGen, name)
    __repr__ = _swig_repr

    def cNRrandom3(self) -> "double":
        return _mm3d.cElRanGen_cNRrandom3(self)

    def cResetNRrand(self) -> "void":
        return _mm3d.cElRanGen_cResetNRrand(self)

    def cNRrandC(self) -> "double":
        return _mm3d.cElRanGen_cNRrandC(self)

    def __init__(self):
        this = _mm3d.new_cElRanGen()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitOfTime(self, aNb: 'int'=1000) -> "void":
        return _mm3d.cElRanGen_InitOfTime(self, aNb)
    __swig_destroy__ = _mm3d.delete_cElRanGen
    __del__ = lambda self: None
cElRanGen_swigregister = _mm3d.cElRanGen_swigregister
cElRanGen_swigregister(cElRanGen)

class cRandNParmiQ(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cRandNParmiQ, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cRandNParmiQ, name)
    __repr__ = _swig_repr

    def __init__(self, aN: 'int', aQ: 'int'):
        this = _mm3d.new_cRandNParmiQ(aN, aQ)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetNext(self) -> "bool":
        return _mm3d.cRandNParmiQ_GetNext(self)
    __swig_destroy__ = _mm3d.delete_cRandNParmiQ
    __del__ = lambda self: None
cRandNParmiQ_swigregister = _mm3d.cRandNParmiQ_swigregister
cRandNParmiQ_swigregister(cRandNParmiQ)


def RandPermut(aN: 'int') -> "std::vector< int,std::allocator< int > >":
    return _mm3d.RandPermut(aN)
RandPermut = _mm3d.RandPermut

def NRrandom3InitOfTime() -> "void":
    return _mm3d.NRrandom3InitOfTime()
NRrandom3InitOfTime = _mm3d.NRrandom3InitOfTime

def NRrandom3(*args) -> "double":
    return _mm3d.NRrandom3(*args)
NRrandom3 = _mm3d.NRrandom3

def NRrandC() -> "double":
    return _mm3d.NRrandC()
NRrandC = _mm3d.NRrandC

def ResetNRrand() -> "void":
    return _mm3d.ResetNRrand()
ResetNRrand = _mm3d.ResetNRrand

def rationnal_approx(arg1: 'double', arg2: 'int &', arg3: 'int &') -> "void":
    return _mm3d.rationnal_approx(arg1, arg2, arg3)
rationnal_approx = _mm3d.rationnal_approx
class ElTimer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElTimer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElTimer, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_ElTimer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def reinit(self) -> "void":
        return _mm3d.ElTimer_reinit(self)

    def uval(self) -> "double":
        return _mm3d.ElTimer_uval(self)

    def sval(self) -> "double":
        return _mm3d.ElTimer_sval(self)

    def ValAndInit(self) -> "double":
        return _mm3d.ElTimer_ValAndInit(self)

    def ValAbs(self) -> "double":
        return _mm3d.ElTimer_ValAbs(self)
    __swig_destroy__ = _mm3d.delete_ElTimer
    __del__ = lambda self: None
ElTimer_swigregister = _mm3d.ElTimer_swigregister
ElTimer_swigregister(ElTimer)


def ElTimeOfDay() -> "double":
    return _mm3d.ElTimeOfDay()
ElTimeOfDay = _mm3d.ElTimeOfDay
class ElTabFlag(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElTabFlag, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElTabFlag, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_ElTabFlag()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def kth(self, k: 'int') -> "bool":
        return _mm3d.ElTabFlag_kth(self, k)

    def set_kth_true(self, k: 'int') -> "void":
        return _mm3d.ElTabFlag_set_kth_true(self, k)

    def set_kth_false(self, k: 'int') -> "void":
        return _mm3d.ElTabFlag_set_kth_false(self, k)

    def set_kth(self, k: 'int', val: 'bool') -> "void":
        return _mm3d.ElTabFlag_set_kth(self, k, val)
    __swig_destroy__ = _mm3d.delete_ElTabFlag
    __del__ = lambda self: None
ElTabFlag_swigregister = _mm3d.ElTabFlag_swigregister
ElTabFlag_swigregister(ElTabFlag)

class ElFlagAllocator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElFlagAllocator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElFlagAllocator, name)
    __repr__ = _swig_repr

    def flag_alloc(self) -> "int":
        return _mm3d.ElFlagAllocator_flag_alloc(self)

    def flag_free(self, arg2: 'int') -> "void":
        return _mm3d.ElFlagAllocator_flag_free(self, arg2)

    def __init__(self):
        this = _mm3d.new_ElFlagAllocator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElFlagAllocator
    __del__ = lambda self: None
ElFlagAllocator_swigregister = _mm3d.ElFlagAllocator_swigregister
ElFlagAllocator_swigregister(ElFlagAllocator)


def CmpByEnd(aName1: 'char const *', aName2: 'char const *', aK1: 'int &', aK2: 'int &') -> "void":
    return _mm3d.CmpByEnd(aName1, aName2, aK1, aK2)
CmpByEnd = _mm3d.CmpByEnd

def N2IsEndN1(aName1: 'char const *', aName2: 'char const *') -> "bool":
    return _mm3d.N2IsEndN1(aName1, aName2)
N2IsEndN1 = _mm3d.N2IsEndN1

def ToStrBlkCorr(arg1: 'std::string const &') -> "std::string":
    return _mm3d.ToStrBlkCorr(arg1)
ToStrBlkCorr = _mm3d.ToStrBlkCorr

def StrToLower(aStr: 'std::string const &') -> "std::string":
    return _mm3d.StrToLower(aStr)
StrToLower = _mm3d.StrToLower

def IndPostfixed(*args) -> "int":
    return _mm3d.IndPostfixed(*args)
IndPostfixed = _mm3d.IndPostfixed

def StdPostfix(*args) -> "std::string":
    return _mm3d.StdPostfix(*args)
StdPostfix = _mm3d.StdPostfix

def StdPrefix(*args) -> "std::string":
    return _mm3d.StdPrefix(*args)
StdPrefix = _mm3d.StdPrefix

def StdPrefixGen(*args) -> "std::string":
    return _mm3d.StdPrefixGen(*args)
StdPrefixGen = _mm3d.StdPrefixGen

def NameWithoutDir(arg1: 'std::string const &') -> "std::string":
    return _mm3d.NameWithoutDir(arg1)
NameWithoutDir = _mm3d.NameWithoutDir

def ExtractDigit(aName: 'std::string const &', aDef: 'std::string const &') -> "std::string":
    return _mm3d.ExtractDigit(aName, aDef)
ExtractDigit = _mm3d.ExtractDigit

def IsPrefix(aPref: 'char const *', aStr: 'char const *') -> "bool":
    return _mm3d.IsPrefix(aPref, aStr)
IsPrefix = _mm3d.IsPrefix

def ToCommande(argc: 'int', argv: 'char **') -> "std::string":
    return _mm3d.ToCommande(argc, argv)
ToCommande = _mm3d.ToCommande

def QUOTE(aStr: 'std::string const &') -> "std::string":
    return _mm3d.QUOTE(aStr)
QUOTE = _mm3d.QUOTE

def GlobStdAdapt2Crochet(aStr: 'std::string &') -> "void":
    return _mm3d.GlobStdAdapt2Crochet(aStr)
GlobStdAdapt2Crochet = _mm3d.GlobStdAdapt2Crochet

def PATTERN_QUOTE(aStr: 'string const &') -> "string":
    return _mm3d.PATTERN_QUOTE(aStr)
PATTERN_QUOTE = _mm3d.PATTERN_QUOTE

def SplitIn2ArroundCar(a2Stplit: 'std::string const &', aSpliCar: 'char', aBefore: 'std::string &', aAfter: 'std::string &', AcceptNoCar: 'bool') -> "bool":
    return _mm3d.SplitIn2ArroundCar(a2Stplit, aSpliCar, aBefore, aAfter, AcceptNoCar)
SplitIn2ArroundCar = _mm3d.SplitIn2ArroundCar

def SplitInNArroundCar(a2Stplit: 'std::string const &', aSpliCar: 'char', aR0: 'std::string &', aRAux: 'StringVector') -> "void":
    return _mm3d.SplitInNArroundCar(a2Stplit, aSpliCar, aR0, aRAux)
SplitInNArroundCar = _mm3d.SplitInNArroundCar

def SplitIn2ArroundEq(a2Stplit: 'std::string const &', aBefore: 'std::string &', aAfter: 'std::string &') -> "void":
    return _mm3d.SplitIn2ArroundEq(a2Stplit, aBefore, aAfter)
SplitIn2ArroundEq = _mm3d.SplitIn2ArroundEq

def SplitDirAndFile(aNameDir: 'std::string &', aNameFile: 'std::string &', aStr: 'std::string const &') -> "void":
    return _mm3d.SplitDirAndFile(aNameDir, aNameFile, aStr)
SplitDirAndFile = _mm3d.SplitDirAndFile

def ToArgMain(aStr: 'std::string const &') -> "std::vector< char *,std::allocator< char * > >":
    return _mm3d.ToArgMain(aStr)
ToArgMain = _mm3d.ToArgMain

def AddPrePost(aName: 'std::string const &', aPref: 'std::string const &', aPost: 'std::string const &') -> "std::string":
    return _mm3d.AddPrePost(aName, aPref, aPost)
AddPrePost = _mm3d.AddPrePost

def DirOfFile(aStr: 'std::string const &') -> "std::string":
    return _mm3d.DirOfFile(aStr)
DirOfFile = _mm3d.DirOfFile

def StdWorkdDir(aValWD: 'std::string const &', aNameFile: 'std::string const &') -> "std::string":
    return _mm3d.StdWorkdDir(aValWD, aNameFile)
StdWorkdDir = _mm3d.StdWorkdDir

def VecStrFromFile(arg1: 'std::string const &') -> "std::vector< std::string,std::allocator< std::string > >":
    return _mm3d.VecStrFromFile(arg1)
VecStrFromFile = _mm3d.VecStrFromFile

def GetOneModifLC(argc: 'int', argv: 'char **', aNameSymb: 'std::string const &', aVal: 'std::string &') -> "bool":
    return _mm3d.GetOneModifLC(argc, argv, aNameSymb, aVal)
GetOneModifLC = _mm3d.GetOneModifLC

def MakeFileDirCompl(arg1: 'std::string &') -> "void":
    return _mm3d.MakeFileDirCompl(arg1)
MakeFileDirCompl = _mm3d.MakeFileDirCompl

def IsPostfixed(*args) -> "bool":
    return _mm3d.IsPostfixed(*args)
IsPostfixed = _mm3d.IsPostfixed

def IsPostfixedBy(arg1: 'std::string const &', arg2: 'std::string const &') -> "bool":
    return _mm3d.IsPostfixedBy(arg1, arg2)
IsPostfixedBy = _mm3d.IsPostfixedBy

def IsFileDmp(arg1: 'std::string const &') -> "bool":
    return _mm3d.IsFileDmp(arg1)
IsFileDmp = _mm3d.IsFileDmp

def EliseBRKP() -> "void":
    return _mm3d.EliseBRKP()
EliseBRKP = _mm3d.EliseBRKP

def ToStringNBD(aNb: 'int', aNbDig: 'int') -> "std::string":
    return _mm3d.ToStringNBD(aNb, aNbDig)
ToStringNBD = _mm3d.ToStringNBD
class cElStatErreur(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElStatErreur, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElStatErreur, name)
    __repr__ = _swig_repr

    def __init__(self, NbValInit: 'int'):
        this = _mm3d.new_cElStatErreur(NbValInit)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddErreur(self, arg2: 'double') -> "void":
        return _mm3d.cElStatErreur_AddErreur(self, arg2)

    def Reset(self) -> "void":
        return _mm3d.cElStatErreur_Reset(self)

    def Erreur(self, Pos: 'double') -> "double":
        return _mm3d.cElStatErreur_Erreur(self, Pos)

    def Avg(self) -> "double":
        return _mm3d.cElStatErreur_Avg(self)

    def Ect(self) -> "double":
        return _mm3d.cElStatErreur_Ect(self)
    __swig_destroy__ = _mm3d.delete_cElStatErreur
    __del__ = lambda self: None
cElStatErreur_swigregister = _mm3d.cElStatErreur_swigregister
cElStatErreur_swigregister(cElStatErreur)

class cDecoupageInterv1D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDecoupageInterv1D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cDecoupageInterv1D, name)
    __repr__ = _swig_repr

    def __init__(self, aIntervGlob: 'cInterv1D< int > const &', aSzMax: 'int', aSzBord: 'cInterv1D< int > const &', anArrondi: 'int'=1):
        this = _mm3d.new_cDecoupageInterv1D(aIntervGlob, aSzMax, aSzBord, anArrondi)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbInterv(self) -> "int":
        return _mm3d.cDecoupageInterv1D_NbInterv(self)

    def KthIntervOut(self, aK: 'int') -> "cInterv1D< int >":
        return _mm3d.cDecoupageInterv1D_KthIntervOut(self, aK)

    def KthIntervIn(self, *args) -> "cInterv1D< int >":
        return _mm3d.cDecoupageInterv1D_KthIntervIn(self, *args)

    def IGlob(self) -> "cInterv1D< int > const &":
        return _mm3d.cDecoupageInterv1D_IGlob(self)

    def IBrd(self) -> "cInterv1D< int > const &":
        return _mm3d.cDecoupageInterv1D_IBrd(self)

    def LargMaxOut(self) -> "int":
        return _mm3d.cDecoupageInterv1D_LargMaxOut(self)

    def LargMaxIn(self, *args) -> "int":
        return _mm3d.cDecoupageInterv1D_LargMaxIn(self, *args)
    __swig_destroy__ = _mm3d.delete_cDecoupageInterv1D
    __del__ = lambda self: None
cDecoupageInterv1D_swigregister = _mm3d.cDecoupageInterv1D_swigregister
cDecoupageInterv1D_swigregister(cDecoupageInterv1D)

class tFileOffset(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tFileOffset, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tFileOffset, name)
    __repr__ = _swig_repr

    def CKK_AbsLLO(self) -> "tLowLevelFileOffset const &":
        return _mm3d.tFileOffset_CKK_AbsLLO(self)

    def CKK_Byte4AbsLLO(self) -> "tByte4AbsFileOffset":
        return _mm3d.tFileOffset_CKK_Byte4AbsLLO(self)

    def BasicLLO(self) -> "tLowLevelFileOffset const &":
        return _mm3d.tFileOffset_BasicLLO(self)

    def CKK_IntBasicLLO(self) -> "int":
        return _mm3d.tFileOffset_CKK_IntBasicLLO(self)

    def __init__(self, *args):
        this = _mm3d.new_tFileOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __add__(self, anO2: 'tFileOffset') -> "tFileOffset":
        return _mm3d.tFileOffset___add__(self, anO2)

    def __sub__(self, anO2: 'tFileOffset') -> "tFileOffset":
        return _mm3d.tFileOffset___sub__(self, anO2)

    def __truediv__(self, *args):
        return _mm3d.tFileOffset___truediv__(self, *args)
    __div__ = __truediv__



    def __mul__(self, anO2: 'tFileOffset') -> "tFileOffset":
        return _mm3d.tFileOffset___mul__(self, anO2)

    def __lt__(self, anO2: 'tFileOffset') -> "bool":
        return _mm3d.tFileOffset___lt__(self, anO2)

    def __gt__(self, anO2: 'tFileOffset') -> "bool":
        return _mm3d.tFileOffset___gt__(self, anO2)

    def __eq__(self, anO2: 'tFileOffset') -> "bool":
        return _mm3d.tFileOffset___eq__(self, anO2)

    def __ne__(self, anO2: 'tFileOffset') -> "bool":
        return _mm3d.tFileOffset___ne__(self, anO2)

    def __iadd__(self, anO2: 'tFileOffset') -> "void":
        return _mm3d.tFileOffset___iadd__(self, anO2)

    def __isub__(self, anO2: 'tFileOffset') -> "void":
        return _mm3d.tFileOffset___isub__(self, anO2)

    def __imul__(self, anO2: 'tFileOffset') -> "void":
        return _mm3d.tFileOffset___imul__(self, anO2)

    def IsInit(self) -> "bool":
        return _mm3d.tFileOffset_IsInit(self)
    if _newclass:
        CKK_FromReinterpretInt = staticmethod(_mm3d.tFileOffset_CKK_FromReinterpretInt)
    else:
        CKK_FromReinterpretInt = _mm3d.tFileOffset_CKK_FromReinterpretInt

    def CKK_ToReinterpretInt(self) -> "int":
        return _mm3d.tFileOffset_CKK_ToReinterpretInt(self)
    __swig_destroy__ = _mm3d.delete_tFileOffset
    __del__ = lambda self: None
tFileOffset_swigregister = _mm3d.tFileOffset_swigregister
tFileOffset_swigregister(tFileOffset)

def tFileOffset_CKK_FromReinterpretInt(anI: 'int') -> "tFileOffset":
    return _mm3d.tFileOffset_CKK_FromReinterpretInt(anI)
tFileOffset_CKK_FromReinterpretInt = _mm3d.tFileOffset_CKK_FromReinterpretInt
tFileOffset.NoOffset = _mm3d.cvar.tFileOffset_NoOffset


def RelToAbs(anOff: 'tFileOffset') -> "tFileOffset":
    return _mm3d.RelToAbs(anOff)
RelToAbs = _mm3d.RelToAbs
class cFonc1D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cFonc1D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cFonc1D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __call__(self, arg2: 'int const &') -> "int":
        return _mm3d.cFonc1D___call__(self, arg2)
    __swig_destroy__ = _mm3d.delete_cFonc1D
    __del__ = lambda self: None
cFonc1D_swigregister = _mm3d.cFonc1D_swigregister
cFonc1D_swigregister(cFonc1D)

class cFonc1D_HomTr(cFonc1D):
    __swig_setmethods__ = {}
    for _s in [cFonc1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cFonc1D_HomTr, name, value)
    __swig_getmethods__ = {}
    for _s in [cFonc1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cFonc1D_HomTr, name)
    __repr__ = _swig_repr

    def __call__(self, arg2: 'int const &') -> "int":
        return _mm3d.cFonc1D_HomTr___call__(self, arg2)

    def __init__(self, anA: 'int const &', aB: 'int const &', aC: 'int const &'):
        this = _mm3d.new_cFonc1D_HomTr(anA, aB, aC)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cFonc1D_HomTr
    __del__ = lambda self: None
cFonc1D_HomTr_swigregister = _mm3d.cFonc1D_HomTr_swigregister
cFonc1D_HomTr_swigregister(cFonc1D_HomTr)

class cEquiv1D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cEquiv1D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cEquiv1D, name)
    __repr__ = _swig_repr

    def InitFromFctr(self, aV0: 'int', aV1: 'int', arg4: 'cFonc1D') -> "void":
        return _mm3d.cEquiv1D_InitFromFctr(self, aV0, aV1, arg4)

    def InitByFusion(self, arg2: 'cEquiv1D', aFus: 'int') -> "void":
        return _mm3d.cEquiv1D_InitByFusion(self, arg2, aFus)

    def __init__(self, *args):
        this = _mm3d.new_cEquiv1D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitByClipAndTr(self, arg2: 'cEquiv1D', aHomOfNewV0: 'int', aNewV0: 'int', aNewV1: 'int') -> "void":
        return _mm3d.cEquiv1D_InitByClipAndTr(self, arg2, aHomOfNewV0, aNewV0, aNewV1)

    def InitByDeZoom(self, arg2: 'cEquiv1D', aDz: 'int', mLut: 'cVectTr< int > *') -> "void":
        return _mm3d.cEquiv1D_InitByDeZoom(self, arg2, aDz, mLut)

    def NbClasses(self) -> "int":
        return _mm3d.cEquiv1D_NbClasses(self)

    def V0(self) -> "int":
        return _mm3d.cEquiv1D_V0(self)

    def V1(self) -> "int":
        return _mm3d.cEquiv1D_V1(self)

    def NumClasse(self, aV: 'int const &') -> "int":
        return _mm3d.cEquiv1D_NumClasse(self, aV)

    def ClasseOfNum(self, aV0: 'int &', aV1: 'int &', aNCL: 'int const &') -> "void":
        return _mm3d.cEquiv1D_ClasseOfNum(self, aV0, aV1, aNCL)

    def SzMaxClasses(self) -> "int":
        return _mm3d.cEquiv1D_SzMaxClasses(self)
    __swig_destroy__ = _mm3d.delete_cEquiv1D
    __del__ = lambda self: None
cEquiv1D_swigregister = _mm3d.cEquiv1D_swigregister
cEquiv1D_swigregister(cEquiv1D)

class cElTask(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElTask, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElTask, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddDep(self, *args) -> "void":
        return _mm3d.cElTask_AddDep(self, *args)

    def AddBR(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cElTask_AddBR(self, arg2)

    def GenerateMakeFile(self, arg2: 'FILE *') -> "void":
        return _mm3d.cElTask_GenerateMakeFile(self, arg2)
    __swig_destroy__ = _mm3d.delete_cElTask
    __del__ = lambda self: None
cElTask_swigregister = _mm3d.cElTask_swigregister
cElTask_swigregister(cElTask)

class cEl_GPAO(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cEl_GPAO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cEl_GPAO, name)
    __repr__ = _swig_repr
    if _newclass:
        DoComInParal = staticmethod(_mm3d.cEl_GPAO_DoComInParal)
    else:
        DoComInParal = _mm3d.cEl_GPAO_DoComInParal
    if _newclass:
        DoComInSerie = staticmethod(_mm3d.cEl_GPAO_DoComInSerie)
    else:
        DoComInSerie = _mm3d.cEl_GPAO_DoComInSerie
    __swig_destroy__ = _mm3d.delete_cEl_GPAO
    __del__ = lambda self: None

    def __init__(self):
        this = _mm3d.new_cEl_GPAO()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NewTask(self, aName: 'std::string const &', aBuildingRule: 'std::string const &') -> "cElTask &":
        return _mm3d.cEl_GPAO_NewTask(self, aName, aBuildingRule)

    def GetOrCreate(self, aName: 'std::string const &', aBuildingRule: 'std::string const &') -> "cElTask &":
        return _mm3d.cEl_GPAO_GetOrCreate(self, aName, aBuildingRule)

    def TaskOfName(self, aName: 'std::string const &') -> "cElTask &":
        return _mm3d.cEl_GPAO_TaskOfName(self, aName)

    def GenerateMakeFile(self, *args) -> "void":
        return _mm3d.cEl_GPAO_GenerateMakeFile(self, *args)

    def ExeParal(self, aFile: 'std::string', aNbProc: 'int'=-1, SuprFile: 'bool'=True) -> "void":
        return _mm3d.cEl_GPAO_ExeParal(self, aFile, aNbProc, SuprFile)

    def dump(self, *args) -> "void":
        return _mm3d.cEl_GPAO_dump(self, *args)
cEl_GPAO_swigregister = _mm3d.cEl_GPAO_swigregister
cEl_GPAO_swigregister(cEl_GPAO)

def cEl_GPAO_DoComInParal(*args) -> "void":
    return _mm3d.cEl_GPAO_DoComInParal(*args)
cEl_GPAO_DoComInParal = _mm3d.cEl_GPAO_DoComInParal

def cEl_GPAO_DoComInSerie(arg2: 'std::list< std::string,std::allocator< std::string > > const &') -> "void":
    return _mm3d.cEl_GPAO_DoComInSerie(arg2)
cEl_GPAO_DoComInSerie = _mm3d.cEl_GPAO_DoComInSerie


def MkFMapCmdFileCoul8B(aDir: 'std::string const &', aSet: 'StringVector') -> "void":
    return _mm3d.MkFMapCmdFileCoul8B(aDir, aSet)
MkFMapCmdFileCoul8B = _mm3d.MkFMapCmdFileCoul8B

def RequireBin(*args) -> "void":
    return _mm3d.RequireBin(*args)
RequireBin = _mm3d.RequireBin

def TopSystem(aComOri: 'std::string const &') -> "int":
    return _mm3d.TopSystem(aComOri)
TopSystem = _mm3d.TopSystem
DEF_SVP_System = _mm3d.DEF_SVP_System
DEF_AdaptGlob_System = _mm3d.DEF_AdaptGlob_System

def System(aCom: 'std::string const &', aSVP: 'bool'=False, AddOptGlob: 'bool'=False, UseTheNbIterProcess: 'bool'=False) -> "int":
    return _mm3d.System(aCom, aSVP, AddOptGlob, UseTheNbIterProcess)
System = _mm3d.System
class cAppliBatch(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cAppliBatch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cAppliBatch, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    eExeDoNothing = _mm3d.cAppliBatch_eExeDoNothing
    eExeDoIfFileDontExist = _mm3d.cAppliBatch_eExeDoIfFileDontExist
    eExeDoSys = _mm3d.cAppliBatch_eExeDoSys
    eExeWriteBatch = _mm3d.cAppliBatch_eExeWriteBatch
    eNoPurge = _mm3d.cAppliBatch_eNoPurge
    ePurgeTmp = _mm3d.cAppliBatch_ePurgeTmp
    ePurgeAll = _mm3d.cAppliBatch_ePurgeAll

    def DoAll(self) -> "void":
        return _mm3d.cAppliBatch_DoAll(self)

    def GPAO(self) -> "cEl_GPAO &":
        return _mm3d.cAppliBatch_GPAO(self)

    def ByMKf(self) -> "bool":
        return _mm3d.cAppliBatch_ByMKf(self)

    def MKf(self) -> "std::string const &":
        return _mm3d.cAppliBatch_MKf(self)

    def IsRelancedByThis(self) -> "bool":
        return _mm3d.cAppliBatch_IsRelancedByThis(self)
cAppliBatch_swigregister = _mm3d.cAppliBatch_swigregister
cAppliBatch_swigregister(cAppliBatch)

class cCpleString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCpleString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cCpleString, name)
    __repr__ = _swig_repr

    def AddPrePost(self, aPre: 'std::string const &', aPost: 'std::string const &') -> "cCpleString":
        return _mm3d.cCpleString_AddPrePost(self, aPre, aPost)

    def __init__(self, *args):
        this = _mm3d.new_cCpleString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def N1(self) -> "std::string const &":
        return _mm3d.cCpleString_N1(self)

    def N2(self) -> "std::string const &":
        return _mm3d.cCpleString_N2(self)

    def __lt__(self, arg2: 'cCpleString') -> "bool":
        return _mm3d.cCpleString___lt__(self, arg2)

    def __eq__(self, arg2: 'cCpleString') -> "bool":
        return _mm3d.cCpleString___eq__(self, arg2)
    __swig_destroy__ = _mm3d.delete_cCpleString
    __del__ = lambda self: None
cCpleString_swigregister = _mm3d.cCpleString_swigregister
cCpleString_swigregister(cCpleString)

class cMonomXY(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cMonomXY, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cMonomXY, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_cMonomXY(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["mCoeff"] = _mm3d.cMonomXY_mCoeff_set
    __swig_getmethods__["mCoeff"] = _mm3d.cMonomXY_mCoeff_get
    if _newclass:
        mCoeff = _swig_property(_mm3d.cMonomXY_mCoeff_get, _mm3d.cMonomXY_mCoeff_set)
    __swig_setmethods__["mDegX"] = _mm3d.cMonomXY_mDegX_set
    __swig_getmethods__["mDegX"] = _mm3d.cMonomXY_mDegX_get
    if _newclass:
        mDegX = _swig_property(_mm3d.cMonomXY_mDegX_get, _mm3d.cMonomXY_mDegX_set)
    __swig_setmethods__["mDegY"] = _mm3d.cMonomXY_mDegY_set
    __swig_getmethods__["mDegY"] = _mm3d.cMonomXY_mDegY_get
    if _newclass:
        mDegY = _swig_property(_mm3d.cMonomXY_mDegY_get, _mm3d.cMonomXY_mDegY_set)
    __swig_destroy__ = _mm3d.delete_cMonomXY
    __del__ = lambda self: None
cMonomXY_swigregister = _mm3d.cMonomXY_swigregister
cMonomXY_swigregister(cMonomXY)

class cElHour(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElHour, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElHour, name)
    __repr__ = _swig_repr

    def ToXml(self) -> "cXmlHour":
        return _mm3d.cElHour_ToXml(self)
    if _newclass:
        FromXml = staticmethod(_mm3d.cElHour_FromXml)
    else:
        FromXml = _mm3d.cElHour_FromXml

    def __init__(self, *args):
        this = _mm3d.new_cElHour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InSec(self) -> "double":
        return _mm3d.cElHour_InSec(self)

    def H(self) -> "int":
        return _mm3d.cElHour_H(self)

    def M(self) -> "int":
        return _mm3d.cElHour_M(self)

    def S(self) -> "double":
        return _mm3d.cElHour_S(self)

    def __eq__(self, i_b: 'cElHour') -> "bool":
        return _mm3d.cElHour___eq__(self, i_b)

    def __ne__(self, i_b: 'cElHour') -> "bool":
        return _mm3d.cElHour___ne__(self, i_b)

    def from_raw_data(self, io_rawData: 'char const *&', i_reverseByteOrder: 'bool') -> "void":
        return _mm3d.cElHour_from_raw_data(self, io_rawData, i_reverseByteOrder)

    def to_raw_data(self, i_reverseByteOrder: 'bool', o_rawData: 'char *&') -> "void":
        return _mm3d.cElHour_to_raw_data(self, i_reverseByteOrder, o_rawData)
    if _newclass:
        raw_size = staticmethod(_mm3d.cElHour_raw_size)
    else:
        raw_size = _mm3d.cElHour_raw_size

    def read_raw(self, io_istream: 'istream &', i_inverseByteOrder: 'bool') -> "void":
        return _mm3d.cElHour_read_raw(self, io_istream, i_inverseByteOrder)

    def write_raw(self, io_ostream: 'ostream &', i_inverseByteOrder: 'bool') -> "void":
        return _mm3d.cElHour_write_raw(self, io_ostream, i_inverseByteOrder)
    if _newclass:
        getCurrentHour_local = staticmethod(_mm3d.cElHour_getCurrentHour_local)
    else:
        getCurrentHour_local = _mm3d.cElHour_getCurrentHour_local
    if _newclass:
        getCurrentHour_UTC = staticmethod(_mm3d.cElHour_getCurrentHour_UTC)
    else:
        getCurrentHour_UTC = _mm3d.cElHour_getCurrentHour_UTC
    __swig_destroy__ = _mm3d.delete_cElHour
    __del__ = lambda self: None
cElHour_swigregister = _mm3d.cElHour_swigregister
cElHour_swigregister(cElHour)

def cElHour_FromXml(arg2: 'cXmlHour const &') -> "cElHour":
    return _mm3d.cElHour_FromXml(arg2)
cElHour_FromXml = _mm3d.cElHour_FromXml

def cElHour_raw_size() -> "unsigned int":
    return _mm3d.cElHour_raw_size()
cElHour_raw_size = _mm3d.cElHour_raw_size

def cElHour_getCurrentHour_local(o_localHour: 'cElHour') -> "void":
    return _mm3d.cElHour_getCurrentHour_local(o_localHour)
cElHour_getCurrentHour_local = _mm3d.cElHour_getCurrentHour_local

def cElHour_getCurrentHour_UTC(o_utcHour: 'cElHour') -> "void":
    return _mm3d.cElHour_getCurrentHour_UTC(o_utcHour)
cElHour_getCurrentHour_UTC = _mm3d.cElHour_getCurrentHour_UTC

class cElDate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElDate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElDate, name)
    __repr__ = _swig_repr

    def ToXml(self) -> "cXmlDate":
        return _mm3d.cElDate_ToXml(self)
    if _newclass:
        FromXml = staticmethod(_mm3d.cElDate_FromXml)
    else:
        FromXml = _mm3d.cElDate_FromXml

    def IsNoDate(self) -> "bool":
        return _mm3d.cElDate_IsNoDate(self)

    def __init__(self, *args):
        this = _mm3d.new_cElDate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def H(self) -> "cElHour const &":
        return _mm3d.cElDate_H(self)

    def Y(self) -> "int":
        return _mm3d.cElDate_Y(self)

    def M(self) -> "int":
        return _mm3d.cElDate_M(self)

    def D(self) -> "int":
        return _mm3d.cElDate_D(self)
    if _newclass:
        FromString = staticmethod(_mm3d.cElDate_FromString)
    else:
        FromString = _mm3d.cElDate_FromString

    def NbDayFrom1erJ(self) -> "int":
        return _mm3d.cElDate_NbDayFrom1erJ(self)

    def NbDayFromJC(self) -> "int":
        return _mm3d.cElDate_NbDayFromJC(self)

    def DifInDay(self, arg2: 'cElDate') -> "int":
        return _mm3d.cElDate_DifInDay(self, arg2)

    def DifInSec(self, arg2: 'cElDate') -> "double":
        return _mm3d.cElDate_DifInSec(self, arg2)

    def __eq__(self, i_b: 'cElDate') -> "bool":
        return _mm3d.cElDate___eq__(self, i_b)

    def __ne__(self, i_b: 'cElDate') -> "bool":
        return _mm3d.cElDate___ne__(self, i_b)

    def from_raw_data(self, io_rawData: 'char const *&', i_reverseByteOrder: 'bool') -> "void":
        return _mm3d.cElDate_from_raw_data(self, io_rawData, i_reverseByteOrder)

    def to_raw_data(self, i_reverseByteOrder: 'bool', o_rawData: 'char *&') -> "void":
        return _mm3d.cElDate_to_raw_data(self, i_reverseByteOrder, o_rawData)
    if _newclass:
        raw_size = staticmethod(_mm3d.cElDate_raw_size)
    else:
        raw_size = _mm3d.cElDate_raw_size

    def read_raw(self, io_istream: 'istream &', i_inverseByteOrder: 'bool'=False) -> "void":
        return _mm3d.cElDate_read_raw(self, io_istream, i_inverseByteOrder)

    def write_raw(self, io_ostream: 'ostream &', i_inverseByteOrder: 'bool'=False) -> "void":
        return _mm3d.cElDate_write_raw(self, io_ostream, i_inverseByteOrder)
    if _newclass:
        getCurrentDate_local = staticmethod(_mm3d.cElDate_getCurrentDate_local)
    else:
        getCurrentDate_local = _mm3d.cElDate_getCurrentDate_local
    if _newclass:
        getCurrentDate_UTC = staticmethod(_mm3d.cElDate_getCurrentDate_UTC)
    else:
        getCurrentDate_UTC = _mm3d.cElDate_getCurrentDate_UTC
    __swig_destroy__ = _mm3d.delete_cElDate
    __del__ = lambda self: None
cElDate_swigregister = _mm3d.cElDate_swigregister
cElDate_swigregister(cElDate)

def cElDate_FromXml(arg2: 'cXmlDate const &') -> "cElDate":
    return _mm3d.cElDate_FromXml(arg2)
cElDate_FromXml = _mm3d.cElDate_FromXml
cElDate.NoDate = _mm3d.cvar.cElDate_NoDate

def cElDate_FromString(arg2: 'std::string const &') -> "cElDate":
    return _mm3d.cElDate_FromString(arg2)
cElDate_FromString = _mm3d.cElDate_FromString

def cElDate_raw_size() -> "unsigned int":
    return _mm3d.cElDate_raw_size()
cElDate_raw_size = _mm3d.cElDate_raw_size

def cElDate_getCurrentDate_local(o_localDate: 'cElDate') -> "void":
    return _mm3d.cElDate_getCurrentDate_local(o_localDate)
cElDate_getCurrentDate_local = _mm3d.cElDate_getCurrentDate_local

def cElDate_getCurrentDate_UTC(o_utcDate: 'cElDate') -> "void":
    return _mm3d.cElDate_getCurrentDate_UTC(o_utcDate)
cElDate_getCurrentDate_UTC = _mm3d.cElDate_getCurrentDate_UTC

class cINT8ImplemSetInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cINT8ImplemSetInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cINT8ImplemSetInt, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cINT8ImplemSetInt()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, anInt: 'int') -> "void":
        return _mm3d.cINT8ImplemSetInt_Add(self, anInt)

    def IsIn(self, anInt: 'int') -> "bool":
        return _mm3d.cINT8ImplemSetInt_IsIn(self, anInt)

    def NumOrdre(self, *args) -> "int":
        return _mm3d.cINT8ImplemSetInt_NumOrdre(self, *args)
    if _newclass:
        Capacite = staticmethod(_mm3d.cINT8ImplemSetInt_Capacite)
    else:
        Capacite = _mm3d.cINT8ImplemSetInt_Capacite

    def __lt__(self, arg2: 'cINT8ImplemSetInt') -> "bool":
        return _mm3d.cINT8ImplemSetInt___lt__(self, arg2)
    __swig_destroy__ = _mm3d.delete_cINT8ImplemSetInt
    __del__ = lambda self: None
cINT8ImplemSetInt_swigregister = _mm3d.cINT8ImplemSetInt_swigregister
cINT8ImplemSetInt_swigregister(cINT8ImplemSetInt)

def cINT8ImplemSetInt_Capacite() -> "int":
    return _mm3d.cINT8ImplemSetInt_Capacite()
cINT8ImplemSetInt_Capacite = _mm3d.cINT8ImplemSetInt_Capacite

class cVarSetIntMultiple(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cVarSetIntMultiple, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cVarSetIntMultiple, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cVarSetIntMultiple()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, anInt: 'int') -> "void":
        return _mm3d.cVarSetIntMultiple_Add(self, anInt)

    def IsIn(self, anInt: 'int') -> "bool":
        return _mm3d.cVarSetIntMultiple_IsIn(self, anInt)

    def NumOrdre(self, aI: 'int') -> "int":
        return _mm3d.cVarSetIntMultiple_NumOrdre(self, aI)

    def __lt__(self, arg2: 'cVarSetIntMultiple') -> "bool":
        return _mm3d.cVarSetIntMultiple___lt__(self, arg2)

    def Capacite(self) -> "int":
        return _mm3d.cVarSetIntMultiple_Capacite(self)
    __swig_destroy__ = _mm3d.delete_cVarSetIntMultiple
    __del__ = lambda self: None
cVarSetIntMultiple_swigregister = _mm3d.cVarSetIntMultiple_swigregister
cVarSetIntMultiple_swigregister(cVarSetIntMultiple)


def TransFormArgKey(aName: 'std::string &', AMMNoArg: 'bool', aDirExt: 'StringVector') -> "bool":
    return _mm3d.TransFormArgKey(aName, AMMNoArg, aDirExt)
TransFormArgKey = _mm3d.TransFormArgKey

def ComputeIntervaleDelta(aDzMin: 'int &', aDzMax: 'int &', aZ: 'int', MaxDeltaZ: 'int', aZ1Min: 'int', aZ1Max: 'int', aZ0Min: 'int', aZ0Max: 'int') -> "void":
    return _mm3d.ComputeIntervaleDelta(aDzMin, aDzMax, aZ, MaxDeltaZ, aZ1Min, aZ1Max, aZ0Min, aZ0Max)
ComputeIntervaleDelta = _mm3d.ComputeIntervaleDelta

def BasicComputeIntervaleDelta(aDzMin: 'int &', aDzMax: 'int &', aZ: 'int', MaxDeltaZ: 'int', aZ0Min: 'int', aZ0Max: 'int') -> "void":
    return _mm3d.BasicComputeIntervaleDelta(aDzMin, aDzMax, aZ, MaxDeltaZ, aZ0Min, aZ0Max)
BasicComputeIntervaleDelta = _mm3d.BasicComputeIntervaleDelta

def FromSzW2FactExp(aSzW: 'double', mCurNbIterFenSpec: 'double') -> "double":
    return _mm3d.FromSzW2FactExp(aSzW, mCurNbIterFenSpec)
FromSzW2FactExp = _mm3d.FromSzW2FactExp

def getBanniereMM3D() -> "std::string":
    return _mm3d.getBanniereMM3D()
getBanniereMM3D = _mm3d.getBanniereMM3D

def BanniereMM3D() -> "void":
    return _mm3d.BanniereMM3D()
BanniereMM3D = _mm3d.BanniereMM3D

def ElFopen(path: 'char const *', mode: 'char const *') -> "FILE *":
    return _mm3d.ElFopen(path, mode)
ElFopen = _mm3d.ElFopen

def ElFclose(fp: 'FILE *') -> "int":
    return _mm3d.ElFclose(fp)
ElFclose = _mm3d.ElFclose

def ShowFClose() -> "void":
    return _mm3d.ShowFClose()
ShowFClose = _mm3d.ShowFClose

def GetSubset(aRes: 'std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &', aNb: 'int', aMax: 'int') -> "void":
    return _mm3d.GetSubset(aRes, aNb, aMax)
GetSubset = _mm3d.GetSubset

def ElGetStrSys(i_base_cmd: 'std::string const &', o_result: 'std::string &') -> "bool":
    return _mm3d.ElGetStrSys(i_base_cmd, o_result)
ElGetStrSys = _mm3d.ElGetStrSys

def protect_spaces(i_str: 'string const &') -> "string":
    return _mm3d.protect_spaces(i_str)
protect_spaces = _mm3d.protect_spaces

def MMNbProc() -> "int":
    return _mm3d.MMNbProc()
MMNbProc = _mm3d.MMNbProc

def launchMake(*args) -> "bool":
    return _mm3d.launchMake(*args)
launchMake = _mm3d.launchMake

def MoyHarmonik(*args) -> "double":
    return _mm3d.MoyHarmonik(*args)
MoyHarmonik = _mm3d.MoyHarmonik

def getSystemMemory() -> "size_t":
    return _mm3d.getSystemMemory()
getSystemMemory = _mm3d.getSystemMemory

def getUsedMemory() -> "size_t":
    return _mm3d.getUsedMemory()
getUsedMemory = _mm3d.getUsedMemory

def humanReadable(aSize: 'size_t') -> "std::string":
    return _mm3d.humanReadable(aSize)
humanReadable = _mm3d.humanReadable

def gitRevision() -> "std::string":
    return _mm3d.gitRevision()
gitRevision = _mm3d.gitRevision

def AdjUC(*args) -> "int":
    return _mm3d.AdjUC(*args)
AdjUC = _mm3d.AdjUC
class GenIm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenIm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenIm, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def same_dim_and_sz(self, arg2: 'GenIm') -> "bool":
        return _mm3d.GenIm_same_dim_and_sz(self, arg2)
    __swig_destroy__ = _mm3d.delete_GenIm
    __del__ = lambda self: None
    u_int1 = _mm3d.GenIm_u_int1
    int1 = _mm3d.GenIm_int1
    u_int2 = _mm3d.GenIm_u_int2
    int2 = _mm3d.GenIm_int2
    int4 = _mm3d.GenIm_int4
    real4 = _mm3d.GenIm_real4
    real8 = _mm3d.GenIm_real8
    bits1_msbf = _mm3d.GenIm_bits1_msbf
    bits2_msbf = _mm3d.GenIm_bits2_msbf
    bits4_msbf = _mm3d.GenIm_bits4_msbf
    bits1_lsbf = _mm3d.GenIm_bits1_lsbf
    bits2_lsbf = _mm3d.GenIm_bits2_lsbf
    bits4_lsbf = _mm3d.GenIm_bits4_lsbf
    real16 = _mm3d.GenIm_real16
    int8 = _mm3d.GenIm_int8
    u_int4 = _mm3d.GenIm_u_int4
    u_int8 = _mm3d.GenIm_u_int8
    no_type = _mm3d.GenIm_no_type

    def _in(self, *args) -> "Fonc_Num":
        return _mm3d.GenIm__in(self, *args)

    def in_proj(self) -> "Fonc_Num":
        return _mm3d.GenIm_in_proj(self)

    def oclip(self) -> "Output":
        return _mm3d.GenIm_oclip(self)

    def out(self) -> "Output":
        return _mm3d.GenIm_out(self)

    def data_lin(self) -> "void *":
        return _mm3d.GenIm_data_lin(self)

    def P1(self) -> "int const *":
        return _mm3d.GenIm_P1(self)

    def histo(self, auto_clip: 'bool'=False) -> "Output":
        return _mm3d.GenIm_histo(self, auto_clip)

    def sum_eg(self, auto_clip: 'bool'=False) -> "Output":
        return _mm3d.GenIm_sum_eg(self, auto_clip)

    def max_eg(self, auto_clip: 'bool'=False) -> "Output":
        return _mm3d.GenIm_max_eg(self, auto_clip)

    def min_eg(self, auto_clip: 'bool'=False) -> "Output":
        return _mm3d.GenIm_min_eg(self, auto_clip)

    def mul_eg(self, auto_clip: 'bool'=False) -> "Output":
        return _mm3d.GenIm_mul_eg(self, auto_clip)

    def oper_ass_eg(self, op: 'OperAssocMixte const &', auto_clip: 'bool') -> "Output":
        return _mm3d.GenIm_oper_ass_eg(self, op, auto_clip)

    def read_data(self, fp: 'ELISE_fp &') -> "void":
        return _mm3d.GenIm_read_data(self, fp)

    def write_data(self, fp: 'ELISE_fp &') -> "void":
        return _mm3d.GenIm_write_data(self, fp)
GenIm_swigregister = _mm3d.GenIm_swigregister
GenIm_swigregister(GenIm)


def type_elToString(arg1: 'GenIm::type_el') -> "string":
    return _mm3d.type_elToString(arg1)
type_elToString = _mm3d.type_elToString
class cFoncI2D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cFoncI2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cFoncI2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Val(self, x: 'int const &', y: 'int const &') -> "double":
        return _mm3d.cFoncI2D_Val(self, x, y)

    def BoxDef(self) -> "Box2di":
        return _mm3d.cFoncI2D_BoxDef(self)
    __swig_destroy__ = _mm3d.delete_cFoncI2D
    __del__ = lambda self: None
cFoncI2D_swigregister = _mm3d.cFoncI2D_swigregister
cFoncI2D_swigregister(cFoncI2D)

class Im2DGen(GenIm, cFoncI2D):
    __swig_setmethods__ = {}
    for _s in [GenIm, cFoncI2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Im2DGen, name, value)
    __swig_getmethods__ = {}
    for _s in [GenIm, cFoncI2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Im2DGen, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _mm3d.delete_Im2DGen
    __del__ = lambda self: None

    def TypeEl(self) -> "GenIm::type_el":
        return _mm3d.Im2DGen_TypeEl(self)

    def OptimizeSegTournantSomIm(self, score: 'double &', seg: 'Seg2d', NbPts: 'int', step_init: 'double', step_limite: 'double', optim_absc: 'bool'=True, optim_teta: 'bool'=True, FreelyOpt: 'bool *'=None) -> "Seg2d":
        return _mm3d.Im2DGen_OptimizeSegTournantSomIm(self, score, seg, NbPts, step_init, step_limite, optim_absc, optim_teta, FreelyOpt)

    def tx(self) -> "int":
        return _mm3d.Im2DGen_tx(self)

    def ty(self) -> "int":
        return _mm3d.Im2DGen_ty(self)

    def sz(self) -> "Pt2di":
        return _mm3d.Im2DGen_sz(self)

    def ImBox2d(self, *args) -> "Box2di":
        return _mm3d.Im2DGen_ImBox2d(self, *args)

    def TronqueAndSet(self, arg2: 'Pt2di', aVal: 'double') -> "void":
        return _mm3d.Im2DGen_TronqueAndSet(self, arg2, aVal)

    def MoyG2(self) -> "double":
        return _mm3d.Im2DGen_MoyG2(self)

    def vmax(self) -> "int":
        return _mm3d.Im2DGen_vmax(self)

    def vmin(self) -> "int":
        return _mm3d.Im2DGen_vmin(self)

    def BilinIm(self) -> "cIm2DInter *":
        return _mm3d.Im2DGen_BilinIm(self)

    def BiCubIm(self, aCoef: 'double', aScale: 'double'=1.0) -> "cIm2DInter *":
        return _mm3d.Im2DGen_BiCubIm(self, aCoef, aScale)

    def SinusCard(self, SzSin: 'double', SzApod: 'double') -> "cIm2DInter *":
        return _mm3d.Im2DGen_SinusCard(self, SzSin, SzApod)

    def SetI(self, arg2: 'Pt2di', aValI: 'int') -> "void":
        return _mm3d.Im2DGen_SetI(self, arg2, aValI)

    def SetR(self, arg2: 'Pt2di', aValR: 'double') -> "void":
        return _mm3d.Im2DGen_SetR(self, arg2, aValR)

    def SetI_SVP(self, arg2: 'Pt2di', aValI: 'int') -> "void":
        return _mm3d.Im2DGen_SetI_SVP(self, arg2, aValI)

    def SetR_SVP(self, arg2: 'Pt2di', aValR: 'double') -> "void":
        return _mm3d.Im2DGen_SetR_SVP(self, arg2, aValR)

    def AssertInside(self, arg2: 'Pt2di') -> "void":
        return _mm3d.Im2DGen_AssertInside(self, arg2)

    def Inside(self, arg2: 'Pt2di') -> "bool":
        return _mm3d.Im2DGen_Inside(self, arg2)

    def GetI(self, *args) -> "int":
        return _mm3d.Im2DGen_GetI(self, *args)

    def GetR(self, *args) -> "double":
        return _mm3d.Im2DGen_GetR(self, *args)

    def PutData(self, aFP: 'FILE *', anI: 'Pt2di', aModeBin: 'bool') -> "void":
        return _mm3d.Im2DGen_PutData(self, aFP, anI, aModeBin)

    def ImOfSameType(self, aSz: 'Pt2di') -> "Im2DGen *":
        return _mm3d.Im2DGen_ImOfSameType(self, aSz)

    def ImRotate(self, aRot: 'int') -> "Im2DGen *":
        return _mm3d.Im2DGen_ImRotate(self, aRot)

    def BoxDef(self) -> "Box2di":
        return _mm3d.Im2DGen_BoxDef(self)

    def Val(self, x: 'int const &', y: 'int const &') -> "double":
        return _mm3d.Im2DGen_Val(self, x, y)

    def Resize(self, aSz: 'Pt2di') -> "void":
        return _mm3d.Im2DGen_Resize(self, aSz)
Im2DGen_swigregister = _mm3d.Im2DGen_swigregister
Im2DGen_swigregister(Im2DGen)


def StdInPut(arg1: 'std::vector< Im2DGen *,std::allocator< Im2DGen * > >') -> "Fonc_Num":
    return _mm3d.StdInPut(arg1)
StdInPut = _mm3d.StdInPut

def StdOutput(arg1: 'std::vector< Im2DGen *,std::allocator< Im2DGen * > >') -> "Output":
    return _mm3d.StdOutput(arg1)
StdOutput = _mm3d.StdOutput

def gray_im_red_centred(arg1: 'Im2DGen') -> "Im2DGen":
    return _mm3d.gray_im_red_centred(arg1)
gray_im_red_centred = _mm3d.gray_im_red_centred

def gray_file_red_centred(aTif: 'Tiff_Im', aName: 'std::string const &') -> "Tiff_Im":
    return _mm3d.gray_file_red_centred(aTif, aName)
gray_file_red_centred = _mm3d.gray_file_red_centred
class Im2D_NoDataLin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Im2D_NoDataLin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Im2D_NoDataLin, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_Im2D_NoDataLin()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_Im2D_NoDataLin
    __del__ = lambda self: None
Im2D_NoDataLin_swigregister = _mm3d.Im2D_NoDataLin_swigregister
Im2D_NoDataLin_swigregister(Im2D_NoDataLin)

class Im2D_BitsIntitDataLin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Im2D_BitsIntitDataLin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Im2D_BitsIntitDataLin, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_Im2D_BitsIntitDataLin()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_Im2D_BitsIntitDataLin
    __del__ = lambda self: None
Im2D_BitsIntitDataLin_swigregister = _mm3d.Im2D_BitsIntitDataLin_swigregister
Im2D_BitsIntitDataLin_swigregister(Im2D_BitsIntitDataLin)


def MasqFromFile(*args) -> "Im2D_Bits< 1 >":
    return _mm3d.MasqFromFile(*args)
MasqFromFile = _mm3d.MasqFromFile
eModeBilin = _mm3d.eModeBilin
eModeBicub = _mm3d.eModeBicub

def ReducCentered(arg1: 'Im2D_Bits< 1 >') -> "Im2D_Bits< 1 >":
    return _mm3d.ReducCentered(arg1)
ReducCentered = _mm3d.ReducCentered

def MasqForInterpole(aMasqInInit: 'Im2D_Bits< 1 >', aMode: 'eModeInterp') -> "Im2D_Bits< 1 >":
    return _mm3d.MasqForInterpole(aMasqInInit, aMode)
MasqForInterpole = _mm3d.MasqForInterpole
class Im3D_WithDataLin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Im3D_WithDataLin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Im3D_WithDataLin, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_Im3D_WithDataLin()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_Im3D_WithDataLin
    __del__ = lambda self: None
Im3D_WithDataLin_swigregister = _mm3d.Im3D_WithDataLin_swigregister
Im3D_WithDataLin_swigregister(Im3D_WithDataLin)

class Liste_Pts_Gen(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Liste_Pts_Gen, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Liste_Pts_Gen, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def empty(self) -> "bool":
        return _mm3d.Liste_Pts_Gen_empty(self)

    def card(self) -> "int":
        return _mm3d.Liste_Pts_Gen_card(self)

    def dim(self) -> "int":
        return _mm3d.Liste_Pts_Gen_dim(self)
    __swig_destroy__ = _mm3d.delete_Liste_Pts_Gen
    __del__ = lambda self: None
Liste_Pts_Gen_swigregister = _mm3d.Liste_Pts_Gen_swigregister
Liste_Pts_Gen_swigregister(Liste_Pts_Gen)


def hongrois(cost: 'Im2D_INT4') -> "Im1D_INT4":
    return _mm3d.hongrois(cost)
hongrois = _mm3d.hongrois

def ALGOHONGR(arg1: 'Im2D_INT4', arg2: 'Im1D_INT4') -> "void":
    return _mm3d.ALGOHONGR(arg1, arg2)
ALGOHONGR = _mm3d.ALGOHONGR

def deriche_uc(gx: 'Im2D_REAL4', gy: 'Im2D_REAL4', i: 'Im2D_U_INT1', alpha: 'float') -> "void":
    return _mm3d.deriche_uc(gx, gy, i, alpha)
deriche_uc = _mm3d.deriche_uc

def alloc_im1d(type_el: 'GenIm::type_el', tx: 'int', data: 'void *'=None) -> "GenIm":
    return _mm3d.alloc_im1d(type_el, tx, data)
alloc_im1d = _mm3d.alloc_im1d

def alloc_im2d(*args) -> "GenIm":
    return _mm3d.alloc_im2d(*args)
alloc_im2d = _mm3d.alloc_im2d

def D2alloc_im2d(type_el: 'GenIm::type_el', tx: 'int', ty: 'int') -> "Im2DGen":
    return _mm3d.D2alloc_im2d(type_el, tx, ty)
D2alloc_im2d = _mm3d.D2alloc_im2d

def Ptr_D2alloc_im2d(type_el: 'GenIm::type_el', tx: 'int', ty: 'int') -> "Im2DGen *":
    return _mm3d.Ptr_D2alloc_im2d(type_el, tx, ty)
Ptr_D2alloc_im2d = _mm3d.Ptr_D2alloc_im2d

def type_im_integral(type_el: 'GenIm::type_el') -> "bool":
    return _mm3d.type_im_integral(type_el)
type_im_integral = _mm3d.type_im_integral

def nbb_type_num(type_el: 'GenIm::type_el') -> "int":
    return _mm3d.nbb_type_num(type_el)
nbb_type_num = _mm3d.nbb_type_num

def msbf_type_num(type_el: 'GenIm::type_el') -> "bool":
    return _mm3d.msbf_type_num(type_el)
msbf_type_num = _mm3d.msbf_type_num

def signed_type_num(type_el: 'GenIm::type_el') -> "bool":
    return _mm3d.signed_type_num(type_el)
signed_type_num = _mm3d.signed_type_num

def type_u_int_of_nbb(nbb: 'int', msbf: 'bool'=True) -> "GenIm::type_el":
    return _mm3d.type_u_int_of_nbb(nbb, msbf)
type_u_int_of_nbb = _mm3d.type_u_int_of_nbb

def type_im(*args) -> "GenIm::type_el":
    return _mm3d.type_im(*args)
type_im = _mm3d.type_im

def eToString(arg1: 'GenIm::type_el const &') -> "std::string":
    return _mm3d.eToString(arg1)
eToString = _mm3d.eToString

def NamePlyOfType(arg1: 'GenIm::type_el') -> "std::string":
    return _mm3d.NamePlyOfType(arg1)
NamePlyOfType = _mm3d.NamePlyOfType

def min_max_type_num(arg1: 'GenIm::type_el', v_min: 'int &', v_max: 'int &') -> "void":
    return _mm3d.min_max_type_num(arg1, v_min, v_max)
min_max_type_num = _mm3d.min_max_type_num

def VCentrale_type_num(arg1: 'GenIm::type_el') -> "int":
    return _mm3d.VCentrale_type_num(arg1)
VCentrale_type_num = _mm3d.VCentrale_type_num

def Tronque(arg1: 'GenIm::type_el', arg2: 'Fonc_Num') -> "Fonc_Num":
    return _mm3d.Tronque(arg1, arg2)
Tronque = _mm3d.Tronque

def type_of_ptr(*args) -> "GenIm::type_el":
    return _mm3d.type_of_ptr(*args)
type_of_ptr = _mm3d.type_of_ptr

def jacobi(*args) -> "std::vector< int,std::allocator< int > >":
    return _mm3d.jacobi(*args)
jacobi = _mm3d.jacobi

def svdcmp(aMat: 'ElMatrixr', anU: 'ElMatrixr', aLineDiag: 'ElMatrixr', aV: 'ElMatrixr', direct: 'bool') -> "void":
    return _mm3d.svdcmp(aMat, anU, aLineDiag, aV, direct)
svdcmp = _mm3d.svdcmp

def svdcmp_diag(aMat: 'ElMatrixr', anU: 'ElMatrixr', aDiag: 'ElMatrixr', aV: 'ElMatrixr', direct: 'bool') -> "void":
    return _mm3d.svdcmp_diag(aMat, anU, aDiag, aV, direct)
svdcmp_diag = _mm3d.svdcmp_diag

def QRDecomp(aM0: 'ElMatrixr') -> "std::pair< ElMatrix< double >,ElMatrix< double > >":
    return _mm3d.QRDecomp(aM0)
QRDecomp = _mm3d.QRDecomp

def RQDecomp(aM0: 'ElMatrixr') -> "std::pair< ElMatrix< double >,ElMatrix< double > >":
    return _mm3d.RQDecomp(aM0)
RQDecomp = _mm3d.RQDecomp

def NearestRotation(arg1: 'ElMatrixr') -> "ElMatrix< double >":
    return _mm3d.NearestRotation(arg1)
NearestRotation = _mm3d.NearestRotation

def MatProVect(arg1: 'Pt3dr') -> "ElMatrix< double >":
    return _mm3d.MatProVect(arg1)
MatProVect = _mm3d.MatProVect

def InspectPbCD(arg1: 'ElMatrixr') -> "void":
    return _mm3d.InspectPbCD(arg1)
InspectPbCD = _mm3d.InspectPbCD

def ComplemRotation(anAnt1: 'Pt3dr', anAnt2: 'Pt3dr', anIm1: 'Pt3dr', anIm2: 'Pt3dr') -> "ElMatrix< double >":
    return _mm3d.ComplemRotation(anAnt1, anAnt2, anIm1, anIm2)
ComplemRotation = _mm3d.ComplemRotation

def MakeOrthon(aV1: 'Pt3dr', aV2: 'Pt3dr') -> "Pt3dr":
    return _mm3d.MakeOrthon(aV1, aV2)
MakeOrthon = _mm3d.MakeOrthon

def SchmitComplMakeOrthon(aV1: 'Pt3dr', aV2: 'Pt3dr') -> "Pt3dr":
    return _mm3d.SchmitComplMakeOrthon(aV1, aV2)
SchmitComplMakeOrthon = _mm3d.SchmitComplMakeOrthon

def MakeMatON(aV1: 'Pt3dr', aV2: 'Pt3dr') -> "ElMatrix< double >":
    return _mm3d.MakeMatON(aV1, aV2)
MakeMatON = _mm3d.MakeMatON

def MakeRONWith1Vect(aV1: 'Pt3dr', aV2: 'Pt3dr', aV3: 'Pt3dr') -> "void":
    return _mm3d.MakeRONWith1Vect(aV1, aV2, aV3)
MakeRONWith1Vect = _mm3d.MakeRONWith1Vect

def ComplBaseParLeHaut(arg1: 'ElMatrixr', NbLigneOk: 'int') -> "void":
    return _mm3d.ComplBaseParLeHaut(arg1, NbLigneOk)
ComplBaseParLeHaut = _mm3d.ComplBaseParLeHaut

def DiffRotEn1Pt(teta01: 'double', teta02: 'double', teta12: 'double', pt: 'Pt3dr') -> "ElMatrix< double >":
    return _mm3d.DiffRotEn1Pt(teta01, teta02, teta12, pt)
DiffRotEn1Pt = _mm3d.DiffRotEn1Pt

def MatFromImageBase(C0: 'Pt3dr', C1: 'Pt3dr', C2: 'Pt3dr', ImC0: 'Pt3dr', arg5: 'Pt3dr', arg6: 'Pt3dr') -> "ElMatrix< double >":
    return _mm3d.MatFromImageBase(C0, C1, C2, ImC0, arg5, arg6)
MatFromImageBase = _mm3d.MatFromImageBase

def EcartInv(m1: 'ElMatrixr', m2: 'ElMatrixr') -> "double":
    return _mm3d.EcartInv(m1, m2)
EcartInv = _mm3d.EcartInv

def AngleFromRot(m: 'ElMatrixr', a: 'double &', b: 'double &', c: 'double &') -> "void":
    return _mm3d.AngleFromRot(m, a, b, c)
AngleFromRot = _mm3d.AngleFromRot
class cChCoCart(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cChCoCart, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cChCoCart, name)
    __repr__ = _swig_repr

    def FromLoc(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.cChCoCart_FromLoc(self, arg2)

    def Inv(self) -> "cChCoCart":
        return _mm3d.cChCoCart_Inv(self)

    def __init__(self, aOri: 'Pt3dr', arg3: 'Pt3dr', arg4: 'Pt3dr', arg5: 'Pt3dr'):
        this = _mm3d.new_cChCoCart(aOri, arg3, arg4, arg5)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        Xml2El = staticmethod(_mm3d.cChCoCart_Xml2El)
    else:
        Xml2El = _mm3d.cChCoCart_Xml2El

    def El2Xml(self) -> "cRepereCartesien":
        return _mm3d.cChCoCart_El2Xml(self)
    __swig_destroy__ = _mm3d.delete_cChCoCart
    __del__ = lambda self: None
cChCoCart_swigregister = _mm3d.cChCoCart_swigregister
cChCoCart_swigregister(cChCoCart)

def cChCoCart_Xml2El(arg2: 'cRepereCartesien const &') -> "cChCoCart":
    return _mm3d.cChCoCart_Xml2El(arg2)
cChCoCart_Xml2El = _mm3d.cChCoCart_Xml2El


def VectRotationArroundAxe(arg1: 'Pt3dr', aTeta: 'double') -> "ElMatrix< double >":
    return _mm3d.VectRotationArroundAxe(arg1, aTeta)
VectRotationArroundAxe = _mm3d.VectRotationArroundAxe

def AffinRotationArroundAxe(arg1: 'ElSeg3D const &', aTeta: 'double') -> "ElRotation3D":
    return _mm3d.AffinRotationArroundAxe(arg1, aTeta)
AffinRotationArroundAxe = _mm3d.AffinRotationArroundAxe

def RotationOfInvariantPoint(arg1: 'Pt3dr', arg2: 'ElMatrixr') -> "ElRotation3D":
    return _mm3d.RotationOfInvariantPoint(arg1, arg2)
RotationOfInvariantPoint = _mm3d.RotationOfInvariantPoint

def VecKern(aMat: 'ElMatrixr') -> "ElMatrix< double >":
    return _mm3d.VecKern(aMat)
VecKern = _mm3d.VecKern

def VecOfValP(aMat: 'ElMatrixr', aVP: 'double') -> "ElMatrix< double >":
    return _mm3d.VecOfValP(aMat, aVP)
VecOfValP = _mm3d.VecOfValP

def AxeRot(aMat: 'ElMatrixr') -> "Pt3dr":
    return _mm3d.AxeRot(aMat)
AxeRot = _mm3d.AxeRot

def TetaOfAxeRot(aMat: 'ElMatrixr', aP1: 'Pt3dr') -> "double":
    return _mm3d.TetaOfAxeRot(aMat, aP1)
TetaOfAxeRot = _mm3d.TetaOfAxeRot

def LongBase(arg1: 'ElRotation3D') -> "double":
    return _mm3d.LongBase(arg1)
LongBase = _mm3d.LongBase

def ScaleBase(arg1: 'ElRotation3D', aScale: 'double const &') -> "ElRotation3D":
    return _mm3d.ScaleBase(arg1, aScale)
ScaleBase = _mm3d.ScaleBase

def ProfFromCam(anOr: 'ElRotation3D', aP: 'Pt3dr') -> "double":
    return _mm3d.ProfFromCam(anOr, aP)
ProfFromCam = _mm3d.ProfFromCam

def AverRotation(aVRot: 'std::vector< ElRotation3D,std::allocator< ElRotation3D > > const &', aVWeights: 'DoubleVector') -> "ElRotation3D":
    return _mm3d.AverRotation(aVRot, aVWeights)
AverRotation = _mm3d.AverRotation

def SauvFile(arg1: 'ElRotation3D', arg2: 'std::string const &') -> "void":
    return _mm3d.SauvFile(arg1, arg2)
SauvFile = _mm3d.SauvFile

def XML_SauvFile(*args) -> "void":
    return _mm3d.XML_SauvFile(*args)
XML_SauvFile = _mm3d.XML_SauvFile

def ReadFromFile(arg1: 'ElRotation3D', arg2: 'std::string const &') -> "ElRotation3D":
    return _mm3d.ReadFromFile(arg1, arg2)
ReadFromFile = _mm3d.ReadFromFile

def LeasSqFit(Samples: 'vector< Pt2dr >', aDeg: 'int'=-1, aPds: 'DoubleVector'=None) -> "ElPolynome< double >":
    return _mm3d.LeasSqFit(Samples, aDeg, aPds)
LeasSqFit = _mm3d.LeasSqFit

def RacinesPolyneDegre2Reel(a0: 'double', a1: 'double', a2: 'double', CAS: 'int &', X1: 'Pt2dr', X2: 'Pt2dr') -> "void":
    return _mm3d.RacinesPolyneDegre2Reel(a0, a1, a2, CAS, X1, X2)
RacinesPolyneDegre2Reel = _mm3d.RacinesPolyneDegre2Reel

def RacineCarreesComplexe(X: 'Pt2dr', A1: 'Pt2dr', A2: 'Pt2dr') -> "void":
    return _mm3d.RacineCarreesComplexe(X, A1, A2)
RacineCarreesComplexe = _mm3d.RacineCarreesComplexe

def RacinesPolyneDegre3Reel(A0: 'double', A1: 'double', A2: 'double', A3: 'double', CAS: 'int &', X1: 'Pt2dr', X2: 'Pt2dr', X3: 'Pt2dr') -> "void":
    return _mm3d.RacinesPolyneDegre3Reel(A0, A1, A2, A3, CAS, X1, X2, X3)
RacinesPolyneDegre3Reel = _mm3d.RacinesPolyneDegre3Reel

def RacinesPolyneDegre4Reel(A0: 'double', A1: 'double', A2: 'double', A3: 'double', A4: 'double', CAS: 'int &', X1: 'Pt2dr', X2: 'Pt2dr', X3: 'Pt2dr', X4: 'Pt2dr') -> "void":
    return _mm3d.RacinesPolyneDegre4Reel(A0, A1, A2, A3, A4, CAS, X1, X2, X3, X4)
RacinesPolyneDegre4Reel = _mm3d.RacinesPolyneDegre4Reel
class Monome2dReal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Monome2dReal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Monome2dReal, name)
    __repr__ = _swig_repr

    def __init__(self, d0X: 'int', d0Y: 'int', ampl: 'double'):
        this = _mm3d.new_Monome2dReal(d0X, d0Y, ampl)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CoeffMulNewAmpl(self, NewAmpl: 'double') -> "double":
        return _mm3d.Monome2dReal_CoeffMulNewAmpl(self, NewAmpl)

    def SetAmpl(self, arg2: 'double') -> "void":
        return _mm3d.Monome2dReal_SetAmpl(self, arg2)

    def __call__(self, aP: 'Pt2dr') -> "double":
        return _mm3d.Monome2dReal___call__(self, aP)

    def grad(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.Monome2dReal_grad(self, aP)

    def FNum(self) -> "Fonc_Num":
        return _mm3d.Monome2dReal_FNum(self)

    def DegreX(self) -> "int":
        return _mm3d.Monome2dReal_DegreX(self)

    def DegreY(self) -> "int":
        return _mm3d.Monome2dReal_DegreY(self)

    def DegreTot(self) -> "int":
        return _mm3d.Monome2dReal_DegreTot(self)

    def Show(self, X: 'bool') -> "void":
        return _mm3d.Monome2dReal_Show(self, X)
    __swig_destroy__ = _mm3d.delete_Monome2dReal
    __del__ = lambda self: None
Monome2dReal_swigregister = _mm3d.Monome2dReal_swigregister
Monome2dReal_swigregister(Monome2dReal)

class Polynome2dReal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Polynome2dReal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Polynome2dReal, name)
    __repr__ = _swig_repr

    def ToVect(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.Polynome2dReal_ToVect(self)
    if _newclass:
        FromVect = staticmethod(_mm3d.Polynome2dReal_FromVect)
    else:
        FromVect = _mm3d.Polynome2dReal_FromVect

    def __init__(self, *args):
        this = _mm3d.new_Polynome2dReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDegre1(self, aV0: 'double', aVX: 'double', aVY: 'double', AnnulOthers: 'bool'=True) -> "void":
        return _mm3d.Polynome2dReal_SetDegre1(self, aV0, aVX, aVY, AnnulOthers)

    def __call__(self, aP: 'Pt2dr') -> "double":
        return _mm3d.Polynome2dReal___call__(self, aP)

    def grad(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.Polynome2dReal_grad(self, aP)

    def NbMonome(self) -> "int":
        return _mm3d.Polynome2dReal_NbMonome(self)

    def KthMonome(self, arg2: 'int') -> "Monome2dReal const &":
        return _mm3d.Polynome2dReal_KthMonome(self, arg2)

    def DegreX(self, arg2: 'int') -> "int":
        return _mm3d.Polynome2dReal_DegreX(self, arg2)

    def DegreY(self, arg2: 'int') -> "int":
        return _mm3d.Polynome2dReal_DegreY(self, arg2)

    def DegreTot(self, arg2: 'int') -> "int":
        return _mm3d.Polynome2dReal_DegreTot(self, arg2)

    def SetCoeff(self, aNumMon: 'int', aCoeff: 'double') -> "void":
        return _mm3d.Polynome2dReal_SetCoeff(self, aNumMon, aCoeff)

    def Coeff(self, *args) -> "double &":
        return _mm3d.Polynome2dReal_Coeff(self, *args)

    def Show(self, *args) -> "void":
        return _mm3d.Polynome2dReal_Show(self, *args)

    def FNum(self) -> "Fonc_Num":
        return _mm3d.Polynome2dReal_FNum(self)

    def Ampl(self) -> "double":
        return _mm3d.Polynome2dReal_Ampl(self)

    def write(self, arg2: 'ELISE_fp &') -> "void":
        return _mm3d.Polynome2dReal_write(self, arg2)
    if _newclass:
        read = staticmethod(_mm3d.Polynome2dReal_read)
    else:
        read = _mm3d.Polynome2dReal_read

    def MapingChScale(self, aChSacle: 'double') -> "Polynome2dReal":
        return _mm3d.Polynome2dReal_MapingChScale(self, aChSacle)

    def __add__(self, arg2: 'Polynome2dReal') -> "Polynome2dReal":
        return _mm3d.Polynome2dReal___add__(self, arg2)

    def __sub__(self, arg2: 'Polynome2dReal') -> "Polynome2dReal":
        return _mm3d.Polynome2dReal___sub__(self, arg2)

    def __mul__(self, arg2: 'double') -> "Polynome2dReal":
        return _mm3d.Polynome2dReal___mul__(self, arg2)

    def __truediv__(self, *args):
        return _mm3d.Polynome2dReal___truediv__(self, *args)
    __div__ = __truediv__



    def DMax(self) -> "int":
        return _mm3d.Polynome2dReal_DMax(self)
    if _newclass:
        PolyDegre1 = staticmethod(_mm3d.Polynome2dReal_PolyDegre1)
    else:
        PolyDegre1 = _mm3d.Polynome2dReal_PolyDegre1
    __swig_destroy__ = _mm3d.delete_Polynome2dReal
    __del__ = lambda self: None
Polynome2dReal_swigregister = _mm3d.Polynome2dReal_swigregister
Polynome2dReal_swigregister(Polynome2dReal)

def Polynome2dReal_FromVect(arg2: 'DoubleVector', anAmp: 'double') -> "Polynome2dReal":
    return _mm3d.Polynome2dReal_FromVect(arg2, anAmp)
Polynome2dReal_FromVect = _mm3d.Polynome2dReal_FromVect

def Polynome2dReal_read(arg2: 'ELISE_fp &') -> "Polynome2dReal":
    return _mm3d.Polynome2dReal_read(arg2)
Polynome2dReal_read = _mm3d.Polynome2dReal_read

def Polynome2dReal_PolyDegre1(aV0: 'double', aVX: 'double', aVY: 'double') -> "Polynome2dReal":
    return _mm3d.Polynome2dReal_PolyDegre1(aV0, aVX, aVY)
Polynome2dReal_PolyDegre1 = _mm3d.Polynome2dReal_PolyDegre1


def LeasquarePol2DFit(*args) -> "Polynome2dReal":
    return _mm3d.LeasquarePol2DFit(*args)
LeasquarePol2DFit = _mm3d.LeasquarePol2DFit

def ElFFT(aReIm: 'Im2D_REAL8', aImIm: 'Im2D_REAL8', aDirect: 'bool') -> "void":
    return _mm3d.ElFFT(aReIm, aImIm, aDirect)
ElFFT = _mm3d.ElFFT

def ElFFTCorrelCirc(aReIm1: 'Im2D_REAL8', aReIm2: 'Im2D_REAL8') -> "void":
    return _mm3d.ElFFTCorrelCirc(aReIm1, aReIm2)
ElFFTCorrelCirc = _mm3d.ElFFTCorrelCirc

def ElFFTCorrelPadded(aReIm1: 'Im2D_REAL8', aReIm2: 'Im2D_REAL8') -> "Im2D_REAL8":
    return _mm3d.ElFFTCorrelPadded(aReIm1, aReIm2)
ElFFTCorrelPadded = _mm3d.ElFFTCorrelPadded

def ElFFTCorrelNCPadded(aReIm1: 'Im2D_REAL8', aReIm2: 'Im2D_REAL8', anEps: 'double', aSurfMin: 'double'=-1) -> "Im2D_REAL8":
    return _mm3d.ElFFTCorrelNCPadded(aReIm1, aReIm2, anEps, aSurfMin)
ElFFTCorrelNCPadded = _mm3d.ElFFTCorrelNCPadded

def ElFFTPonderedCorrelNCPadded(aF1: 'Fonc_Num', aF2: 'Fonc_Num', aSz: 'Pt2di', aPds1: 'Fonc_Num', aPds2: 'Fonc_Num', anEps: 'double', aSurfMin: 'double'=-1) -> "Im2D_REAL8":
    return _mm3d.ElFFTPonderedCorrelNCPadded(aF1, aF2, aSz, aPds1, aPds2, anEps, aSurfMin)
ElFFTPonderedCorrelNCPadded = _mm3d.ElFFTPonderedCorrelNCPadded

def ImCorrFromNrFFT(anIm: 'Im2D_REAL8', aDecIm1: 'Pt2di') -> "double":
    return _mm3d.ImCorrFromNrFFT(anIm, aDecIm1)
ImCorrFromNrFFT = _mm3d.ImCorrFromNrFFT

def DecIm2DecFFT(anImFFT: 'Im2D_REAL8', aDecIm1: 'Pt2di') -> "Pt2di":
    return _mm3d.DecIm2DecFFT(anImFFT, aDecIm1)
DecIm2DecFFT = _mm3d.DecIm2DecFFT

def DecFFT2DecIm(anImFFT: 'Im2D_REAL8', aP: 'Pt2di') -> "Pt2di":
    return _mm3d.DecFFT2DecIm(anImFFT, aP)
DecFFT2DecIm = _mm3d.DecFFT2DecIm

def FN_DecFFT2DecIm(anIm: 'Im2D_REAL8') -> "Pt2d< Fonc_Num >":
    return _mm3d.FN_DecFFT2DecIm(anIm)
FN_DecFFT2DecIm = _mm3d.FN_DecFFT2DecIm
class RImGrid(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RImGrid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RImGrid, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_RImGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_RImGrid
    __del__ = lambda self: None

    def InitGlob(self, aFonc: 'Fonc_Num') -> "void":
        return _mm3d.RImGrid_InitGlob(self, aFonc)

    def ToGrid(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.RImGrid_ToGrid(self, aP)

    def ToReal(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.RImGrid_ToReal(self, aP)

    def SzGrid(self) -> "Pt2di":
        return _mm3d.RImGrid_SzGrid(self)

    def TranlateIn(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.RImGrid_TranlateIn(self, arg2)

    def Value(self, aRealP: 'Pt2dr') -> "double":
        return _mm3d.RImGrid_Value(self, aRealP)

    def ValueAndDer(self, aRealP: 'Pt2dr', aDer: 'Pt2dr') -> "double":
        return _mm3d.RImGrid_ValueAndDer(self, aRealP, aDer)

    def SetValueGrid(self, aP: 'Pt2di', aV: 'double') -> "void":
        return _mm3d.RImGrid_SetValueGrid(self, aP, aV)

    def ExtDef(self) -> "void":
        return _mm3d.RImGrid_ExtDef(self)

    def NewChScale(self, aChSacle: 'double', ModeMapping: 'bool') -> "RImGrid *":
        return _mm3d.RImGrid_NewChScale(self, aChSacle, ModeMapping)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.RImGrid_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.RImGrid_read)
    else:
        read = _mm3d.RImGrid_read

    def Step(self) -> "Pt2dr const &":
        return _mm3d.RImGrid_Step(self)

    def Origine(self) -> "Pt2dr":
        return _mm3d.RImGrid_Origine(self)

    def DataGrid(self) -> "Im2D_REAL8":
        return _mm3d.RImGrid_DataGrid(self)

    def SetTrChScaleOut(self, aChScale: 'double', aTr: 'double') -> "void":
        return _mm3d.RImGrid_SetTrChScaleOut(self, aChScale, aTr)

    def SetTrChScaleIn(self, aChScale: 'double', aTr: 'Pt2dr') -> "void":
        return _mm3d.RImGrid_SetTrChScaleIn(self, aChScale, aTr)

    def Name(self) -> "std::string const &":
        return _mm3d.RImGrid_Name(self)

    def P0(self) -> "Pt2dr const &":
        return _mm3d.RImGrid_P0(self)

    def P1(self) -> "Pt2dr const &":
        return _mm3d.RImGrid_P1(self)

    def StepAdapted(self) -> "bool":
        return _mm3d.RImGrid_StepAdapted(self)
RImGrid_swigregister = _mm3d.RImGrid_swigregister
RImGrid_swigregister(RImGrid)

def RImGrid_read(aFile: 'ELISE_fp &') -> "RImGrid *":
    return _mm3d.RImGrid_read(aFile)
RImGrid_read = _mm3d.RImGrid_read

class PtImGrid(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PtImGrid, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PtImGrid, name)
    __repr__ = _swig_repr

    def ToGrid(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.PtImGrid_ToGrid(self, aP)

    def ToReal(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.PtImGrid_ToReal(self, aP)

    def SzGrid(self) -> "Pt2di":
        return _mm3d.PtImGrid_SzGrid(self)

    def Value(self, aRealP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.PtImGrid_Value(self, aRealP)

    def ValueAndDer(self, aRealP: 'Pt2dr', aGradX: 'Pt2dr', aGradY: 'Pt2dr') -> "Pt2dr":
        return _mm3d.PtImGrid_ValueAndDer(self, aRealP, aGradX, aGradY)

    def SetValueGrid(self, aP: 'Pt2di', aV: 'Pt2dr') -> "void":
        return _mm3d.PtImGrid_SetValueGrid(self, aP, aV)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.PtImGrid_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.PtImGrid_read)
    else:
        read = _mm3d.PtImGrid_read
    __swig_destroy__ = _mm3d.delete_PtImGrid
    __del__ = lambda self: None

    def Step(self) -> "Pt2dr const &":
        return _mm3d.PtImGrid_Step(self)

    def Origine(self) -> "Pt2dr":
        return _mm3d.PtImGrid_Origine(self)

    def DataGridX(self) -> "Im2D_REAL8":
        return _mm3d.PtImGrid_DataGridX(self)

    def DataGridY(self) -> "Im2D_REAL8":
        return _mm3d.PtImGrid_DataGridY(self)

    def Name(self) -> "std::string const &":
        return _mm3d.PtImGrid_Name(self)

    def NameX(self) -> "std::string const &":
        return _mm3d.PtImGrid_NameX(self)

    def NameY(self) -> "std::string const &":
        return _mm3d.PtImGrid_NameY(self)

    def __init__(self, *args):
        this = _mm3d.new_PtImGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTrChScaleOut(self, aChScale: 'double', aTr: 'Pt2dr') -> "void":
        return _mm3d.PtImGrid_SetTrChScaleOut(self, aChScale, aTr)

    def SetTrChScaleIn(self, aChScale: 'double', aTr: 'Pt2dr') -> "void":
        return _mm3d.PtImGrid_SetTrChScaleIn(self, aChScale, aTr)

    def P0(self) -> "Pt2dr const &":
        return _mm3d.PtImGrid_P0(self)

    def P1(self) -> "Pt2dr const &":
        return _mm3d.PtImGrid_P1(self)

    def StepAdapted(self) -> "bool":
        return _mm3d.PtImGrid_StepAdapted(self)
PtImGrid_swigregister = _mm3d.PtImGrid_swigregister
PtImGrid_swigregister(PtImGrid)

def PtImGrid_read(aFile: 'ELISE_fp &') -> "PtImGrid *":
    return _mm3d.PtImGrid_read(aFile)
PtImGrid_read = _mm3d.PtImGrid_read


def ShowMatr(mes: 'char const *', aMatr: 'ElMatrixr') -> "void":
    return _mm3d.ShowMatr(mes, aMatr)
ShowMatr = _mm3d.ShowMatr
class cKernelInterpol1D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cKernelInterpol1D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cKernelInterpol1D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        StdInterpCHC = staticmethod(_mm3d.cKernelInterpol1D_StdInterpCHC)
    else:
        StdInterpCHC = _mm3d.cKernelInterpol1D_StdInterpCHC

    def Interpole(self, arg2: 'cFoncI2D', x: 'double const &', y: 'double const &') -> "double":
        return _mm3d.cKernelInterpol1D_Interpole(self, arg2, x, y)

    def Value(self, x: 'double') -> "double":
        return _mm3d.cKernelInterpol1D_Value(self, x)

    def SzKernel(self) -> "double const &":
        return _mm3d.cKernelInterpol1D_SzKernel(self)
    __swig_destroy__ = _mm3d.delete_cKernelInterpol1D
    __del__ = lambda self: None
cKernelInterpol1D_swigregister = _mm3d.cKernelInterpol1D_swigregister
cKernelInterpol1D_swigregister(cKernelInterpol1D)

def cKernelInterpol1D_StdInterpCHC(aScale: 'double', aNbTab: 'int'=100) -> "cKernelInterpol1D *":
    return _mm3d.cKernelInterpol1D_StdInterpCHC(aScale, aNbTab)
cKernelInterpol1D_StdInterpCHC = _mm3d.cKernelInterpol1D_StdInterpCHC

class cCubicInterpKernel(cKernelInterpol1D):
    __swig_setmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCubicInterpKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCubicInterpKernel, name)
    __repr__ = _swig_repr

    def Value(self, x: 'double') -> "double":
        return _mm3d.cCubicInterpKernel_Value(self, x)

    def Derivee(self, x: 'double') -> "double":
        return _mm3d.cCubicInterpKernel_Derivee(self, x)

    def ValAndDerivee(self, x: 'double', V: 'double &', D: 'double &') -> "void":
        return _mm3d.cCubicInterpKernel_ValAndDerivee(self, x, V, D)

    def __init__(self, aA: 'double'):
        this = _mm3d.new_cCubicInterpKernel(aA)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cCubicInterpKernel
    __del__ = lambda self: None
cCubicInterpKernel_swigregister = _mm3d.cCubicInterpKernel_swigregister
cCubicInterpKernel_swigregister(cCubicInterpKernel)

class cSinCardApodInterpol1D(cKernelInterpol1D):
    __swig_setmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cSinCardApodInterpol1D, name, value)
    __swig_getmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cSinCardApodInterpol1D, name)
    __repr__ = _swig_repr
    eTukeyApod = _mm3d.cSinCardApodInterpol1D_eTukeyApod
    eModePorte = _mm3d.cSinCardApodInterpol1D_eModePorte

    def Value(self, x: 'double') -> "double":
        return _mm3d.cSinCardApodInterpol1D_Value(self, x)

    def __init__(self, arg2: 'cSinCardApodInterpol1D::eModeApod', aSzK: 'double', aSzApod: 'double', aEpsilon: 'double'=1e-3, OnlyApod: 'bool'=False):
        this = _mm3d.new_cSinCardApodInterpol1D(arg2, aSzK, aSzApod, aEpsilon, OnlyApod)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cSinCardApodInterpol1D
    __del__ = lambda self: None
cSinCardApodInterpol1D_swigregister = _mm3d.cSinCardApodInterpol1D_swigregister
cSinCardApodInterpol1D_swigregister(cSinCardApodInterpol1D)

class cScaledKernelInterpol(cKernelInterpol1D):
    __swig_setmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cScaledKernelInterpol, name, value)
    __swig_getmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cScaledKernelInterpol, name)
    __repr__ = _swig_repr

    def Value(self, x: 'double') -> "double":
        return _mm3d.cScaledKernelInterpol_Value(self, x)

    def __init__(self, arg2: 'cKernelInterpol1D', ascale: 'double'):
        this = _mm3d.new_cScaledKernelInterpol(arg2, ascale)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cScaledKernelInterpol
    __del__ = lambda self: None
cScaledKernelInterpol_swigregister = _mm3d.cScaledKernelInterpol_swigregister
cScaledKernelInterpol_swigregister(cScaledKernelInterpol)

class cTabulKernelInterpol(cKernelInterpol1D):
    __swig_setmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTabulKernelInterpol, name, value)
    __swig_getmethods__ = {}
    for _s in [cKernelInterpol1D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cTabulKernelInterpol, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'cKernelInterpol1D', NbDisc1: 'int', mPrecBil: 'bool'):
        this = _mm3d.new_cTabulKernelInterpol(arg2, NbDisc1, mPrecBil)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cTabulKernelInterpol
    __del__ = lambda self: None

    def Value(self, x: 'double') -> "double":
        return _mm3d.cTabulKernelInterpol_Value(self, x)

    def ValueDer(self, x: 'double') -> "double":
        return _mm3d.cTabulKernelInterpol_ValueDer(self, x)

    def NbDisc1(self) -> "int":
        return _mm3d.cTabulKernelInterpol_NbDisc1(self)
cTabulKernelInterpol_swigregister = _mm3d.cTabulKernelInterpol_swigregister
cTabulKernelInterpol_swigregister(cTabulKernelInterpol)

eTabulBicub = _mm3d.eTabulBicub
eTabulMPD_EcartMoyen = _mm3d.eTabulMPD_EcartMoyen
eTabulMPD_EcartType = _mm3d.eTabulMPD_EcartType
eTabul_Bilin = _mm3d.eTabul_Bilin

def FiltrageImage3D(StepX: 'int', StepY: 'int', StepZ: 'int', Data: 'double *', Tx: 'int', Ty: 'int', Tz: 'int') -> "void":
    return _mm3d.FiltrageImage3D(StepX, StepY, StepZ, Data, Tx, Ty, Tz)
FiltrageImage3D = _mm3d.FiltrageImage3D

def NoyauxFiltrageImage3D(StepX: 'int', StepY: 'int', StepZ: 'int', Data: 'double *', Tx: 'int', Ty: 'int', Tz: 'int') -> "void":
    return _mm3d.NoyauxFiltrageImage3D(StepX, StepY, StepZ, Data, Tx, Ty, Tz)
NoyauxFiltrageImage3D = _mm3d.NoyauxFiltrageImage3D

def Shading(aSz: 'Pt2di', aFMnt: 'Fonc_Num', aNbDir: 'int', Anisotropie: 'double') -> "Im2D_U_INT1":
    return _mm3d.Shading(aSz, aFMnt, aNbDir, Anisotropie)
Shading = _mm3d.Shading
class cElBitmFont(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElBitmFont, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElBitmFont, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        BasicFont_10x8 = staticmethod(_mm3d.cElBitmFont_BasicFont_10x8)
    else:
        BasicFont_10x8 = _mm3d.cElBitmFont_BasicFont_10x8

    def ImChar(self, arg2: 'char') -> "Im2D_Bits< 1 >":
        return _mm3d.cElBitmFont_ImChar(self, arg2)
    __swig_destroy__ = _mm3d.delete_cElBitmFont
    __del__ = lambda self: None

    def BasicImageString(self, arg2: 'std::string const &', aSpace: 'int') -> "Im2D_Bits< 1 >":
        return _mm3d.cElBitmFont_BasicImageString(self, arg2, aSpace)

    def MultiLineImageString(self, aStrInit: 'std::string const &', aSpace: 'Pt2di', aRab: 'Pt2di', Centering: 'int') -> "Im2D_Bits< 1 >":
        return _mm3d.cElBitmFont_MultiLineImageString(self, aStrInit, aSpace, aRab, Centering)
cElBitmFont_swigregister = _mm3d.cElBitmFont_swigregister
cElBitmFont_swigregister(cElBitmFont)

def cElBitmFont_BasicFont_10x8() -> "cElBitmFont &":
    return _mm3d.cElBitmFont_BasicFont_10x8()
cElBitmFont_BasicFont_10x8 = _mm3d.cElBitmFont_BasicFont_10x8

class cIm2DInter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cIm2DInter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cIm2DInter, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Get(self, arg2: 'Pt2dr') -> "double":
        return _mm3d.cIm2DInter_Get(self, arg2)

    def GetDef(self, arg2: 'Pt2dr', arg3: 'double') -> "double":
        return _mm3d.cIm2DInter_GetDef(self, arg2, arg3)

    def SzKernel(self) -> "int":
        return _mm3d.cIm2DInter_SzKernel(self)
    __swig_destroy__ = _mm3d.delete_cIm2DInter
    __del__ = lambda self: None
cIm2DInter_swigregister = _mm3d.cIm2DInter_swigregister
cIm2DInter_swigregister(cIm2DInter)

class cComputecKernelGraph(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cComputecKernelGraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cComputecKernelGraph, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cComputecKernelGraph()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetN(self, aN: 'int') -> "void":
        return _mm3d.cComputecKernelGraph_SetN(self, aN)

    def AddCost(self, aK1: 'int', aK2: 'int', aPds1: 'double', aPds2: 'double', aDist: 'double') -> "void":
        return _mm3d.cComputecKernelGraph_AddCost(self, aK1, aK2, aPds1, aPds2, aDist)

    def GetKernel(self) -> "int":
        return _mm3d.cComputecKernelGraph_GetKernel(self)

    def GetKernelGen(self) -> "int":
        return _mm3d.cComputecKernelGraph_GetKernelGen(self)
    __swig_destroy__ = _mm3d.delete_cComputecKernelGraph
    __del__ = lambda self: None
cComputecKernelGraph_swigregister = _mm3d.cComputecKernelGraph_swigregister
cComputecKernelGraph_swigregister(cComputecKernelGraph)


def scal(*args) -> "double":
    return _mm3d.scal(*args)
scal = _mm3d.scal

def MapFromElem(arg1: 'cXml_Map2DElem const &') -> "cXml_Map2D":
    return _mm3d.MapFromElem(arg1)
MapFromElem = _mm3d.MapFromElem
class cElMap2D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElMap2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElMap2D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    if _newclass:
        IdentFromType = staticmethod(_mm3d.cElMap2D_IdentFromType)
    else:
        IdentFromType = _mm3d.cElMap2D_IdentFromType

    def __call__(self, p: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cElMap2D___call__(self, p)

    def Type(self) -> "int":
        return _mm3d.cElMap2D_Type(self)
    __swig_destroy__ = _mm3d.delete_cElMap2D
    __del__ = lambda self: None

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.cElMap2D_Map2DInverse(self)

    def Simplify(self) -> "cElMap2D *":
        return _mm3d.cElMap2D_Simplify(self)

    def Duplicate(self) -> "cElMap2D *":
        return _mm3d.cElMap2D_Duplicate(self)

    def Identity(self) -> "cElMap2D *":
        return _mm3d.cElMap2D_Identity(self)

    def NbUnknown(self) -> "int":
        return _mm3d.cElMap2D_NbUnknown(self)

    def AddEq(self, aCste: 'Pt2dr', anEqX: 'DoubleVector', anEqY: 'DoubleVector', aP1: 'Pt2dr', aP2: 'Pt2dr') -> "void":
        return _mm3d.cElMap2D_AddEq(self, aCste, anEqX, anEqY, aP1, aP2)

    def InitFromParams(self, aSol: 'DoubleVector') -> "void":
        return _mm3d.cElMap2D_InitFromParams(self, aSol)

    def SaveInFile(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cElMap2D_SaveInFile(self, arg2)
    if _newclass:
        FromFile = staticmethod(_mm3d.cElMap2D_FromFile)
    else:
        FromFile = _mm3d.cElMap2D_FromFile

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.cElMap2D_ToXmlGen(self)

    def Affect(self, arg2: 'cElMap2D') -> "void":
        return _mm3d.cElMap2D_Affect(self, arg2)

    def Params(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.cElMap2D_Params(self)

    def ParamAux(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _mm3d.cElMap2D_ParamAux(self)
cElMap2D_swigregister = _mm3d.cElMap2D_swigregister
cElMap2D_swigregister(cElMap2D)

def cElMap2D_IdentFromType(arg1: 'int', arg2: 'StringVector'=None) -> "cElMap2D *":
    return _mm3d.cElMap2D_IdentFromType(arg1, arg2)
cElMap2D_IdentFromType = _mm3d.cElMap2D_IdentFromType

def cElMap2D_FromFile(arg2: 'std::string const &') -> "cElMap2D *":
    return _mm3d.cElMap2D_FromFile(arg2)
cElMap2D_FromFile = _mm3d.cElMap2D_FromFile

class cComposElMap2D(cElMap2D):
    __swig_setmethods__ = {}
    for _s in [cElMap2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cComposElMap2D, name, value)
    __swig_getmethods__ = {}
    for _s in [cElMap2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cComposElMap2D, name)
    __repr__ = _swig_repr

    def Type(self) -> "int":
        return _mm3d.cComposElMap2D_Type(self)

    def __init__(self, aVMap: 'std::vector< cElMap2D *,std::allocator< cElMap2D * > > const &'):
        this = _mm3d.new_cComposElMap2D(aVMap)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, p: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cComposElMap2D___call__(self, p)

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.cComposElMap2D_Map2DInverse(self)

    def Simplify(self) -> "cElMap2D *":
        return _mm3d.cComposElMap2D_Simplify(self)

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.cComposElMap2D_ToXmlGen(self)
    __swig_setmethods__["mVMap"] = _mm3d.cComposElMap2D_mVMap_set
    __swig_getmethods__["mVMap"] = _mm3d.cComposElMap2D_mVMap_get
    if _newclass:
        mVMap = _swig_property(_mm3d.cComposElMap2D_mVMap_get, _mm3d.cComposElMap2D_mVMap_set)
    __swig_destroy__ = _mm3d.delete_cComposElMap2D
    __del__ = lambda self: None
cComposElMap2D_swigregister = _mm3d.cComposElMap2D_swigregister
cComposElMap2D_swigregister(cComposElMap2D)

class ElHomot(cElMap2D):
    __swig_setmethods__ = {}
    for _s in [cElMap2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElHomot, name, value)
    __swig_getmethods__ = {}
    for _s in [cElMap2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElHomot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_ElHomot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, p: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElHomot___call__(self, p)

    def __mul__(self, sim2: 'ElHomot') -> "ElHomot":
        return _mm3d.ElHomot___mul__(self, sim2)

    def Type(self) -> "int":
        return _mm3d.ElHomot_Type(self)

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.ElHomot_Map2DInverse(self)

    def Duplicate(self) -> "cElMap2D *":
        return _mm3d.ElHomot_Duplicate(self)

    def Identity(self) -> "cElMap2D *":
        return _mm3d.ElHomot_Identity(self)

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.ElHomot_ToXmlGen(self)

    def inv(self) -> "ElHomot":
        return _mm3d.ElHomot_inv(self)

    def NbUnknown(self) -> "int":
        return _mm3d.ElHomot_NbUnknown(self)

    def AddEq(self, aCste: 'Pt2dr', anEqX: 'DoubleVector', anEqY: 'DoubleVector', aP1: 'Pt2dr', aP2: 'Pt2dr') -> "void":
        return _mm3d.ElHomot_AddEq(self, aCste, anEqX, anEqY, aP1, aP2)

    def InitFromParams(self, aSol: 'DoubleVector') -> "void":
        return _mm3d.ElHomot_InitFromParams(self, aSol)

    def Params(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.ElHomot_Params(self)

    def Tr(self) -> "Pt2dr const &":
        return _mm3d.ElHomot_Tr(self)

    def Sc(self) -> "double const &":
        return _mm3d.ElHomot_Sc(self)
    __swig_destroy__ = _mm3d.delete_ElHomot
    __del__ = lambda self: None
ElHomot_swigregister = _mm3d.ElHomot_swigregister
ElHomot_swigregister(ElHomot)


def Xml2EL(arg1: 'cXml_Homot const &') -> "ElHomot":
    return _mm3d.Xml2EL(arg1)
Xml2EL = _mm3d.Xml2EL

def EL2Xml(arg1: 'ElHomot') -> "cXml_Homot":
    return _mm3d.EL2Xml(arg1)
EL2Xml = _mm3d.EL2Xml
class ElSimilitude(cElMap2D):
    __swig_setmethods__ = {}
    for _s in [cElMap2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElSimilitude, name, value)
    __swig_getmethods__ = {}
    for _s in [cElMap2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElSimilitude, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_ElSimilitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        SimOfCentre = staticmethod(_mm3d.ElSimilitude_SimOfCentre)
    else:
        SimOfCentre = _mm3d.ElSimilitude_SimOfCentre

    def __call__(self, p: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElSimilitude___call__(self, p)

    def __mul__(self, sim2: 'ElSimilitude') -> "ElSimilitude":
        return _mm3d.ElSimilitude___mul__(self, sim2)

    def NbUnknown(self) -> "int":
        return _mm3d.ElSimilitude_NbUnknown(self)

    def AddEq(self, aCste: 'Pt2dr', anEqX: 'DoubleVector', anEqY: 'DoubleVector', aP1: 'Pt2dr', aP2: 'Pt2dr') -> "void":
        return _mm3d.ElSimilitude_AddEq(self, aCste, anEqX, anEqY, aP1, aP2)

    def InitFromParams(self, aSol: 'DoubleVector') -> "void":
        return _mm3d.ElSimilitude_InitFromParams(self, aSol)

    def Params(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.ElSimilitude_Params(self)

    def Type(self) -> "int":
        return _mm3d.ElSimilitude_Type(self)

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.ElSimilitude_Map2DInverse(self)

    def Duplicate(self) -> "cElMap2D *":
        return _mm3d.ElSimilitude_Duplicate(self)

    def Identity(self) -> "cElMap2D *":
        return _mm3d.ElSimilitude_Identity(self)

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.ElSimilitude_ToXmlGen(self)

    def inv(self) -> "ElSimilitude":
        return _mm3d.ElSimilitude_inv(self)

    def tr(self) -> "Pt2dr":
        return _mm3d.ElSimilitude_tr(self)

    def sc(self) -> "Pt2dr":
        return _mm3d.ElSimilitude_sc(self)
    __swig_destroy__ = _mm3d.delete_ElSimilitude
    __del__ = lambda self: None
ElSimilitude_swigregister = _mm3d.ElSimilitude_swigregister
ElSimilitude_swigregister(ElSimilitude)

def ElSimilitude_SimOfCentre(*args) -> "ElSimilitude":
    return _mm3d.ElSimilitude_SimOfCentre(*args)
ElSimilitude_SimOfCentre = _mm3d.ElSimilitude_SimOfCentre


def L2EstimSimHom(aPack: 'ElPackHomologue') -> "ElSimilitude":
    return _mm3d.L2EstimSimHom(aPack)
L2EstimSimHom = _mm3d.L2EstimSimHom
class ElAffin2D(cElMap2D):
    __swig_setmethods__ = {}
    for _s in [cElMap2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElAffin2D, name, value)
    __swig_getmethods__ = {}
    for _s in [cElMap2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElAffin2D, name)
    __repr__ = _swig_repr
    if _newclass:
        L2Fit = staticmethod(_mm3d.ElAffin2D_L2Fit)
    else:
        L2Fit = _mm3d.ElAffin2D_L2Fit

    def IsId(self) -> "bool":
        return _mm3d.ElAffin2D_IsId(self)
    if _newclass:
        Id = staticmethod(_mm3d.ElAffin2D_Id)
    else:
        Id = _mm3d.ElAffin2D_Id
    if _newclass:
        trans = staticmethod(_mm3d.ElAffin2D_trans)
    else:
        trans = _mm3d.ElAffin2D_trans
    if _newclass:
        TransfoImCropAndSousEch = staticmethod(_mm3d.ElAffin2D_TransfoImCropAndSousEch)
    else:
        TransfoImCropAndSousEch = _mm3d.ElAffin2D_TransfoImCropAndSousEch

    def __init__(self, *args):
        this = _mm3d.new_ElAffin2D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IVect(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElAffin2D_IVect(self, aP)

    def __call__(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElAffin2D___call__(self, aP)

    def __mul__(self, sim2: 'ElAffin2D') -> "ElAffin2D":
        return _mm3d.ElAffin2D___mul__(self, sim2)

    def __add__(self, sim2: 'ElAffin2D') -> "ElAffin2D":
        return _mm3d.ElAffin2D___add__(self, sim2)

    def inv(self) -> "ElAffin2D":
        return _mm3d.ElAffin2D_inv(self)

    def NbUnknown(self) -> "int":
        return _mm3d.ElAffin2D_NbUnknown(self)

    def AddEq(self, aCste: 'Pt2dr', anEqX: 'DoubleVector', anEqY: 'DoubleVector', aP1: 'Pt2dr', aP2: 'Pt2dr') -> "void":
        return _mm3d.ElAffin2D_AddEq(self, aCste, anEqX, anEqY, aP1, aP2)

    def InitFromParams(self, aSol: 'DoubleVector') -> "void":
        return _mm3d.ElAffin2D_InitFromParams(self, aSol)

    def Params(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.ElAffin2D_Params(self)

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.ElAffin2D_Map2DInverse(self)

    def Type(self) -> "int":
        return _mm3d.ElAffin2D_Type(self)

    def Duplicate(self) -> "cElMap2D *":
        return _mm3d.ElAffin2D_Duplicate(self)

    def Identity(self) -> "cElMap2D *":
        return _mm3d.ElAffin2D_Identity(self)

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.ElAffin2D_ToXmlGen(self)

    def I00(self) -> "Pt2dr":
        return _mm3d.ElAffin2D_I00(self)

    def I10(self) -> "Pt2dr":
        return _mm3d.ElAffin2D_I10(self)

    def I01(self) -> "Pt2dr":
        return _mm3d.ElAffin2D_I01(self)
    if _newclass:
        FromTri2Tri = staticmethod(_mm3d.ElAffin2D_FromTri2Tri)
    else:
        FromTri2Tri = _mm3d.ElAffin2D_FromTri2Tri

    def ToHomographie(self) -> "cElHomographie":
        return _mm3d.ElAffin2D_ToHomographie(self)

    def CorrectWithMatch(self, aPt: 'Pt2dr', aRes: 'Pt2dr') -> "ElAffin2D":
        return _mm3d.ElAffin2D_CorrectWithMatch(self, aPt, aRes)
    __swig_destroy__ = _mm3d.delete_ElAffin2D
    __del__ = lambda self: None
ElAffin2D_swigregister = _mm3d.ElAffin2D_swigregister
ElAffin2D_swigregister(ElAffin2D)

def ElAffin2D_L2Fit(arg1: 'ElPackHomologue', aRes: 'double *'=None) -> "ElAffin2D":
    return _mm3d.ElAffin2D_L2Fit(arg1, aRes)
ElAffin2D_L2Fit = _mm3d.ElAffin2D_L2Fit

def ElAffin2D_Id() -> "ElAffin2D":
    return _mm3d.ElAffin2D_Id()
ElAffin2D_Id = _mm3d.ElAffin2D_Id

def ElAffin2D_trans(aTr: 'Pt2dr') -> "ElAffin2D":
    return _mm3d.ElAffin2D_trans(aTr)
ElAffin2D_trans = _mm3d.ElAffin2D_trans

def ElAffin2D_TransfoImCropAndSousEch(*args) -> "ElAffin2D":
    return _mm3d.ElAffin2D_TransfoImCropAndSousEch(*args)
ElAffin2D_TransfoImCropAndSousEch = _mm3d.ElAffin2D_TransfoImCropAndSousEch

def ElAffin2D_FromTri2Tri(a0: 'Pt2dr', a1: 'Pt2dr', a2: 'Pt2dr', b0: 'Pt2dr', b1: 'Pt2dr', b2: 'Pt2dr') -> "ElAffin2D":
    return _mm3d.ElAffin2D_FromTri2Tri(a0, a1, a2, b0, b1, b2)
ElAffin2D_FromTri2Tri = _mm3d.ElAffin2D_FromTri2Tri


def DMaxCoins(*args) -> "double":
    return _mm3d.DMaxCoins(*args)
DMaxCoins = _mm3d.DMaxCoins

def average_euclid_line_seed(arg1: 'Pt2di') -> "double":
    return _mm3d.average_euclid_line_seed(arg1)
average_euclid_line_seed = _mm3d.average_euclid_line_seed

def best_4_approx(p: 'Pt2di') -> "Pt2di":
    return _mm3d.best_4_approx(p)
best_4_approx = _mm3d.best_4_approx

def second_freeman_approx(u: 'Pt2di', conx_8: 'bool', u1: 'Pt2di') -> "Pt2di":
    return _mm3d.second_freeman_approx(u, conx_8, u1)
second_freeman_approx = _mm3d.second_freeman_approx

def num_4_freeman(arg1: 'Pt2di') -> "int":
    return _mm3d.num_4_freeman(arg1)
num_4_freeman = _mm3d.num_4_freeman

def ImAppSym(A: 'double', B: 'double', C: 'double', aP: 'Pt2dr') -> "Pt2dr":
    return _mm3d.ImAppSym(A, B, C, aP)
ImAppSym = _mm3d.ImAppSym

def corner_box_included(pmin: 'Pt2di', pmax: 'Pt2di', left: 'bool', down: 'bool') -> "Pt2di":
    return _mm3d.corner_box_included(pmin, pmax, left, down)
corner_box_included = _mm3d.corner_box_included

def round_ni(*args) -> "Pt2di":
    return _mm3d.round_ni(*args)
round_ni = _mm3d.round_ni

def round_up(*args) -> "Pt2di":
    return _mm3d.round_up(*args)
round_up = _mm3d.round_up

def arrondi_sup(*args) -> "Pt2di":
    return _mm3d.arrondi_sup(*args)
arrondi_sup = _mm3d.arrondi_sup

def rot90(p: 'Pt2dr') -> "Pt2dr":
    return _mm3d.rot90(p)
rot90 = _mm3d.rot90

def angle(*args) -> "double":
    return _mm3d.angle(*args)
angle = _mm3d.angle

def angle_de_droite(*args) -> "double":
    return _mm3d.angle_de_droite(*args)
angle_de_droite = _mm3d.angle_de_droite

def angle_de_droite_nor(*args) -> "double":
    return _mm3d.angle_de_droite_nor(*args)
angle_de_droite_nor = _mm3d.angle_de_droite_nor

def PointInCouronne(aD8Min: 'int', aD8Max: 'int') -> "std::vector< Pt2di,std::allocator< Pt2di > >":
    return _mm3d.PointInCouronne(aD8Min, aD8Max)
PointInCouronne = _mm3d.PointInCouronne

def PointOfCouronnes(Dist: 'IntVector', AddD4First: 'bool') -> "std::vector< std::vector< Pt2di,std::allocator< Pt2di > >,std::allocator< std::vector< Pt2di,std::allocator< Pt2di > > > >":
    return _mm3d.PointOfCouronnes(Dist, AddD4First)
PointOfCouronnes = _mm3d.PointOfCouronnes

def StdPointOfCouronnes(aDMax: 'int', AddD4First: 'bool') -> "std::vector< std::vector< Pt2di,std::allocator< Pt2di > >,std::allocator< std::vector< Pt2di,std::allocator< Pt2di > > > >":
    return _mm3d.StdPointOfCouronnes(aDMax, AddD4First)
StdPointOfCouronnes = _mm3d.StdPointOfCouronnes

def Pcoord2(*args) -> "Pt2dr":
    return _mm3d.Pcoord2(*args)
Pcoord2 = _mm3d.Pcoord2

def SomCoord(*args) -> "double":
    return _mm3d.SomCoord(*args)
SomCoord = _mm3d.SomCoord

def BadValue(*args) -> "bool":
    return _mm3d.BadValue(*args)
BadValue = _mm3d.BadValue

def OneDirOrtho(arg1: 'Pt3dr') -> "Pt3dr":
    return _mm3d.OneDirOrtho(arg1)
OneDirOrtho = _mm3d.OneDirOrtho

def round_down(*args) -> "Pt3di":
    return _mm3d.round_down(*args)
round_down = _mm3d.round_down

def vunit(*args) -> "Pt3dr":
    return _mm3d.vunit(*args)
vunit = _mm3d.vunit

def ToSpherique(aP: 'Pt3dr', rho: 'double &', teta: 'double &', phi: 'double &') -> "double":
    return _mm3d.ToSpherique(aP, rho, teta, phi)
ToSpherique = _mm3d.ToSpherique
class ElCmpZ(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElCmpZ, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElCmpZ, name)
    __repr__ = _swig_repr

    def __call__(self, p1: 'Pt3di const &', p2: 'Pt3di const &') -> "bool":
        return _mm3d.ElCmpZ___call__(self, p1, p2)

    def __init__(self):
        this = _mm3d.new_ElCmpZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElCmpZ
    __del__ = lambda self: None
ElCmpZ_swigregister = _mm3d.ElCmpZ_swigregister
ElCmpZ_swigregister(ElCmpZ)

class ElCmp4Z(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElCmp4Z, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElCmp4Z, name)
    __repr__ = _swig_repr

    def __call__(self, p1: 'Pt4d< int > const &', p2: 'Pt4d< int > const &') -> "bool":
        return _mm3d.ElCmp4Z___call__(self, p1, p2)

    def __init__(self):
        this = _mm3d.new_ElCmp4Z()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElCmp4Z
    __del__ = lambda self: None
ElCmp4Z_swigregister = _mm3d.ElCmp4Z_swigregister
ElCmp4Z_swigregister(ElCmp4Z)

class Interval(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interval, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interval, name)
    __repr__ = _swig_repr
    __swig_setmethods__["_v0"] = _mm3d.Interval__v0_set
    __swig_getmethods__["_v0"] = _mm3d.Interval__v0_get
    if _newclass:
        _v0 = _swig_property(_mm3d.Interval__v0_get, _mm3d.Interval__v0_set)
    __swig_setmethods__["_v1"] = _mm3d.Interval__v1_set
    __swig_getmethods__["_v1"] = _mm3d.Interval__v1_get
    if _newclass:
        _v1 = _swig_property(_mm3d.Interval__v1_get, _mm3d.Interval__v1_set)

    def __init__(self, *args):
        this = _mm3d.new_Interval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dist(self, arg2: 'Interval') -> "double":
        return _mm3d.Interval_dist(self, arg2)
    __swig_destroy__ = _mm3d.delete_Interval
    __del__ = lambda self: None
Interval_swigregister = _mm3d.Interval_swigregister
Interval_swigregister(Interval)


def ToPt2dr(*args) -> "Pt2dr":
    return _mm3d.ToPt2dr(*args)
ToPt2dr = _mm3d.ToPt2dr

def ToPt2di(*args) -> "Pt2di":
    return _mm3d.ToPt2di(*args)
ToPt2di = _mm3d.ToPt2di

def MapPolFromHom(aPack: 'ElPackHomologue', aBox: 'Box2dr const &', aDeg: 'int', aRabDegInv: 'int') -> "cElMap2D *":
    return _mm3d.MapPolFromHom(aPack, aBox, aDeg, aRabDegInv)
MapPolFromHom = _mm3d.MapPolFromHom

def BoxPClipedIntervC(arg1: 'Box2di const &', arg2: 'Pt2di') -> "Pt2di":
    return _mm3d.BoxPClipedIntervC(arg1, arg2)
BoxPClipedIntervC = _mm3d.BoxPClipedIntervC

def RandomlyGenereInside(arg1: 'Box2di const &') -> "Pt2di":
    return _mm3d.RandomlyGenereInside(arg1)
RandomlyGenereInside = _mm3d.RandomlyGenereInside

def I2R(arg1: 'Box2di const &') -> "Box2dr":
    return _mm3d.I2R(arg1)
I2R = _mm3d.I2R

def R2I(arg1: 'Box2dr const &') -> "Box2di":
    return _mm3d.R2I(arg1)
R2I = _mm3d.R2I

def R2ISup(arg1: 'Box2dr const &') -> "Box2di":
    return _mm3d.R2ISup(arg1)
R2ISup = _mm3d.R2ISup

def AdaptParamCopyTrans(*args) -> "void":
    return _mm3d.AdaptParamCopyTrans(*args)
AdaptParamCopyTrans = _mm3d.AdaptParamCopyTrans
class cDecoupageInterv2D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDecoupageInterv2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cDecoupageInterv2D, name)
    __repr__ = _swig_repr

    def DilateBox(self, aKBox: 'int', arg3: 'Box2di const &', aDil: 'int') -> "Box2di":
        return _mm3d.cDecoupageInterv2D_DilateBox(self, aKBox, arg3, aDil)

    def __init__(self, aBoxGlob: 'Box2di const &', aSzMax: 'Pt2di', aSzBord: 'Box2di const &', anArrondi: 'int'=1):
        this = _mm3d.new_cDecoupageInterv2D(aBoxGlob, aSzMax, aSzBord, anArrondi)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        SimpleDec = staticmethod(_mm3d.cDecoupageInterv2D_SimpleDec)
    else:
        SimpleDec = _mm3d.cDecoupageInterv2D_SimpleDec

    def NbInterv(self) -> "int":
        return _mm3d.cDecoupageInterv2D_NbInterv(self)

    def KthIntervOut(self, aK: 'int') -> "Box2di":
        return _mm3d.cDecoupageInterv2D_KthIntervOut(self, aK)

    def IndexOfKBox(self, aKBOx: 'int') -> "Pt2di":
        return _mm3d.cDecoupageInterv2D_IndexOfKBox(self, aKBOx)

    def KthIntervIn(self, *args) -> "Box2di":
        return _mm3d.cDecoupageInterv2D_KthIntervIn(self, *args)

    def SzMaxOut(self) -> "Pt2di":
        return _mm3d.cDecoupageInterv2D_SzMaxOut(self)

    def SzMaxIn(self, *args) -> "Pt2di":
        return _mm3d.cDecoupageInterv2D_SzMaxIn(self, *args)

    def NbX(self) -> "int":
        return _mm3d.cDecoupageInterv2D_NbX(self)
    __swig_destroy__ = _mm3d.delete_cDecoupageInterv2D
    __del__ = lambda self: None
cDecoupageInterv2D_swigregister = _mm3d.cDecoupageInterv2D_swigregister
cDecoupageInterv2D_swigregister(cDecoupageInterv2D)

def cDecoupageInterv2D_SimpleDec(aSz: 'Pt2di', aSzMax: 'int', aSzBrd: 'int', anArrondi: 'int'=1) -> "cDecoupageInterv2D":
    return _mm3d.cDecoupageInterv2D_SimpleDec(aSz, aSzMax, aSzBrd, anArrondi)
cDecoupageInterv2D_SimpleDec = _mm3d.cDecoupageInterv2D_SimpleDec

class cMetaDataPhoto(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cMetaDataPhoto, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cMetaDataPhoto, name)
    __repr__ = _swig_repr

    def IsNoMTD(self) -> "bool":
        return _mm3d.cMetaDataPhoto_IsNoMTD(self)

    def MultiplierEqual(self, arg2: 'cMetaDataPhoto', AllOk: 'bool *') -> "double":
        return _mm3d.cMetaDataPhoto_MultiplierEqual(self, arg2, AllOk)
    if _newclass:
        CreateExiv2 = staticmethod(_mm3d.cMetaDataPhoto_CreateExiv2)
    else:
        CreateExiv2 = _mm3d.cMetaDataPhoto_CreateExiv2

    def Date(self, Svp: 'bool'=False) -> "cElDate const &":
        return _mm3d.cMetaDataPhoto_Date(self, Svp)

    def SetSz(self, arg2: 'Pt2di') -> "void":
        return _mm3d.cMetaDataPhoto_SetSz(self, arg2)

    def SetFocal(self, arg2: 'double const &') -> "void":
        return _mm3d.cMetaDataPhoto_SetFocal(self, arg2)

    def SetFoc35(self, arg2: 'double const &') -> "void":
        return _mm3d.cMetaDataPhoto_SetFoc35(self, arg2)

    def SetCam(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cMetaDataPhoto_SetCam(self, arg2)

    def FocMm(self, Svp: 'bool'=False) -> "double":
        return _mm3d.cMetaDataPhoto_FocMm(self, Svp)

    def Foc35(self, Svp: 'bool'=False) -> "double":
        return _mm3d.cMetaDataPhoto_Foc35(self, Svp)

    def FocPix(self) -> "double":
        return _mm3d.cMetaDataPhoto_FocPix(self)

    def NbBits(self, Svp: 'bool'=False) -> "int":
        return _mm3d.cMetaDataPhoto_NbBits(self, Svp)

    def ExpTime(self, Svp: 'bool'=False) -> "double":
        return _mm3d.cMetaDataPhoto_ExpTime(self, Svp)

    def Diaph(self, Svp: 'bool'=False) -> "double":
        return _mm3d.cMetaDataPhoto_Diaph(self, Svp)

    def IsoSpeed(self, Svp: 'bool'=False) -> "double":
        return _mm3d.cMetaDataPhoto_IsoSpeed(self, Svp)

    def Cam(self, Svp: 'bool'=False) -> "std::string const &":
        return _mm3d.cMetaDataPhoto_Cam(self, Svp)

    def XifSzIm(self, Svp: 'bool'=False) -> "Pt2di":
        return _mm3d.cMetaDataPhoto_XifSzIm(self, Svp)

    def TifSzIm(self, Svp: 'bool'=False) -> "Pt2di":
        return _mm3d.cMetaDataPhoto_TifSzIm(self, Svp)

    def SzImTifOrXif(self, Svp: 'bool'=False) -> "Pt2di":
        return _mm3d.cMetaDataPhoto_SzImTifOrXif(self, Svp)

    def SetXYZTetas(self, aXYZ: 'Pt3dr', Tetas: 'Pt3dr') -> "void":
        return _mm3d.cMetaDataPhoto_SetXYZTetas(self, aXYZ, Tetas)

    def XYZTetasInit(self) -> "bool":
        return _mm3d.cMetaDataPhoto_XYZTetasInit(self)

    def XYZ(self) -> "Pt3dr const &":
        return _mm3d.cMetaDataPhoto_XYZ(self)

    def Tetas(self) -> "Pt3dr const &":
        return _mm3d.cMetaDataPhoto_Tetas(self)

    def HasGPSLatLon(self) -> "bool const &":
        return _mm3d.cMetaDataPhoto_HasGPSLatLon(self)

    def GPSLat(self) -> "double const &":
        return _mm3d.cMetaDataPhoto_GPSLat(self)

    def GPSLon(self) -> "double const &":
        return _mm3d.cMetaDataPhoto_GPSLon(self)

    def HasGPSAlt(self) -> "bool const &":
        return _mm3d.cMetaDataPhoto_HasGPSAlt(self)

    def GPSAlt(self) -> "double const &":
        return _mm3d.cMetaDataPhoto_GPSAlt(self)

    def SetGPSLatLon(self, aLat: 'double const &', aLon: 'double const &') -> "void":
        return _mm3d.cMetaDataPhoto_SetGPSLatLon(self, aLat, aLon)

    def SetGPSAlt(self, anAlt: 'double const &') -> "void":
        return _mm3d.cMetaDataPhoto_SetGPSAlt(self, anAlt)

    def __init__(self, *args):
        this = _mm3d.new_cMetaDataPhoto(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BayPat(self) -> "std::string const &":
        return _mm3d.cMetaDataPhoto_BayPat(self)

    def FocForced(self) -> "bool &":
        return _mm3d.cMetaDataPhoto_FocForced(self)

    def Orientation(self) -> "std::string const &":
        return _mm3d.cMetaDataPhoto_Orientation(self)

    def CameraOrientation(self) -> "std::string const &":
        return _mm3d.cMetaDataPhoto_CameraOrientation(self)

    def dump(self, *args) -> "void":
        return _mm3d.cMetaDataPhoto_dump(self, *args)
    __swig_destroy__ = _mm3d.delete_cMetaDataPhoto
    __del__ = lambda self: None
cMetaDataPhoto_swigregister = _mm3d.cMetaDataPhoto_swigregister
cMetaDataPhoto_swigregister(cMetaDataPhoto)
aPRefFullFrame = cvar.aPRefFullFrame

def cMetaDataPhoto_CreateExiv2(arg2: 'std::string const &') -> "cMetaDataPhoto const &":
    return _mm3d.cMetaDataPhoto_CreateExiv2(arg2)
cMetaDataPhoto_CreateExiv2 = _mm3d.cMetaDataPhoto_CreateExiv2


def GetFocalMmDefined(aNameFile: 'std::string const &') -> "double":
    return _mm3d.GetFocalMmDefined(aNameFile)
GetFocalMmDefined = _mm3d.GetFocalMmDefined

def CmpY(aP1: 'Pt2di', aP2: 'Pt2di') -> "bool":
    return _mm3d.CmpY(aP1, aP2)
CmpY = _mm3d.CmpY
class cSysCoord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cSysCoord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cSysCoord, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def JacobToGeoc(self, *args) -> "ElMatrix< double >":
        return _mm3d.cSysCoord_JacobToGeoc(self, *args)

    def JacobFromGeoc(self, *args) -> "ElMatrix< double >":
        return _mm3d.cSysCoord_JacobFromGeoc(self, *args)

    def ToGeoC(self, *args) -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cSysCoord_ToGeoC(self, *args)

    def FromGeoC(self, *args) -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cSysCoord_FromGeoC(self, *args)

    def FromSys2This(self, arg2: 'cSysCoord', arg3: 'Pt3dr') -> "Pt3dr":
        return _mm3d.cSysCoord_FromSys2This(self, arg2, arg3)

    def JacobSys2This(self, *args) -> "ElMatrix< double >":
        return _mm3d.cSysCoord_JacobSys2This(self, *args)

    def ToXML(self) -> "cSystemeCoord":
        return _mm3d.cSysCoord_ToXML(self)

    def OdgEnMetre(self) -> "Pt3dr":
        return _mm3d.cSysCoord_OdgEnMetre(self)
    if _newclass:
        GeoC = staticmethod(_mm3d.cSysCoord_GeoC)
    else:
        GeoC = _mm3d.cSysCoord_GeoC
    if _newclass:
        WGS84 = staticmethod(_mm3d.cSysCoord_WGS84)
    else:
        WGS84 = _mm3d.cSysCoord_WGS84
    if _newclass:
        WGS84Degre = staticmethod(_mm3d.cSysCoord_WGS84Degre)
    else:
        WGS84Degre = _mm3d.cSysCoord_WGS84Degre
    if _newclass:
        RTL = staticmethod(_mm3d.cSysCoord_RTL)
    else:
        RTL = _mm3d.cSysCoord_RTL
    if _newclass:
        FromXML = staticmethod(_mm3d.cSysCoord_FromXML)
    else:
        FromXML = _mm3d.cSysCoord_FromXML
    if _newclass:
        FromFile = staticmethod(_mm3d.cSysCoord_FromFile)
    else:
        FromFile = _mm3d.cSysCoord_FromFile
    if _newclass:
        ModelePolyNomial = staticmethod(_mm3d.cSysCoord_ModelePolyNomial)
    else:
        ModelePolyNomial = _mm3d.cSysCoord_ModelePolyNomial
    if _newclass:
        TypedModelePolyNomial = staticmethod(_mm3d.cSysCoord_TypedModelePolyNomial)
    else:
        TypedModelePolyNomial = _mm3d.cSysCoord_TypedModelePolyNomial

    def Delete(self) -> "void":
        return _mm3d.cSysCoord_Delete(self)

    def Jacobien(self, *args) -> "std::vector< ElMatrix< double >,std::allocator< ElMatrix< double > > >":
        return _mm3d.cSysCoord_Jacobien(self, *args)
cSysCoord_swigregister = _mm3d.cSysCoord_swigregister
cSysCoord_swigregister(cSysCoord)

def cSysCoord_GeoC() -> "cSysCoord *":
    return _mm3d.cSysCoord_GeoC()
cSysCoord_GeoC = _mm3d.cSysCoord_GeoC

def cSysCoord_WGS84() -> "cSysCoord *":
    return _mm3d.cSysCoord_WGS84()
cSysCoord_WGS84 = _mm3d.cSysCoord_WGS84

def cSysCoord_WGS84Degre() -> "cSysCoord *":
    return _mm3d.cSysCoord_WGS84Degre()
cSysCoord_WGS84Degre = _mm3d.cSysCoord_WGS84Degre

def cSysCoord_RTL(Ori: 'Pt3dr') -> "cSysCoord *":
    return _mm3d.cSysCoord_RTL(Ori)
cSysCoord_RTL = _mm3d.cSysCoord_RTL

def cSysCoord_FromXML(arg2: 'cSystemeCoord const &', aDir: 'char const *') -> "cSysCoord *":
    return _mm3d.cSysCoord_FromXML(arg2, aDir)
cSysCoord_FromXML = _mm3d.cSysCoord_FromXML

def cSysCoord_FromFile(*args) -> "cSysCoord *":
    return _mm3d.cSysCoord_FromFile(*args)
cSysCoord_FromFile = _mm3d.cSysCoord_FromFile

def cSysCoord_ModelePolyNomial(aDegX: 'Pt3di', aDegY: 'Pt3di', aDegZ: 'Pt3di', aSysIn: 'cSysCoord', aVin: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &', aVout: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &') -> "cSysCoord *":
    return _mm3d.cSysCoord_ModelePolyNomial(aDegX, aDegY, aDegZ, aSysIn, aVin, aVout)
cSysCoord_ModelePolyNomial = _mm3d.cSysCoord_ModelePolyNomial

def cSysCoord_TypedModelePolyNomial(aDegX: 'Pt3di', aDegY: 'Pt3di', aDegZ: 'Pt3di', aSysIn: 'cSysCoord', aVin: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &', aVout: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &') -> "cSysCoordPolyn *":
    return _mm3d.cSysCoord_TypedModelePolyNomial(aDegX, aDegY, aDegZ, aSysIn, aVin, aVout)
cSysCoord_TypedModelePolyNomial = _mm3d.cSysCoord_TypedModelePolyNomial

class cProj4(cSysCoord):
    __swig_setmethods__ = {}
    for _s in [cSysCoord]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cProj4, name, value)
    __swig_getmethods__ = {}
    for _s in [cSysCoord]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cProj4, name)
    __repr__ = _swig_repr

    def __init__(self, aStr: 'std::string const &', aMOdg: 'Pt3dr'):
        this = _mm3d.new_cProj4(aStr, aMOdg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ToGeoC(self, arg2: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &') -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cProj4_ToGeoC(self, arg2)

    def FromGeoC(self, arg2: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &') -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cProj4_FromGeoC(self, arg2)
    if _newclass:
        Lambert = staticmethod(_mm3d.cProj4_Lambert)
    else:
        Lambert = _mm3d.cProj4_Lambert
    if _newclass:
        Lambert93 = staticmethod(_mm3d.cProj4_Lambert93)
    else:
        Lambert93 = _mm3d.cProj4_Lambert93

    def OdgEnMetre(self) -> "Pt3dr":
        return _mm3d.cProj4_OdgEnMetre(self)

    def ToXML(self) -> "cSystemeCoord":
        return _mm3d.cProj4_ToXML(self)

    def Delete(self) -> "void":
        return _mm3d.cProj4_Delete(self)
    __swig_destroy__ = _mm3d.delete_cProj4
    __del__ = lambda self: None
cProj4_swigregister = _mm3d.cProj4_swigregister
cProj4_swigregister(cProj4)

def cProj4_Lambert(aPhi0: 'double', aPhi1: 'double', aPhi2: 'double', aLon0: 'double', aX0: 'double', aY0: 'double') -> "cProj4":
    return _mm3d.cProj4_Lambert(aPhi0, aPhi1, aPhi2, aLon0, aX0, aY0)
cProj4_Lambert = _mm3d.cProj4_Lambert

def cProj4_Lambert93() -> "cProj4 *":
    return _mm3d.cProj4_Lambert93()
cProj4_Lambert93 = _mm3d.cProj4_Lambert93

class cCs2Cs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCs2Cs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cCs2Cs, name)
    __repr__ = _swig_repr

    def __init__(self, aStr: 'std::string const &'):
        this = _mm3d.new_cCs2Cs(aStr)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Chang(self, arg2: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &') -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cCs2Cs_Chang(self, arg2)

    def ToXML(self) -> "cSystemeCoord":
        return _mm3d.cCs2Cs_ToXML(self)
    __swig_destroy__ = _mm3d.delete_cCs2Cs
    __del__ = lambda self: None
cCs2Cs_swigregister = _mm3d.cCs2Cs_swigregister
cCs2Cs_swigregister(cCs2Cs)

class cTransfo3D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTransfo3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cTransfo3D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Src2Cibl(self, arg2: 'std::vector< Pt3dr,std::allocator< Pt3dr > > const &') -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cTransfo3D_Src2Cibl(self, arg2)
    __swig_destroy__ = _mm3d.delete_cTransfo3D
    __del__ = lambda self: None
    if _newclass:
        Alloc = staticmethod(_mm3d.cTransfo3D_Alloc)
    else:
        Alloc = _mm3d.cTransfo3D_Alloc
cTransfo3D_swigregister = _mm3d.cTransfo3D_swigregister
cTransfo3D_swigregister(cTransfo3D)

def cTransfo3D_Alloc(aName: 'std::string const &', aDir: 'std::string const &') -> "cTransfo3D *":
    return _mm3d.cTransfo3D_Alloc(aName, aDir)
cTransfo3D_Alloc = _mm3d.cTransfo3D_Alloc

class cChSysCo(cTransfo3D):
    __swig_setmethods__ = {}
    for _s in [cTransfo3D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cChSysCo, name, value)
    __swig_getmethods__ = {}
    for _s in [cTransfo3D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cChSysCo, name)
    __repr__ = _swig_repr

    def Src2Cibl(self, *args) -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cChSysCo_Src2Cibl(self, *args)

    def Cibl2Src(self, *args) -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
        return _mm3d.cChSysCo_Cibl2Src(self, *args)
    if _newclass:
        Alloc = staticmethod(_mm3d.cChSysCo_Alloc)
    else:
        Alloc = _mm3d.cChSysCo_Alloc

    def ChangCoordCamera(self, aVCam: 'std::vector< ElCamera *,std::allocator< ElCamera * > > const &', ForceRot: 'bool') -> "void":
        return _mm3d.cChSysCo_ChangCoordCamera(self, aVCam, ForceRot)

    def __init__(self, aSrc: 'cSysCoord', aCibl: 'cSysCoord'):
        this = _mm3d.new_cChSysCo(aSrc, aCibl)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
cChSysCo_swigregister = _mm3d.cChSysCo_swigregister
cChSysCo_swigregister(cChSysCo)

def cChSysCo_Alloc(aName: 'std::string const &', aDir: 'std::string const &') -> "cChSysCo *":
    return _mm3d.cChSysCo_Alloc(aName, aDir)
cChSysCo_Alloc = _mm3d.cChSysCo_Alloc

class cGeoRefRasterFile(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cGeoRefRasterFile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cGeoRefRasterFile, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'cXmlGeoRefFile const &', aDir: 'char const *'):
        this = _mm3d.new_cGeoRefRasterFile(arg2, aDir)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        FromFile = staticmethod(_mm3d.cGeoRefRasterFile_FromFile)
    else:
        FromFile = _mm3d.cGeoRefRasterFile_FromFile

    def File2Loc(self, *args) -> "Pt3dr":
        return _mm3d.cGeoRefRasterFile_File2Loc(self, *args)

    def File2GeoC(self, *args) -> "Pt3dr":
        return _mm3d.cGeoRefRasterFile_File2GeoC(self, *args)

    def Loc2File(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.cGeoRefRasterFile_Loc2File(self, arg2)

    def Geoc2File(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.cGeoRefRasterFile_Geoc2File(self, arg2)

    def ZMoyen(self) -> "double":
        return _mm3d.cGeoRefRasterFile_ZMoyen(self)
    __swig_destroy__ = _mm3d.delete_cGeoRefRasterFile
    __del__ = lambda self: None
cGeoRefRasterFile_swigregister = _mm3d.cGeoRefRasterFile_swigregister
cGeoRefRasterFile_swigregister(cGeoRefRasterFile)

def cGeoRefRasterFile_FromFile(*args) -> "cGeoRefRasterFile *":
    return _mm3d.cGeoRefRasterFile_FromFile(*args)
cGeoRefRasterFile_FromFile = _mm3d.cGeoRefRasterFile_FromFile


def GetDistribRepreBySort(aVP: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aNbOut: 'Pt2di', aPRep: 'Pt3dr') -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
    return _mm3d.GetDistribRepreBySort(aVP, aNbOut, aPRep)
GetDistribRepreBySort = _mm3d.GetDistribRepreBySort

def GetDistribRepresentative(aCdg: 'Pt3dr', aV: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', aNb: 'Pt2di') -> "std::vector< Pt3dr,std::allocator< Pt3dr > >":
    return _mm3d.GetDistribRepresentative(aCdg, aV, aNb)
GetDistribRepresentative = _mm3d.GetDistribRepresentative

def __lt__(aP1: 'Pt3di const &', aP2: 'Pt3di const &') -> "bool":
    return _mm3d.__lt__(aP1, aP2)
__lt__ = _mm3d.__lt__

def GetMTDImCalc(aNameIm: 'std::string const &') -> "cMTDImCalc":
    return _mm3d.GetMTDImCalc(aNameIm)
GetMTDImCalc = _mm3d.GetMTDImCalc

def GetIndicAutoCorrel(aMTD: 'cMTDImCalc const &', aSzW: 'int') -> "cMIC_IndicAutoCorrel const *":
    return _mm3d.GetIndicAutoCorrel(aMTD, aSzW)
GetIndicAutoCorrel = _mm3d.GetIndicAutoCorrel

def NameMTDImCalc(aFullName: 'std::string const &', Bin: 'bool') -> "std::string":
    return _mm3d.NameMTDImCalc(aFullName, Bin)
NameMTDImCalc = _mm3d.NameMTDImCalc

def CoutAttenueTetaMax(aVal: 'double const &', aVMax: 'double const &') -> "double":
    return _mm3d.CoutAttenueTetaMax(aVal, aVMax)
CoutAttenueTetaMax = _mm3d.CoutAttenueTetaMax

def GenCoutAttenueTetaMax(aVal: 'double const &', aVMax: 'double const &') -> "double":
    return _mm3d.GenCoutAttenueTetaMax(aVal, aVMax)
GenCoutAttenueTetaMax = _mm3d.GenCoutAttenueTetaMax

def arrondi_ni(*args) -> "Pt2dr":
    return _mm3d.arrondi_ni(*args)
arrondi_ni = _mm3d.arrondi_ni

def to_yes_no(aBoolean: 'bool') -> "std::string":
    return _mm3d.to_yes_no(aBoolean)
to_yes_no = _mm3d.to_yes_no

def to_true_false(aBoolean: 'bool') -> "std::string":
    return _mm3d.to_true_false(aBoolean)
to_true_false = _mm3d.to_true_false

def SortedVoisinDisk(aDistMin: 'double', aDistMax: 'double', Sort: 'bool') -> "std::vector< Pt2di,std::allocator< Pt2di > >":
    return _mm3d.SortedVoisinDisk(aDistMin, aDistMax, Sort)
SortedVoisinDisk = _mm3d.SortedVoisinDisk
class cSegEntierHor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cSegEntierHor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cSegEntierHor, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mP0"] = _mm3d.cSegEntierHor_mP0_set
    __swig_getmethods__["mP0"] = _mm3d.cSegEntierHor_mP0_get
    if _newclass:
        mP0 = _swig_property(_mm3d.cSegEntierHor_mP0_get, _mm3d.cSegEntierHor_mP0_set)
    __swig_setmethods__["mNb"] = _mm3d.cSegEntierHor_mNb_set
    __swig_getmethods__["mNb"] = _mm3d.cSegEntierHor_mNb_get
    if _newclass:
        mNb = _swig_property(_mm3d.cSegEntierHor_mNb_get, _mm3d.cSegEntierHor_mNb_set)

    def __init__(self):
        this = _mm3d.new_cSegEntierHor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cSegEntierHor
    __del__ = lambda self: None
cSegEntierHor_swigregister = _mm3d.cSegEntierHor_swigregister
cSegEntierHor_swigregister(cSegEntierHor)


def RasterTriangle(aTri: 'cElTriangleComp const &', aRes: 'std::vector< cSegEntierHor,std::allocator< cSegEntierHor > > &') -> "void":
    return _mm3d.RasterTriangle(aTri, aRes)
RasterTriangle = _mm3d.RasterTriangle
ElPrefDist_M2C = _mm3d.ElPrefDist_M2C
class Appar23(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Appar23, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Appar23, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pim"] = _mm3d.Appar23_pim_set
    __swig_getmethods__["pim"] = _mm3d.Appar23_pim_get
    if _newclass:
        pim = _swig_property(_mm3d.Appar23_pim_get, _mm3d.Appar23_pim_set)
    __swig_setmethods__["pter"] = _mm3d.Appar23_pter_set
    __swig_getmethods__["pter"] = _mm3d.Appar23_pter_get
    if _newclass:
        pter = _swig_property(_mm3d.Appar23_pter_get, _mm3d.Appar23_pter_set)
    __swig_setmethods__["mNum"] = _mm3d.Appar23_mNum_set
    __swig_getmethods__["mNum"] = _mm3d.Appar23_mNum_get
    if _newclass:
        mNum = _swig_property(_mm3d.Appar23_mNum_get, _mm3d.Appar23_mNum_set)

    def __init__(self, *args):
        this = _mm3d.new_Appar23(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_Appar23
    __del__ = lambda self: None
Appar23_swigregister = _mm3d.Appar23_swigregister
Appar23_swigregister(Appar23)


def BarryImTer(arg1: 'std::list< Appar23,std::allocator< Appar23 > > const &') -> "Appar23":
    return _mm3d.BarryImTer(arg1)
BarryImTer = _mm3d.BarryImTer

def InvY(arg1: 'std::list< Appar23,std::allocator< Appar23 > > &', aSzIm: 'Pt2dr', InvX: 'bool'=False) -> "void":
    return _mm3d.InvY(arg1, aSzIm, InvX)
InvY = _mm3d.InvY
class cNupletPtsHomologues(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cNupletPtsHomologues, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cNupletPtsHomologues, name)
    __repr__ = _swig_repr

    def ToCple(self, *args) -> "ElCplePtsHomologues const &":
        return _mm3d.cNupletPtsHomologues_ToCple(self, *args)

    def P1(self, *args) -> "Pt2dr &":
        return _mm3d.cNupletPtsHomologues_P1(self, *args)

    def P2(self, *args) -> "Pt2dr &":
        return _mm3d.cNupletPtsHomologues_P2(self, *args)

    def Pds(self, *args) -> "double &":
        return _mm3d.cNupletPtsHomologues_Pds(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_cNupletPtsHomologues(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cNupletPtsHomologues
    __del__ = lambda self: None

    def NbPts(self) -> "int":
        return _mm3d.cNupletPtsHomologues_NbPts(self)

    def PK(self, *args) -> "Pt2dr &":
        return _mm3d.cNupletPtsHomologues_PK(self, *args)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.cNupletPtsHomologues_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.cNupletPtsHomologues_read)
    else:
        read = _mm3d.cNupletPtsHomologues_read

    def AddPts(self, aPt: 'Pt2dr') -> "void":
        return _mm3d.cNupletPtsHomologues_AddPts(self, aPt)

    def IsDr(self, aK: 'int') -> "bool":
        return _mm3d.cNupletPtsHomologues_IsDr(self, aK)

    def SetDr(self, aK: 'int') -> "void":
        return _mm3d.cNupletPtsHomologues_SetDr(self, aK)
cNupletPtsHomologues_swigregister = _mm3d.cNupletPtsHomologues_swigregister
cNupletPtsHomologues_swigregister(cNupletPtsHomologues)

def cNupletPtsHomologues_read(aFile: 'ELISE_fp &') -> "cNupletPtsHomologues":
    return _mm3d.cNupletPtsHomologues_read(aFile)
cNupletPtsHomologues_read = _mm3d.cNupletPtsHomologues_read

class ElCplePtsHomologues(cNupletPtsHomologues):
    __swig_setmethods__ = {}
    for _s in [cNupletPtsHomologues]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElCplePtsHomologues, name, value)
    __swig_getmethods__ = {}
    for _s in [cNupletPtsHomologues]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElCplePtsHomologues, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_ElCplePtsHomologues(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def P1(self, *args) -> "Pt2dr &":
        return _mm3d.ElCplePtsHomologues_P1(self, *args)

    def P2(self, *args) -> "Pt2dr &":
        return _mm3d.ElCplePtsHomologues_P2(self, *args)

    def SelfSwap(self) -> "void":
        return _mm3d.ElCplePtsHomologues_SelfSwap(self)

    def Profondeur(self, aR: 'ElRotation3D') -> "double":
        return _mm3d.ElCplePtsHomologues_Profondeur(self, aR)
    __swig_destroy__ = _mm3d.delete_ElCplePtsHomologues
    __del__ = lambda self: None
ElCplePtsHomologues_swigregister = _mm3d.ElCplePtsHomologues_swigregister
ElCplePtsHomologues_swigregister(ElCplePtsHomologues)

eModeleCamIdeale = _mm3d.eModeleCamIdeale
eModeleCamDRad = _mm3d.eModeleCamDRad
eModeleCamPhgrsStd = _mm3d.eModeleCamPhgrsStd
class cResolvAmbiBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cResolvAmbiBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cResolvAmbiBase, name)
    __repr__ = _swig_repr

    def __init__(self, aR0: 'ElRotation3D', aR1: 'ElRotation3D'):
        this = _mm3d.new_cResolvAmbiBase(aR0, aR1)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddHom(self, aH12: 'ElPackHomologue', aR2: 'ElRotation3D') -> "void":
        return _mm3d.cResolvAmbiBase_AddHom(self, aH12, aR2)

    def SolveBase(self) -> "double":
        return _mm3d.cResolvAmbiBase_SolveBase(self)

    def SolOrient(self, aLambda: 'double &') -> "ElRotation3D":
        return _mm3d.cResolvAmbiBase_SolOrient(self, aLambda)
    __swig_destroy__ = _mm3d.delete_cResolvAmbiBase
    __del__ = lambda self: None
cResolvAmbiBase_swigregister = _mm3d.cResolvAmbiBase_swigregister
cResolvAmbiBase_swigregister(cResolvAmbiBase)


def StdNuage3DFromFile(arg1: 'std::string const &') -> "std::vector< Pt3dr,std::allocator< Pt3dr > > *":
    return _mm3d.StdNuage3DFromFile(arg1)
StdNuage3DFromFile = _mm3d.StdNuage3DFromFile
class cElImPackHom(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElImPackHom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElImPackHom, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_cElImPackHom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFile(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cElImPackHom_AddFile(self, arg2)

    def SauvFile(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cElImPackHom_SauvFile(self, arg2)

    def NbIm(self) -> "int":
        return _mm3d.cElImPackHom_NbIm(self)

    def ToPackH(self, aK: 'int') -> "ElPackHomologue":
        return _mm3d.cElImPackHom_ToPackH(self, aK)

    def Sz(self) -> "Pt2di":
        return _mm3d.cElImPackHom_Sz(self)

    def P1(self, arg2: 'Pt2di') -> "Pt2dr":
        return _mm3d.cElImPackHom_P1(self, arg2)

    def PN(self, arg2: 'Pt2di', aK: 'int') -> "Pt2dr":
        return _mm3d.cElImPackHom_PN(self, arg2, aK)

    def PdsN(self, arg2: 'Pt2di', aK: 'int') -> "double":
        return _mm3d.cElImPackHom_PdsN(self, arg2, aK)
    __swig_destroy__ = _mm3d.delete_cElImPackHom
    __del__ = lambda self: None
cElImPackHom_swigregister = _mm3d.cElImPackHom_swigregister
cElImPackHom_swigregister(cElImPackHom)

class cPackNupletsHom(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cPackNupletsHom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cPackNupletsHom, name)
    __repr__ = _swig_repr

    def __init__(self, aDim: 'int'):
        this = _mm3d.new_cPackNupletsHom(aDim)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getList(self) -> "cPackNupletsHom::tCont &":
        return _mm3d.cPackNupletsHom_getList(self)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.cPackNupletsHom_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.cPackNupletsHom_read)
    else:
        read = _mm3d.cPackNupletsHom_read

    def back(self, *args) -> "cNupletPtsHomologues const &":
        return _mm3d.cPackNupletsHom_back(self, *args)

    def begin(self, *args) -> "cPackNupletsHom::const_iterator":
        return _mm3d.cPackNupletsHom_begin(self, *args)

    def end(self, *args) -> "cPackNupletsHom::const_iterator":
        return _mm3d.cPackNupletsHom_end(self, *args)

    def size(self) -> "int":
        return _mm3d.cPackNupletsHom_size(self)

    def clear(self) -> "void":
        return _mm3d.cPackNupletsHom_clear(self)

    def AddNuplet(self, arg2: 'cNupletPtsHomologues') -> "void":
        return _mm3d.cPackNupletsHom_AddNuplet(self, arg2)

    def Nuple_Nearest(self, aP: 'Pt2dr', aK: 'int') -> "cNupletPtsHomologues const *":
        return _mm3d.cPackNupletsHom_Nuple_Nearest(self, aP, aK)

    def Nuple_RemoveNearest(self, aP: 'Pt2dr', aK: 'int') -> "void":
        return _mm3d.cPackNupletsHom_Nuple_RemoveNearest(self, aP, aK)

    def ToPckCple(self) -> "ElPackHomologue const &":
        return _mm3d.cPackNupletsHom_ToPckCple(self)
    __swig_destroy__ = _mm3d.delete_cPackNupletsHom
    __del__ = lambda self: None
cPackNupletsHom_swigregister = _mm3d.cPackNupletsHom_swigregister
cPackNupletsHom_swigregister(cPackNupletsHom)

def cPackNupletsHom_read(aFile: 'ELISE_fp &') -> "cPackNupletsHom":
    return _mm3d.cPackNupletsHom_read(aFile)
cPackNupletsHom_read = _mm3d.cPackNupletsHom_read

class ElPackHomologue(cPackNupletsHom):
    __swig_setmethods__ = {}
    for _s in [cPackNupletsHom]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElPackHomologue, name, value)
    __swig_getmethods__ = {}
    for _s in [cPackNupletsHom]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElPackHomologue, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_ElPackHomologue()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SelfSwap(self) -> "void":
        return _mm3d.ElPackHomologue_SelfSwap(self)

    def ApplyHomographies(self, H1: 'cElHomographie', arg3: 'cElHomographie') -> "void":
        return _mm3d.ElPackHomologue_ApplyHomographies(self, H1, arg3)

    def Cple_Back(self, *args) -> "ElCplePtsHomologues const &":
        return _mm3d.ElPackHomologue_Cple_Back(self, *args)

    def Cple_Add(self, arg2: 'ElCplePtsHomologues') -> "void":
        return _mm3d.ElPackHomologue_Cple_Add(self, arg2)

    def Cple_Nearest(self, aP: 'Pt2dr', P1: 'bool'=True) -> "ElCplePtsHomologues const *":
        return _mm3d.ElPackHomologue_Cple_Nearest(self, aP, P1)

    def Cple_RemoveNearest(self, aP: 'Pt2dr', P1: 'bool'=True) -> "void":
        return _mm3d.ElPackHomologue_Cple_RemoveNearest(self, aP, P1)
    if _newclass:
        read = staticmethod(_mm3d.ElPackHomologue_read)
    else:
        read = _mm3d.ElPackHomologue_read

    def FitPolynome(self, aModeL2: 'bool', aDegre: 'int', anAmpl: 'double', aFitX: 'bool') -> "Polynome2dReal":
        return _mm3d.ElPackHomologue_FitPolynome(self, aModeL2, aDegre, anAmpl, aFitX)

    def FitDistPolynomiale(self, aL2: 'bool', aDegre: 'int', anAmpl: 'double', anEpsInv: 'double'=1e-7) -> "ElDistortionPolynomiale":
        return _mm3d.ElPackHomologue_FitDistPolynomiale(self, aL2, aDegre, anAmpl, anEpsInv)

    def DirEpipolaire(self, aDir1: 'Pt2dr', aDir2: 'Pt2dr', WantedPts: 'int', aNbDir: 'int', aDegre: 'int') -> "void":
        return _mm3d.ElPackHomologue_DirEpipolaire(self, aDir1, aDir2, WantedPts, aNbDir, aDegre)

    def DirAndCpleEpipolaire(self, aDir1: 'Pt2dr', aDir2: 'Pt2dr', WantedPts: 'int', aNbDir: 'int', aDegreFinal: 'int') -> "CpleEpipolaireCoord *":
        return _mm3d.ElPackHomologue_DirAndCpleEpipolaire(self, aDir1, aDir2, WantedPts, aNbDir, aDegreFinal)

    def MatriceEssentielle(self, *args) -> "double":
        return _mm3d.ElPackHomologue_MatriceEssentielle(self, *args)

    def OptimiseMEPRel(self, arg2: 'ElRotation3D') -> "ElRotation3D":
        return _mm3d.ElPackHomologue_OptimiseMEPRel(self, arg2)

    def MepRelGenSsOpt(self, LongBase: 'double', L2: 'bool', aD: 'double &') -> "ElRotation3D":
        return _mm3d.ElPackHomologue_MepRelGenSsOpt(self, LongBase, L2, aD)

    def MepRelGen(self, *args) -> "ElRotation3D":
        return _mm3d.ElPackHomologue_MepRelGen(self, *args)

    def MepRelCocentrique(self, aNbRansac: 'int', aNbMaxPts: 'int') -> "ElMatrix< double >":
        return _mm3d.ElPackHomologue_MepRelCocentrique(self, aNbRansac, aNbMaxPts)

    def MepRelStd(self, LongBase: 'double', L2: 'bool') -> "std::list< ElRotation3D,std::allocator< ElRotation3D > >":
        return _mm3d.ElPackHomologue_MepRelStd(self, LongBase, L2)

    def MepRelPhysStd(self, LongBase: 'double', L2: 'bool') -> "ElRotation3D":
        return _mm3d.ElPackHomologue_MepRelPhysStd(self, LongBase, L2)

    def SignInters(self, aRot1to2: 'ElRotation3D', NbP1: 'int &', NbP2: 'int &') -> "double":
        return _mm3d.ElPackHomologue_SignInters(self, aRot1to2, NbP1, NbP2)
    if _newclass:
        MepRelCoplan = staticmethod(_mm3d.ElPackHomologue_MepRelCoplan)
    else:
        MepRelCoplan = _mm3d.ElPackHomologue_MepRelCoplan
    if _newclass:
        FromFile = staticmethod(_mm3d.ElPackHomologue_FromFile)
    else:
        FromFile = _mm3d.ElPackHomologue_FromFile

    def FiltreByFileMasq(self, arg2: 'std::string const &', aVMin: 'double'=0.5) -> "ElPackHomologue":
        return _mm3d.ElPackHomologue_FiltreByFileMasq(self, arg2, aVMin)

    def StdPutInFile(self, arg2: 'std::string const &') -> "void":
        return _mm3d.ElPackHomologue_StdPutInFile(self, arg2)

    def StdAddInFile(self, arg2: 'std::string const &') -> "void":
        return _mm3d.ElPackHomologue_StdAddInFile(self, arg2)

    def Add(self, arg2: 'ElPackHomologue') -> "void":
        return _mm3d.ElPackHomologue_Add(self, arg2)

    def SetProfondeur(self, aR: 'ElRotation3D', aProf: 'double') -> "void":
        return _mm3d.ElPackHomologue_SetProfondeur(self, aR, aProf)

    def Profondeur(self, aR: 'ElRotation3D') -> "double":
        return _mm3d.ElPackHomologue_Profondeur(self, aR)

    def InvY(self, aSzIm1: 'Pt2dr', aSzIm2: 'Pt2dr') -> "void":
        return _mm3d.ElPackHomologue_InvY(self, aSzIm1, aSzIm2)

    def Resize(self, aRatioIm1: 'double', aRatioIm2: 'double') -> "void":
        return _mm3d.ElPackHomologue_Resize(self, aRatioIm1, aRatioIm2)

    def AngularDistInter(self, aR: 'ElRotation3D') -> "double":
        return _mm3d.ElPackHomologue_AngularDistInter(self, aR)

    def ProfMedCam2(self, VProf: 'DoubleVector', aR: 'ElRotation3D') -> "void":
        return _mm3d.ElPackHomologue_ProfMedCam2(self, VProf, aR)

    def QuickDistInter(self, aR: 'ElRotation3D', VProf: 'DoubleVector') -> "double":
        return _mm3d.ElPackHomologue_QuickDistInter(self, aR, VProf)
    __swig_destroy__ = _mm3d.delete_ElPackHomologue
    __del__ = lambda self: None
ElPackHomologue_swigregister = _mm3d.ElPackHomologue_swigregister
ElPackHomologue_swigregister(ElPackHomologue)

def ElPackHomologue_read(aFile: 'ELISE_fp &') -> "ElPackHomologue":
    return _mm3d.ElPackHomologue_read(aFile)
ElPackHomologue_read = _mm3d.ElPackHomologue_read

def ElPackHomologue_MepRelCoplan(*args) -> "cResMepRelCoplan":
    return _mm3d.ElPackHomologue_MepRelCoplan(*args)
ElPackHomologue_MepRelCoplan = _mm3d.ElPackHomologue_MepRelCoplan

def ElPackHomologue_FromFile(arg2: 'std::string const &') -> "ElPackHomologue":
    return _mm3d.ElPackHomologue_FromFile(arg2)
ElPackHomologue_FromFile = _mm3d.ElPackHomologue_FromFile

class StatElPackH(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StatElPackH, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StatElPackH, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'ElPackHomologue'):
        this = _mm3d.new_StatElPackH(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Cdg1(self) -> "Pt2dr":
        return _mm3d.StatElPackH_Cdg1(self)

    def Cdg2(self) -> "Pt2dr":
        return _mm3d.StatElPackH_Cdg2(self)

    def RMax1(self) -> "double":
        return _mm3d.StatElPackH_RMax1(self)

    def RMax2(self) -> "double":
        return _mm3d.StatElPackH_RMax2(self)

    def NbPts(self) -> "int":
        return _mm3d.StatElPackH_NbPts(self)

    def SomD1(self) -> "double":
        return _mm3d.StatElPackH_SomD1(self)

    def SomD2(self) -> "double":
        return _mm3d.StatElPackH_SomD2(self)
    __swig_destroy__ = _mm3d.delete_StatElPackH
    __del__ = lambda self: None
StatElPackH_swigregister = _mm3d.StatElPackH_swigregister
StatElPackH_swigregister(StatElPackH)

class ElProj32(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElProj32, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElProj32, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Proj(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElProj32_Proj(self, arg2)

    def DirRayon(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElProj32_DirRayon(self, arg2)

    def Rayon(self, arg2: 'Pt2dr', p0: 'Pt3dr', p1: 'Pt3dr') -> "void":
        return _mm3d.ElProj32_Rayon(self, arg2, p0, p1)

    def Diff(self, *args) -> "ElMatrix< double >":
        return _mm3d.ElProj32_Diff(self, *args)
    __swig_destroy__ = _mm3d.delete_ElProj32
    __del__ = lambda self: None
ElProj32_swigregister = _mm3d.ElProj32_swigregister
ElProj32_swigregister(ElProj32)

class ElProjIdentite(ElProj32):
    __swig_setmethods__ = {}
    for _s in [ElProj32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElProjIdentite, name, value)
    __swig_getmethods__ = {}
    for _s in [ElProj32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElProjIdentite, name)
    __repr__ = _swig_repr

    def Proj(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElProjIdentite_Proj(self, arg2)

    def DirRayon(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElProjIdentite_DirRayon(self, arg2)

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt3dr') -> "void":
        return _mm3d.ElProjIdentite_Diff(self, arg2, arg3)

    def Rayon(self, arg2: 'Pt2dr', p0: 'Pt3dr', p1: 'Pt3dr') -> "void":
        return _mm3d.ElProjIdentite_Rayon(self, arg2, p0, p1)
    __swig_setmethods__["TheOne"] = _mm3d.ElProjIdentite_TheOne_set
    __swig_getmethods__["TheOne"] = _mm3d.ElProjIdentite_TheOne_get
    if _newclass:
        TheOne = _swig_property(_mm3d.ElProjIdentite_TheOne_get, _mm3d.ElProjIdentite_TheOne_set)

    def __init__(self):
        this = _mm3d.new_ElProjIdentite()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElProjIdentite
    __del__ = lambda self: None
ElProjIdentite_swigregister = _mm3d.ElProjIdentite_swigregister
ElProjIdentite_swigregister(ElProjIdentite)

NbParamAF = _mm3d.NbParamAF
class ElProjStenope(ElProj32):
    __swig_setmethods__ = {}
    for _s in [ElProj32]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElProjStenope, name, value)
    __swig_getmethods__ = {}
    for _s in [ElProj32]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElProjStenope, name)
    __repr__ = _swig_repr

    def __init__(self, Focale: 'double', centre: 'Pt2dr', AFocalParam: 'DoubleVector'):
        this = _mm3d.new_ElProjStenope(Focale, centre, AFocalParam)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Proj(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElProjStenope_Proj(self, arg2)

    def DirRayon(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElProjStenope_DirRayon(self, arg2)

    def Rayon(self, arg2: 'Pt2dr', p0: 'Pt3dr', p1: 'Pt3dr') -> "void":
        return _mm3d.ElProjStenope_Rayon(self, arg2, p0, p1)

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt3dr') -> "void":
        return _mm3d.ElProjStenope_Diff(self, arg2, arg3)

    def centre(self) -> "Pt2dr":
        return _mm3d.ElProjStenope_centre(self)

    def set_centre(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.ElProjStenope_set_centre(self, arg2)
    __swig_destroy__ = _mm3d.delete_ElProjStenope
    __del__ = lambda self: None

    def CentreProjIm(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElProjStenope_CentreProjIm(self, arg2)

    def CentreProjTer(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.ElProjStenope_CentreProjTer(self, arg2)
ElProjStenope_swigregister = _mm3d.ElProjStenope_swigregister
ElProjStenope_swigregister(ElProjStenope)

class ElDistortion22_Gen(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistortion22_Gen, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistortion22_Gen, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CameraOwner(self) -> "ElCamera *":
        return _mm3d.ElDistortion22_Gen_CameraOwner(self)

    def SetCameraOwner(self, arg2: 'ElCamera') -> "void":
        return _mm3d.ElDistortion22_Gen_SetCameraOwner(self, arg2)

    def ToXmlStruct(self, arg2: 'ElCamera') -> "cCalibDistortion":
        return _mm3d.ElDistortion22_Gen_ToXmlStruct(self, arg2)

    def SetName(self, aName: 'char const *') -> "void":
        return _mm3d.ElDistortion22_Gen_SetName(self, aName)

    def Type(self) -> "std::string":
        return _mm3d.ElDistortion22_Gen_Type(self)

    def Name(self) -> "std::string":
        return _mm3d.ElDistortion22_Gen_Name(self)
    if _newclass:
        XmlDistNoVal = staticmethod(_mm3d.ElDistortion22_Gen_XmlDistNoVal)
    else:
        XmlDistNoVal = _mm3d.ElDistortion22_Gen_XmlDistNoVal

    def GetAsPreCond(self) -> "cPreCondGrid":
        return _mm3d.ElDistortion22_Gen_GetAsPreCond(self)
    if _newclass:
        AllocPreC = staticmethod(_mm3d.ElDistortion22_Gen_AllocPreC)
    else:
        AllocPreC = _mm3d.ElDistortion22_Gen_AllocPreC

    def D1(self, arg2: 'ElDistortion22_Gen', P0: 'Pt2dr', P1: 'Pt2dr', NbEch: 'int') -> "double":
        return _mm3d.ElDistortion22_Gen_D1(self, arg2, P0, P1, NbEch)

    def D2(self, arg2: 'ElDistortion22_Gen', P0: 'Pt2dr', P1: 'Pt2dr', NbEch: 'int') -> "double":
        return _mm3d.ElDistortion22_Gen_D2(self, arg2, P0, P1, NbEch)

    def DInfini(self, arg2: 'ElDistortion22_Gen', P0: 'Pt2dr', P1: 'Pt2dr', NbEch: 'int') -> "double":
        return _mm3d.ElDistortion22_Gen_DInfini(self, arg2, P0, P1, NbEch)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistortion22_Gen_Direct(self, arg2)

    def Inverse(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistortion22_Gen_Inverse(self, arg2)

    def Diff(self, arg2: 'Pt2dr') -> "ElMatrix< double >":
        return _mm3d.ElDistortion22_Gen_Diff(self, arg2)
    __swig_destroy__ = _mm3d.delete_ElDistortion22_Gen
    __del__ = lambda self: None

    def NewPolynLeastSquareInverse(self, aBox: 'Box2dr', aDegre: 'int', aNbPts: 'int'=-1) -> "ElDistortionPolynomiale":
        return _mm3d.ElDistortion22_Gen_NewPolynLeastSquareInverse(self, aBox, aDegre, aNbPts)

    def NewPolynLeastSquareInverse_OneCoord(self, XCoord: 'bool', aBox: 'Box2dr', aDegre: 'int', aNbPts: 'int'=-1) -> "Polynome2dReal":
        return _mm3d.ElDistortion22_Gen_NewPolynLeastSquareInverse_OneCoord(self, XCoord, aBox, aDegre, aNbPts)

    def D22G_ChScale(self, aS: 'double') -> "ElDistortion22_Gen *":
        return _mm3d.ElDistortion22_Gen_D22G_ChScale(self, aS)

    def IsId(self) -> "bool":
        return _mm3d.ElDistortion22_Gen_IsId(self)

    def DRADPol(self, strict: 'bool'=False) -> "ElDistRadiale_PolynImpair *":
        return _mm3d.ElDistortion22_Gen_DRADPol(self, strict)

    def ImageOfBox(self, arg2: 'Box2dr', aNbPtsDisc: 'int'=8) -> "Box2dr":
        return _mm3d.ElDistortion22_Gen_ImageOfBox(self, arg2, aNbPtsDisc)

    def ImageRecOfBox(self, arg2: 'Box2dr', aNbPtsDisc: 'int'=8) -> "Box2dr":
        return _mm3d.ElDistortion22_Gen_ImageRecOfBox(self, arg2, aNbPtsDisc)

    def CalcInverse(self) -> "ElDistortion22_Gen *":
        return _mm3d.ElDistortion22_Gen_CalcInverse(self)

    def SetParamConvInvDiff(self, aNbIter: 'int', aEps: 'double') -> "void":
        return _mm3d.ElDistortion22_Gen_SetParamConvInvDiff(self, aNbIter, aEps)

    def SaveAsGrid(self, arg2: 'std::string const &', aP0: 'Pt2dr', aP1: 'Pt2dr', aStep: 'Pt2dr') -> "void":
        return _mm3d.ElDistortion22_Gen_SaveAsGrid(self, arg2, aP0, aP1, aStep)

    def DirectAndDer(self, aP: 'Pt2dr', aGradX: 'Pt2dr', aGradY: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistortion22_Gen_DirectAndDer(self, aP, aGradX, aGradY)

    def AcceptScaling(self) -> "bool":
        return _mm3d.ElDistortion22_Gen_AcceptScaling(self)

    def AcceptTranslate(self) -> "bool":
        return _mm3d.ElDistortion22_Gen_AcceptTranslate(self)

    def SetScalingTranslate(self, F: 'double const &', aPP: 'Pt2dr') -> "void":
        return _mm3d.ElDistortion22_Gen_SetScalingTranslate(self, F, aPP)

    def ScN(self, *args) -> "double const &":
        return _mm3d.ElDistortion22_Gen_ScN(self, *args)

    def SetDist22Gen_UsePreConditionner(self, arg2: 'bool') -> "void":
        return _mm3d.ElDistortion22_Gen_SetDist22Gen_UsePreConditionner(self, arg2)

    def Dist22Gen_UsePreConditionner(self) -> "bool const &":
        return _mm3d.ElDistortion22_Gen_Dist22Gen_UsePreConditionner(self)

    def ComputeInvFromDirByDiff(self, aPt: 'Pt2dr', InvEstim0: 'Pt2dr', DiffReestim: 'bool') -> "Pt2dr":
        return _mm3d.ElDistortion22_Gen_ComputeInvFromDirByDiff(self, aPt, InvEstim0, DiffReestim)

    def SetDist22Gen_SupressPreCondInInverse(self, arg2: 'bool') -> "void":
        return _mm3d.ElDistortion22_Gen_SetDist22Gen_SupressPreCondInInverse(self, arg2)

    def Dist22Gen_SupressPreCondInInverse(self) -> "bool const &":
        return _mm3d.ElDistortion22_Gen_Dist22Gen_SupressPreCondInInverse(self)

    def GuessInv(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistortion22_Gen_GuessInv(self, aP)
ElDistortion22_Gen_swigregister = _mm3d.ElDistortion22_Gen_swigregister
ElDistortion22_Gen_swigregister(ElDistortion22_Gen)

def ElDistortion22_Gen_XmlDistNoVal() -> "cCalibDistortion":
    return _mm3d.ElDistortion22_Gen_XmlDistNoVal()
ElDistortion22_Gen_XmlDistNoVal = _mm3d.ElDistortion22_Gen_XmlDistNoVal

def ElDistortion22_Gen_AllocPreC(arg2: 'cPreCondGrid const &') -> "ElDistortion22_Gen *":
    return _mm3d.ElDistortion22_Gen_AllocPreC(arg2)
ElDistortion22_Gen_AllocPreC = _mm3d.ElDistortion22_Gen_AllocPreC

class cCamAsMap(cElMap2D):
    __swig_setmethods__ = {}
    for _s in [cElMap2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamAsMap, name, value)
    __swig_getmethods__ = {}
    for _s in [cElMap2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamAsMap, name)
    __repr__ = _swig_repr

    def Type(self) -> "int":
        return _mm3d.cCamAsMap_Type(self)

    def __init__(self, aCam: 'CamStenope', Direct: 'bool'):
        this = _mm3d.new_cCamAsMap(aCam, Direct)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __call__(self, p: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cCamAsMap___call__(self, p)

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.cCamAsMap_Map2DInverse(self)

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.cCamAsMap_ToXmlGen(self)
    __swig_destroy__ = _mm3d.delete_cCamAsMap
    __del__ = lambda self: None
cCamAsMap_swigregister = _mm3d.cCamAsMap_swigregister
cCamAsMap_swigregister(cCamAsMap)

class cElComposHomographie(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElComposHomographie, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElComposHomographie, name)
    __repr__ = _swig_repr

    def __call__(self, *args) -> "Fonc_Num":
        return _mm3d.cElComposHomographie___call__(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_cElComposHomographie(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ToXml(self) -> "cXmlAffinR2ToR":
        return _mm3d.cElComposHomographie_ToXml(self)

    def MulXY(self, arg2: 'double') -> "cElComposHomographie":
        return _mm3d.cElComposHomographie_MulXY(self, arg2)

    def MulCste(self, arg2: 'double') -> "cElComposHomographie":
        return _mm3d.cElComposHomographie_MulCste(self, arg2)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.cElComposHomographie_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.cElComposHomographie_read)
    else:
        read = _mm3d.cElComposHomographie_read

    def getCoeffX(self) -> "double &":
        return _mm3d.cElComposHomographie_getCoeffX(self)

    def getCoeffY(self) -> "double &":
        return _mm3d.cElComposHomographie_getCoeffY(self)

    def getCoeff1(self) -> "double &":
        return _mm3d.cElComposHomographie_getCoeff1(self)

    def CoeffX(self) -> "double":
        return _mm3d.cElComposHomographie_CoeffX(self)

    def CoeffY(self) -> "double":
        return _mm3d.cElComposHomographie_CoeffY(self)

    def Coeff1(self) -> "double":
        return _mm3d.cElComposHomographie_Coeff1(self)

    def Show(self, aMes: 'std::string const &') -> "void":
        return _mm3d.cElComposHomographie_Show(self, aMes)

    def HasNan(self) -> "bool":
        return _mm3d.cElComposHomographie_HasNan(self)
    __swig_destroy__ = _mm3d.delete_cElComposHomographie
    __del__ = lambda self: None
cElComposHomographie_swigregister = _mm3d.cElComposHomographie_swigregister
cElComposHomographie_swigregister(cElComposHomographie)

def cElComposHomographie_read(aFile: 'ELISE_fp &') -> "cElComposHomographie":
    return _mm3d.cElComposHomographie_read(aFile)
cElComposHomographie_read = _mm3d.cElComposHomographie_read

class cElHomographie(cElMap2D):
    __swig_setmethods__ = {}
    for _s in [cElMap2D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElHomographie, name, value)
    __swig_getmethods__ = {}
    for _s in [cElMap2D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cElHomographie, name)
    __repr__ = _swig_repr

    def __call__(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cElHomographie___call__(self, aP)

    def Type(self) -> "int":
        return _mm3d.cElHomographie_Type(self)

    def Map2DInverse(self) -> "cElMap2D *":
        return _mm3d.cElHomographie_Map2DInverse(self)

    def Duplicate(self) -> "cElMap2D *":
        return _mm3d.cElHomographie_Duplicate(self)

    def Identity(self) -> "cElMap2D *":
        return _mm3d.cElHomographie_Identity(self)

    def ToXmlGen(self) -> "cXml_Map2D":
        return _mm3d.cElHomographie_ToXmlGen(self)

    def NbUnknown(self) -> "int":
        return _mm3d.cElHomographie_NbUnknown(self)

    def AddEq(self, aCste: 'Pt2dr', EqX: 'DoubleVector', EqY: 'DoubleVector', aP1: 'Pt2dr', aP2: 'Pt2dr') -> "void":
        return _mm3d.cElHomographie_AddEq(self, aCste, EqX, EqY, aP1, aP2)

    def InitFromParams(self, aSol: 'DoubleVector') -> "void":
        return _mm3d.cElHomographie_InitFromParams(self, aSol)

    def Params(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.cElHomographie_Params(self)

    def HasNan(self) -> "bool":
        return _mm3d.cElHomographie_HasNan(self)

    def Direct(self, *args) -> "Pt2d< Fonc_Num >":
        return _mm3d.cElHomographie_Direct(self, *args)

    def Show(self) -> "void":
        return _mm3d.cElHomographie_Show(self)

    def ToXml(self) -> "cXmlHomogr":
        return _mm3d.cElHomographie_ToXml(self)
    if _newclass:
        RansacInitH = staticmethod(_mm3d.cElHomographie_RansacInitH)
    else:
        RansacInitH = _mm3d.cElHomographie_RansacInitH
    if _newclass:
        Id = staticmethod(_mm3d.cElHomographie_Id)
    else:
        Id = _mm3d.cElHomographie_Id
    if _newclass:
        Homotie = staticmethod(_mm3d.cElHomographie_Homotie)
    else:
        Homotie = _mm3d.cElHomographie_Homotie
    if _newclass:
        FromMatrix = staticmethod(_mm3d.cElHomographie_FromMatrix)
    else:
        FromMatrix = _mm3d.cElHomographie_FromMatrix

    def ToMatrix(self, arg2: 'ElMatrixr') -> "void":
        return _mm3d.cElHomographie_ToMatrix(self, arg2)

    def __init__(self, *args):
        this = _mm3d.new_cElHomographie(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Inverse(self) -> "cElHomographie":
        return _mm3d.cElHomographie_Inverse(self)

    def __mul__(self, arg2: 'cElHomographie') -> "cElHomographie":
        return _mm3d.cElHomographie___mul__(self, arg2)

    def MapingChScale(self, aChSacle: 'double') -> "cElHomographie":
        return _mm3d.cElHomographie_MapingChScale(self, aChSacle)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.cElHomographie_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.cElHomographie_read)
    else:
        read = _mm3d.cElHomographie_read

    def HX(self, *args) -> "cElComposHomographie const &":
        return _mm3d.cElHomographie_HX(self, *args)

    def HY(self, *args) -> "cElComposHomographie const &":
        return _mm3d.cElHomographie_HY(self, *args)

    def HZ(self, *args) -> "cElComposHomographie const &":
        return _mm3d.cElHomographie_HZ(self, *args)

    def MatCoordHom(self) -> "ElMatrix< double >":
        return _mm3d.cElHomographie_MatCoordHom(self)
    if _newclass:
        RobustInit = staticmethod(_mm3d.cElHomographie_RobustInit)
    else:
        RobustInit = _mm3d.cElHomographie_RobustInit
    if _newclass:
        SomPondHom = staticmethod(_mm3d.cElHomographie_SomPondHom)
    else:
        SomPondHom = _mm3d.cElHomographie_SomPondHom
    __swig_destroy__ = _mm3d.delete_cElHomographie
    __del__ = lambda self: None
cElHomographie_swigregister = _mm3d.cElHomographie_swigregister
cElHomographie_swigregister(cElHomographie)

def cElHomographie_RansacInitH(aPack: 'ElPackHomologue', aNbRansac: 'int', aNbMaxPts: 'int') -> "cElHomographie":
    return _mm3d.cElHomographie_RansacInitH(aPack, aNbRansac, aNbMaxPts)
cElHomographie_RansacInitH = _mm3d.cElHomographie_RansacInitH

def cElHomographie_Id() -> "cElHomographie":
    return _mm3d.cElHomographie_Id()
cElHomographie_Id = _mm3d.cElHomographie_Id

def cElHomographie_Homotie(aP: 'Pt2dr', aSc: 'double') -> "cElHomographie":
    return _mm3d.cElHomographie_Homotie(aP, aSc)
cElHomographie_Homotie = _mm3d.cElHomographie_Homotie

def cElHomographie_FromMatrix(arg2: 'ElMatrixr') -> "cElHomographie":
    return _mm3d.cElHomographie_FromMatrix(arg2)
cElHomographie_FromMatrix = _mm3d.cElHomographie_FromMatrix

def cElHomographie_read(aFile: 'ELISE_fp &') -> "cElHomographie":
    return _mm3d.cElHomographie_read(aFile)
cElHomographie_read = _mm3d.cElHomographie_read

def cElHomographie_RobustInit(anEcart: 'double &', aQuality: 'double *', aPack: 'ElPackHomologue', Ok: 'bool &', aNbTestEstim: 'int', aPerc: 'double', aNbMaxPts: 'int') -> "cElHomographie":
    return _mm3d.cElHomographie_RobustInit(anEcart, aQuality, aPack, Ok, aNbTestEstim, aPerc, aNbMaxPts)
cElHomographie_RobustInit = _mm3d.cElHomographie_RobustInit

def cElHomographie_SomPondHom(aVH: 'std::vector< cElHomographie,std::allocator< cElHomographie > > const &', aVP: 'DoubleVector') -> "cElHomographie":
    return _mm3d.cElHomographie_SomPondHom(aVH, aVP)
cElHomographie_SomPondHom = _mm3d.cElHomographie_SomPondHom

class cDistHomographie(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistHomographie, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistHomographie, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_cDistHomographie(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def OwnInverse(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cDistHomographie_OwnInverse(self, arg2)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistHomographie_Direct(self, arg2)

    def MapingChScale(self, aChSacle: 'double') -> "cDistHomographie":
        return _mm3d.cDistHomographie_MapingChScale(self, aChSacle)

    def Hom(self) -> "cElHomographie const &":
        return _mm3d.cDistHomographie_Hom(self)
    __swig_destroy__ = _mm3d.delete_cDistHomographie
    __del__ = lambda self: None
cDistHomographie_swigregister = _mm3d.cDistHomographie_swigregister
cDistHomographie_swigregister(cDistHomographie)

class ElDistortion22_Triviale(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistortion22_Triviale, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistortion22_Triviale, name)
    __repr__ = _swig_repr

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt2dr') -> "void":
        return _mm3d.ElDistortion22_Triviale_Diff(self, arg2, arg3)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistortion22_Triviale_Direct(self, arg2)
    __swig_setmethods__["TheOne"] = _mm3d.ElDistortion22_Triviale_TheOne_set
    __swig_getmethods__["TheOne"] = _mm3d.ElDistortion22_Triviale_TheOne_get
    if _newclass:
        TheOne = _swig_property(_mm3d.ElDistortion22_Triviale_TheOne_get, _mm3d.ElDistortion22_Triviale_TheOne_set)

    def D22G_ChScale(self, aS: 'double') -> "ElDistortion22_Gen *":
        return _mm3d.ElDistortion22_Triviale_D22G_ChScale(self, aS)

    def IsId(self) -> "bool":
        return _mm3d.ElDistortion22_Triviale_IsId(self)

    def ToXmlStruct(self, arg2: 'ElCamera') -> "cCalibDistortion":
        return _mm3d.ElDistortion22_Triviale_ToXmlStruct(self, arg2)

    def __init__(self):
        this = _mm3d.new_ElDistortion22_Triviale()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElDistortion22_Triviale
    __del__ = lambda self: None
ElDistortion22_Triviale_swigregister = _mm3d.ElDistortion22_Triviale_swigregister
ElDistortion22_Triviale_swigregister(ElDistortion22_Triviale)

class ElDistRadiale(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistRadiale, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistRadiale, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Centre(self, *args) -> "Pt2dr const &":
        return _mm3d.ElDistRadiale_Centre(self, *args)

    def OwnInverse(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.ElDistRadiale_OwnInverse(self, arg2)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistRadiale_Direct(self, arg2)

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt2dr') -> "void":
        return _mm3d.ElDistRadiale_Diff(self, arg2, arg3)

    def K0(self) -> "double":
        return _mm3d.ElDistRadiale_K0(self)

    def DistDirecte(self, R: 'double') -> "double":
        return _mm3d.ElDistRadiale_DistDirecte(self, R)

    def DistDirecteR2(self, R: 'double') -> "double":
        return _mm3d.ElDistRadiale_DistDirecteR2(self, R)

    def DerSurRho(self, R: 'double') -> "double":
        return _mm3d.ElDistRadiale_DerSurRho(self, R)

    def DistInverse(self, R: 'double') -> "double":
        return _mm3d.ElDistRadiale_DistInverse(self, R)
    __swig_destroy__ = _mm3d.delete_ElDistRadiale
    __del__ = lambda self: None
ElDistRadiale_swigregister = _mm3d.ElDistRadiale_swigregister
ElDistRadiale_swigregister(ElDistRadiale)

class ElDistRadiale_PolynImpair(ElDistRadiale):
    __swig_setmethods__ = {}
    for _s in [ElDistRadiale]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistRadiale_PolynImpair, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistRadiale]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistRadiale_PolynImpair, name)
    __repr__ = _swig_repr

    def __init__(self, RMax: 'double', centre: 'Pt2dr'):
        this = _mm3d.new_ElDistRadiale_PolynImpair(RMax, centre)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ActuRMaxFromDist(self, aSz: 'Pt2di') -> "void":
        return _mm3d.ElDistRadiale_PolynImpair_ActuRMaxFromDist(self, aSz)

    def ActuRMax(self) -> "void":
        return _mm3d.ElDistRadiale_PolynImpair_ActuRMax(self)

    def SetRMax(self, aV: 'double') -> "void":
        return _mm3d.ElDistRadiale_PolynImpair_SetRMax(self, aV)

    def DistDirecte(self, arg2: 'double') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_DistDirecte(self, arg2)

    def DistDirecteR2NoSeuil(self, R: 'double') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_DistDirecteR2NoSeuil(self, R)

    def DistDirecteR2(self, arg2: 'double') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_DistDirecteR2(self, arg2)

    def DerSurRho(self, arg2: 'double') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_DerSurRho(self, arg2)

    def PushCoeff(self, *args) -> "void":
        return _mm3d.ElDistRadiale_PolynImpair_PushCoeff(self, *args)

    def getCoeff(self, k: 'int') -> "double &":
        return _mm3d.ElDistRadiale_PolynImpair_getCoeff(self, k)

    def Coeff(self, k: 'int') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_Coeff(self, k)

    def NbCoeff(self) -> "int":
        return _mm3d.ElDistRadiale_PolynImpair_NbCoeff(self)

    def NbCoeffNN(self) -> "int":
        return _mm3d.ElDistRadiale_PolynImpair_NbCoeffNN(self)

    def VerifCoeff(self, aK: 'int') -> "void":
        return _mm3d.ElDistRadiale_PolynImpair_VerifCoeff(self, aK)

    def CoeffGen(self, aK: 'int') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_CoeffGen(self, aK)

    def DistRadialeInverse(self, RhoApp: 'double', DeltaDeg: 'int'=1) -> "ElDistRadiale_PolynImpair":
        return _mm3d.ElDistRadiale_PolynImpair_DistRadialeInverse(self, RhoApp, DeltaDeg)

    def MapingChScale(self, aChSacle: 'double') -> "ElDistRadiale_PolynImpair":
        return _mm3d.ElDistRadiale_PolynImpair_MapingChScale(self, aChSacle)
    if _newclass:
        DistId = staticmethod(_mm3d.ElDistRadiale_PolynImpair_DistId)
    else:
        DistId = _mm3d.ElDistRadiale_PolynImpair_DistId
    if _newclass:
        read = staticmethod(_mm3d.ElDistRadiale_PolynImpair_read)
    else:
        read = _mm3d.ElDistRadiale_PolynImpair_read

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.ElDistRadiale_PolynImpair_write(self, aFile)

    def RMax(self) -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_RMax(self)

    def ValRMax(self) -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_ValRMax(self)

    def DiffRMax(self) -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_DiffRMax(self)

    def DRADPol(self, strict: 'bool'=False) -> "ElDistRadiale_PolynImpair *":
        return _mm3d.ElDistRadiale_PolynImpair_DRADPol(self, strict)

    def PolynOfR(self) -> "ElPolynome< double >":
        return _mm3d.ElDistRadiale_PolynImpair_PolynOfR(self)

    def RMaxCroissant(self, BorneInit: 'double') -> "double":
        return _mm3d.ElDistRadiale_PolynImpair_RMaxCroissant(self, BorneInit)

    def ToXmlStruct(self, arg2: 'ElCamera') -> "cCalibDistortion":
        return _mm3d.ElDistRadiale_PolynImpair_ToXmlStruct(self, arg2)

    def ToXmlDradStruct(self) -> "cCalibrationInterneRadiale":
        return _mm3d.ElDistRadiale_PolynImpair_ToXmlDradStruct(self)
    __swig_destroy__ = _mm3d.delete_ElDistRadiale_PolynImpair
    __del__ = lambda self: None
ElDistRadiale_PolynImpair_swigregister = _mm3d.ElDistRadiale_PolynImpair_swigregister
ElDistRadiale_PolynImpair_swigregister(ElDistRadiale_PolynImpair)

def ElDistRadiale_PolynImpair_DistId(aRMax: 'double', aCentre: 'Pt2dr', aDeg: 'int') -> "ElDistRadiale_PolynImpair":
    return _mm3d.ElDistRadiale_PolynImpair_DistId(aRMax, aCentre, aDeg)
ElDistRadiale_PolynImpair_DistId = _mm3d.ElDistRadiale_PolynImpair_DistId

def ElDistRadiale_PolynImpair_read(*args) -> "ElDistRadiale_PolynImpair":
    return _mm3d.ElDistRadiale_PolynImpair_read(*args)
ElDistRadiale_PolynImpair_read = _mm3d.ElDistRadiale_PolynImpair_read

class ElDistRadiale_Pol357(ElDistRadiale_PolynImpair):
    __swig_setmethods__ = {}
    for _s in [ElDistRadiale_PolynImpair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistRadiale_Pol357, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistRadiale_PolynImpair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistRadiale_Pol357, name)
    __repr__ = _swig_repr

    def __init__(self, aRMax: 'double', centre: 'Pt2dr', c3: 'double', c5: 'double', c7: 'double'):
        this = _mm3d.new_ElDistRadiale_Pol357(aRMax, centre, c3, c5, c7)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElDistRadiale_Pol357
    __del__ = lambda self: None
ElDistRadiale_Pol357_swigregister = _mm3d.ElDistRadiale_Pol357_swigregister
ElDistRadiale_Pol357_swigregister(ElDistRadiale_Pol357)

class cDistHomographieRadiale(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistHomographieRadiale, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistHomographieRadiale, name)
    __repr__ = _swig_repr

    def __init__(self, anHom: 'cElHomographie', aDRad: 'ElDistRadiale_PolynImpair', aRayInv: 'double', aDeltaDegraInv: 'int'):
        this = _mm3d.new_cDistHomographieRadiale(anHom, aDRad, aRayInv, aDeltaDegraInv)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def OwnInverse(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cDistHomographieRadiale_OwnInverse(self, arg2)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistHomographieRadiale_Direct(self, arg2)

    def MapingChScale(self, aChSacle: 'double') -> "cDistHomographieRadiale":
        return _mm3d.cDistHomographieRadiale_MapingChScale(self, aChSacle)
    __swig_destroy__ = _mm3d.delete_cDistHomographieRadiale
    __del__ = lambda self: None
cDistHomographieRadiale_swigregister = _mm3d.cDistHomographieRadiale_swigregister
cDistHomographieRadiale_swigregister(cDistHomographieRadiale)

class PolyDegre2XY(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyDegre2XY, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolyDegre2XY, name)
    __repr__ = _swig_repr

    def __init__(self, a: 'double', aX: 'double', aY: 'double', aXX: 'double', aXY: 'double', aYY: 'double'):
        this = _mm3d.new_PolyDegre2XY(a, aX, aY, aXX, aXY, aYY)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Val(self, aPt: 'Pt2dr') -> "double":
        return _mm3d.PolyDegre2XY_Val(self, aPt)

    def Grad(self, aPt: 'Pt2dr') -> "Pt2dr":
        return _mm3d.PolyDegre2XY_Grad(self, aPt)

    def Coeff(self) -> "double &":
        return _mm3d.PolyDegre2XY_Coeff(self)

    def CoeffX(self) -> "double &":
        return _mm3d.PolyDegre2XY_CoeffX(self)

    def CoeffY(self) -> "double &":
        return _mm3d.PolyDegre2XY_CoeffY(self)
    __swig_destroy__ = _mm3d.delete_PolyDegre2XY
    __del__ = lambda self: None
PolyDegre2XY_swigregister = _mm3d.PolyDegre2XY_swigregister
PolyDegre2XY_swigregister(PolyDegre2XY)

class ElDistPolyDegre2(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistPolyDegre2, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistPolyDegre2, name)
    __repr__ = _swig_repr

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistPolyDegre2_Direct(self, arg2)

    def __init__(self, aPolX: 'PolyDegre2XY', aPolY: 'PolyDegre2XY', EpsilonInv: 'double'):
        this = _mm3d.new_ElDistPolyDegre2(aPolX, aPolY, EpsilonInv)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt2dr') -> "void":
        return _mm3d.ElDistPolyDegre2_Diff(self, arg2, arg3)
    __swig_destroy__ = _mm3d.delete_ElDistPolyDegre2
    __del__ = lambda self: None
ElDistPolyDegre2_swigregister = _mm3d.ElDistPolyDegre2_swigregister
ElDistPolyDegre2_swigregister(ElDistPolyDegre2)

class ElDistortionPolynomiale(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElDistortionPolynomiale, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElDistortionPolynomiale, name)
    __repr__ = _swig_repr
    if _newclass:
        DistId = staticmethod(_mm3d.ElDistortionPolynomiale_DistId)
    else:
        DistId = _mm3d.ElDistortionPolynomiale_DistId

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElDistortionPolynomiale_Direct(self, arg2)

    def DistX(self) -> "Polynome2dReal const &":
        return _mm3d.ElDistortionPolynomiale_DistX(self)

    def DistY(self) -> "Polynome2dReal const &":
        return _mm3d.ElDistortionPolynomiale_DistY(self)

    def FNum(self) -> "Fonc_Num":
        return _mm3d.ElDistortionPolynomiale_FNum(self)

    def __init__(self, *args):
        this = _mm3d.new_ElDistortionPolynomiale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt2dr') -> "void":
        return _mm3d.ElDistortionPolynomiale_Diff(self, arg2, arg3)

    def MapingChScale(self, aChSacle: 'double') -> "ElDistortionPolynomiale":
        return _mm3d.ElDistortionPolynomiale_MapingChScale(self, aChSacle)

    def D22G_ChScale(self, aS: 'double') -> "ElDistortion22_Gen *":
        return _mm3d.ElDistortionPolynomiale_D22G_ChScale(self, aS)
    __swig_destroy__ = _mm3d.delete_ElDistortionPolynomiale
    __del__ = lambda self: None
ElDistortionPolynomiale_swigregister = _mm3d.ElDistortionPolynomiale_swigregister
ElDistortionPolynomiale_swigregister(ElDistortionPolynomiale)

def ElDistortionPolynomiale_DistId(aDegre: 'int', anAmpl: 'double') -> "ElDistortionPolynomiale":
    return _mm3d.ElDistortionPolynomiale_DistId(aDegre, anAmpl)
ElDistortionPolynomiale_DistId = _mm3d.ElDistortionPolynomiale_DistId

class EpipolaireCoordinate(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EpipolaireCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EpipolaireCoordinate, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SaveOrientEpip(self, anOri: 'std::string const &', anICNM: 'cInterfChantierNameManipulateur *', aNameIm: 'std::string const &', aNameOther: 'std::string const &') -> "void":
        return _mm3d.EpipolaireCoordinate_SaveOrientEpip(self, anOri, anICNM, aNameIm, aNameOther)

    def TransOnLineEpip(self, aP: 'Pt2dr', aParal: 'double') -> "Pt2dr":
        return _mm3d.EpipolaireCoordinate_TransOnLineEpip(self, aP, aParal)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.EpipolaireCoordinate_Direct(self, arg2)

    def IsEpipId(self) -> "bool":
        return _mm3d.EpipolaireCoordinate_IsEpipId(self)

    def DirEpip(self, arg2: 'Pt2dr', anEpsilon: 'double') -> "Pt2dr":
        return _mm3d.EpipolaireCoordinate_DirEpip(self, arg2, anEpsilon)

    def P0(self) -> "Pt2dr":
        return _mm3d.EpipolaireCoordinate_P0(self)

    def DirX(self) -> "Pt2dr":
        return _mm3d.EpipolaireCoordinate_DirX(self)

    def TrFin(self) -> "Pt2dr":
        return _mm3d.EpipolaireCoordinate_TrFin(self)

    def CastToPol(self) -> "PolynomialEpipolaireCoordinate const *":
        return _mm3d.EpipolaireCoordinate_CastToPol(self)

    def MapingChScale(self, aChSacle: 'double') -> "EpipolaireCoordinate *":
        return _mm3d.EpipolaireCoordinate_MapingChScale(self, aChSacle)

    def HeriteChScale(self, arg2: 'EpipolaireCoordinate', aChSacle: 'double') -> "void":
        return _mm3d.EpipolaireCoordinate_HeriteChScale(self, arg2, aChSacle)

    def ImageOfBox(self, arg2: 'Box2dr') -> "Box2dr":
        return _mm3d.EpipolaireCoordinate_ImageOfBox(self, arg2)

    def AddTrFinale(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.EpipolaireCoordinate_AddTrFinale(self, arg2)

    def SetTrFinale(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.EpipolaireCoordinate_SetTrFinale(self, arg2)

    def SetGridCorrec(self, DeltaY: 'Fonc_Num', Pond: 'Fonc_Num', aStepGr: 'double', aBoxIm: 'Box2dr', aRatioMin: 'double'=0.2) -> "void":
        return _mm3d.EpipolaireCoordinate_SetGridCorrec(self, DeltaY, Pond, aStepGr, aBoxIm, aRatioMin)
    __swig_destroy__ = _mm3d.delete_EpipolaireCoordinate
    __del__ = lambda self: None
EpipolaireCoordinate_swigregister = _mm3d.EpipolaireCoordinate_swigregister
EpipolaireCoordinate_swigregister(EpipolaireCoordinate)

class EpipolaireCoordinateNoDist(EpipolaireCoordinate):
    __swig_setmethods__ = {}
    for _s in [EpipolaireCoordinate]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EpipolaireCoordinateNoDist, name, value)
    __swig_getmethods__ = {}
    for _s in [EpipolaireCoordinate]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EpipolaireCoordinateNoDist, name)
    __repr__ = _swig_repr

    def __init__(self, aP0: 'Pt2dr', aDirX: 'Pt2dr'):
        this = _mm3d.new_EpipolaireCoordinateNoDist(aP0, aDirX)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_EpipolaireCoordinateNoDist
    __del__ = lambda self: None
EpipolaireCoordinateNoDist_swigregister = _mm3d.EpipolaireCoordinateNoDist_swigregister
EpipolaireCoordinateNoDist_swigregister(EpipolaireCoordinateNoDist)

class cMappingEpipCoord(EpipolaireCoordinate):
    __swig_setmethods__ = {}
    for _s in [EpipolaireCoordinate]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cMappingEpipCoord, name, value)
    __swig_getmethods__ = {}
    for _s in [EpipolaireCoordinate]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cMappingEpipCoord, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'ElDistortion22_Gen', toDel: 'bool'):
        this = _mm3d.new_cMappingEpipCoord(arg2, toDel)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cMappingEpipCoord
    __del__ = lambda self: None
cMappingEpipCoord_swigregister = _mm3d.cMappingEpipCoord_swigregister
cMappingEpipCoord_swigregister(cMappingEpipCoord)

class PolynomialEpipolaireCoordinate(EpipolaireCoordinate):
    __swig_setmethods__ = {}
    for _s in [EpipolaireCoordinate]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolynomialEpipolaireCoordinate, name, value)
    __swig_getmethods__ = {}
    for _s in [EpipolaireCoordinate]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolynomialEpipolaireCoordinate, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_PolynomialEpipolaireCoordinate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def PolToYEpip(self) -> "Polynome2dReal":
        return _mm3d.PolynomialEpipolaireCoordinate_PolToYEpip(self)

    def PolToYInit(self) -> "Polynome2dReal":
        return _mm3d.PolynomialEpipolaireCoordinate_PolToYInit(self)

    def CastToPol(self) -> "PolynomialEpipolaireCoordinate const *":
        return _mm3d.PolynomialEpipolaireCoordinate_CastToPol(self)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.PolynomialEpipolaireCoordinate_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.PolynomialEpipolaireCoordinate_read)
    else:
        read = _mm3d.PolynomialEpipolaireCoordinate_read

    def MapingChScale(self, aChSacle: 'double') -> "EpipolaireCoordinate *":
        return _mm3d.PolynomialEpipolaireCoordinate_MapingChScale(self, aChSacle)

    def PolMapingChScale(self, aChSacle: 'double') -> "PolynomialEpipolaireCoordinate *":
        return _mm3d.PolynomialEpipolaireCoordinate_PolMapingChScale(self, aChSacle)
    __swig_destroy__ = _mm3d.delete_PolynomialEpipolaireCoordinate
    __del__ = lambda self: None
PolynomialEpipolaireCoordinate_swigregister = _mm3d.PolynomialEpipolaireCoordinate_swigregister
PolynomialEpipolaireCoordinate_swigregister(PolynomialEpipolaireCoordinate)

def PolynomialEpipolaireCoordinate_read(aFile: 'ELISE_fp &') -> "PolynomialEpipolaireCoordinate":
    return _mm3d.PolynomialEpipolaireCoordinate_read(aFile)
PolynomialEpipolaireCoordinate_read = _mm3d.PolynomialEpipolaireCoordinate_read

class CpleEpipolaireCoord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CpleEpipolaireCoord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CpleEpipolaireCoord, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SaveOrientCpleEpip(self, anOri: 'std::string const &', anICNM: 'cInterfChantierNameManipulateur *', aName1: 'std::string const &', aName2: 'std::string const &') -> "void":
        return _mm3d.CpleEpipolaireCoord_SaveOrientCpleEpip(self, anOri, anICNM, aName1, aName2)
    if _newclass:
        EpipolaireNoDist = staticmethod(_mm3d.CpleEpipolaireCoord_EpipolaireNoDist)
    else:
        EpipolaireNoDist = _mm3d.CpleEpipolaireCoord_EpipolaireNoDist
    if _newclass:
        PolynomialFromHomologue = staticmethod(_mm3d.CpleEpipolaireCoord_PolynomialFromHomologue)
    else:
        PolynomialFromHomologue = _mm3d.CpleEpipolaireCoord_PolynomialFromHomologue
    if _newclass:
        MappingEpipolaire = staticmethod(_mm3d.CpleEpipolaireCoord_MappingEpipolaire)
    else:
        MappingEpipolaire = _mm3d.CpleEpipolaireCoord_MappingEpipolaire
    if _newclass:
        MappEpiFromHomographie = staticmethod(_mm3d.CpleEpipolaireCoord_MappEpiFromHomographie)
    else:
        MappEpiFromHomographie = _mm3d.CpleEpipolaireCoord_MappEpiFromHomographie
    if _newclass:
        MappEpiFromHomographieAndDist = staticmethod(_mm3d.CpleEpipolaireCoord_MappEpiFromHomographieAndDist)
    else:
        MappEpiFromHomographieAndDist = _mm3d.CpleEpipolaireCoord_MappEpiFromHomographieAndDist
    if _newclass:
        OriEpipolaire = staticmethod(_mm3d.CpleEpipolaireCoord_OriEpipolaire)
    else:
        OriEpipolaire = _mm3d.CpleEpipolaireCoord_OriEpipolaire
    if _newclass:
        CamEpipolaire = staticmethod(_mm3d.CpleEpipolaireCoord_CamEpipolaire)
    else:
        CamEpipolaire = _mm3d.CpleEpipolaireCoord_CamEpipolaire
    __swig_destroy__ = _mm3d.delete_CpleEpipolaireCoord
    __del__ = lambda self: None

    def EPI1(self, *args) -> "EpipolaireCoordinate &":
        return _mm3d.CpleEpipolaireCoord_EPI1(self, *args)

    def EPI2(self, *args) -> "EpipolaireCoordinate &":
        return _mm3d.CpleEpipolaireCoord_EPI2(self, *args)

    def Hom21(self, *args) -> "Pt2dr":
        return _mm3d.CpleEpipolaireCoord_Hom21(self, *args)

    def Homol(self, arg2: 'Pt2dr', aParalaxe: 'Pt2dr', Sens12: 'bool') -> "Pt2dr":
        return _mm3d.CpleEpipolaireCoord_Homol(self, arg2, aParalaxe, Sens12)

    def Hom12(self, *args) -> "Pt2d< Fonc_Num >":
        return _mm3d.CpleEpipolaireCoord_Hom12(self, *args)

    def write(self, aFile: 'ELISE_fp &') -> "void":
        return _mm3d.CpleEpipolaireCoord_write(self, aFile)
    if _newclass:
        read = staticmethod(_mm3d.CpleEpipolaireCoord_read)
    else:
        read = _mm3d.CpleEpipolaireCoord_read

    def MapingChScale(self, aChSacle: 'double') -> "CpleEpipolaireCoord *":
        return _mm3d.CpleEpipolaireCoord_MapingChScale(self, aChSacle)

    def SelfSwap(self) -> "void":
        return _mm3d.CpleEpipolaireCoord_SelfSwap(self)

    def Swap(self) -> "CpleEpipolaireCoord *":
        return _mm3d.CpleEpipolaireCoord_Swap(self)

    def AdjustTr2Boxes(self, aBox1: 'Box2dr', aBox2: 'Box2dr') -> "void":
        return _mm3d.CpleEpipolaireCoord_AdjustTr2Boxes(self, aBox1, aBox2)

    def IsMappingEpi1(self) -> "bool":
        return _mm3d.CpleEpipolaireCoord_IsMappingEpi1(self)
CpleEpipolaireCoord_swigregister = _mm3d.CpleEpipolaireCoord_swigregister
CpleEpipolaireCoord_swigregister(CpleEpipolaireCoord)

def CpleEpipolaireCoord_EpipolaireNoDist(aPHom1: 'Pt2dr', aPHom2: 'Pt2dr', aDir1: 'Pt2dr', aDir2: 'Pt2dr') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_EpipolaireNoDist(aPHom1, aPHom2, aDir1, aDir2)
CpleEpipolaireCoord_EpipolaireNoDist = _mm3d.CpleEpipolaireCoord_EpipolaireNoDist

def CpleEpipolaireCoord_PolynomialFromHomologue(*args) -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_PolynomialFromHomologue(*args)
CpleEpipolaireCoord_PolynomialFromHomologue = _mm3d.CpleEpipolaireCoord_PolynomialFromHomologue

def CpleEpipolaireCoord_MappingEpipolaire(arg2: 'ElDistortion22_Gen', ToDel: 'bool') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_MappingEpipolaire(arg2, ToDel)
CpleEpipolaireCoord_MappingEpipolaire = _mm3d.CpleEpipolaireCoord_MappingEpipolaire

def CpleEpipolaireCoord_MappEpiFromHomographie(arg2: 'cElHomographie') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_MappEpiFromHomographie(arg2)
CpleEpipolaireCoord_MappEpiFromHomographie = _mm3d.CpleEpipolaireCoord_MappEpiFromHomographie

def CpleEpipolaireCoord_MappEpiFromHomographieAndDist(arg2: 'cElHomographie', arg3: 'ElDistRadiale_PolynImpair', aRayInv: 'double', aDeltaDegreInv: 'int') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_MappEpiFromHomographieAndDist(arg2, arg3, aRayInv, aDeltaDegreInv)
CpleEpipolaireCoord_MappEpiFromHomographieAndDist = _mm3d.CpleEpipolaireCoord_MappEpiFromHomographieAndDist

def CpleEpipolaireCoord_OriEpipolaire(aName1: 'std::string const &', aP1: 'Pt2dr', aName2: 'std::string const &', aP2: 'Pt2dr', aZoom: 'double') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_OriEpipolaire(aName1, aP1, aName2, aP2, aZoom)
CpleEpipolaireCoord_OriEpipolaire = _mm3d.CpleEpipolaireCoord_OriEpipolaire

def CpleEpipolaireCoord_CamEpipolaire(aCam1: 'CamStenope', aP1: 'Pt2dr', aCam2: 'CamStenope', aP2: 'Pt2dr', aZoom: 'double') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_CamEpipolaire(aCam1, aP1, aCam2, aP2, aZoom)
CpleEpipolaireCoord_CamEpipolaire = _mm3d.CpleEpipolaireCoord_CamEpipolaire

def CpleEpipolaireCoord_read(aFile: 'ELISE_fp &') -> "CpleEpipolaireCoord *":
    return _mm3d.CpleEpipolaireCoord_read(aFile)
CpleEpipolaireCoord_read = _mm3d.CpleEpipolaireCoord_read

eProjectionStenope = _mm3d.eProjectionStenope
eProjectionOrtho = _mm3d.eProjectionOrtho
class cCorrRefracAPost(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCorrRefracAPost, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cCorrRefracAPost, name)
    __repr__ = _swig_repr

    def CorrM2C(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cCorrRefracAPost_CorrM2C(self, arg2)

    def CorrC2M(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cCorrRefracAPost_CorrC2M(self, arg2)

    def __init__(self, arg2: 'cCorrectionRefractionAPosteriori const &'):
        this = _mm3d.new_cCorrRefracAPost(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CorrectRefrac(self, arg2: 'Pt3dr', aCoef: 'double') -> "Pt3dr":
        return _mm3d.cCorrRefracAPost_CorrectRefrac(self, arg2, aCoef)

    def ToXML(self) -> "cCorrectionRefractionAPosteriori const &":
        return _mm3d.cCorrRefracAPost_ToXML(self)
    __swig_destroy__ = _mm3d.delete_cCorrRefracAPost
    __del__ = lambda self: None
cCorrRefracAPost_swigregister = _mm3d.cCorrRefracAPost_swigregister
cCorrRefracAPost_swigregister(cCorrRefracAPost)

class cArgOptionalPIsVisibleInImage(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cArgOptionalPIsVisibleInImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cArgOptionalPIsVisibleInImage, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cArgOptionalPIsVisibleInImage()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["mOkBehind"] = _mm3d.cArgOptionalPIsVisibleInImage_mOkBehind_set
    __swig_getmethods__["mOkBehind"] = _mm3d.cArgOptionalPIsVisibleInImage_mOkBehind_get
    if _newclass:
        mOkBehind = _swig_property(_mm3d.cArgOptionalPIsVisibleInImage_mOkBehind_get, _mm3d.cArgOptionalPIsVisibleInImage_mOkBehind_set)
    __swig_setmethods__["mWhy"] = _mm3d.cArgOptionalPIsVisibleInImage_mWhy_set
    __swig_getmethods__["mWhy"] = _mm3d.cArgOptionalPIsVisibleInImage_mWhy_get
    if _newclass:
        mWhy = _swig_property(_mm3d.cArgOptionalPIsVisibleInImage_mWhy_get, _mm3d.cArgOptionalPIsVisibleInImage_mWhy_set)
    __swig_destroy__ = _mm3d.delete_cArgOptionalPIsVisibleInImage
    __del__ = lambda self: None
cArgOptionalPIsVisibleInImage_swigregister = _mm3d.cArgOptionalPIsVisibleInImage_swigregister
cArgOptionalPIsVisibleInImage_swigregister(cArgOptionalPIsVisibleInImage)

class cBasicGeomCap3D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cBasicGeomCap3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cBasicGeomCap3D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Capteur2RayTer(self, aP: 'Pt2dr') -> "ElSeg3D":
        return _mm3d.cBasicGeomCap3D_Capteur2RayTer(self, aP)

    def Ter2Capteur(self, aP: 'Pt3dr') -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_Ter2Capteur(self, aP)

    def SzBasicCapt3D(self) -> "Pt2di":
        return _mm3d.cBasicGeomCap3D_SzBasicCapt3D(self)

    def SzPixel(self) -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_SzPixel(self)

    def ResolSolOfPt(self, arg2: 'Pt3dr') -> "double":
        return _mm3d.cBasicGeomCap3D_ResolSolOfPt(self, arg2)

    def CaptHasData(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cBasicGeomCap3D_CaptHasData(self, arg2)

    def CaptHasDataGeom(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cBasicGeomCap3D_CaptHasDataGeom(self, arg2)

    def PIsVisibleInImage(self, aP: 'Pt3dr', arg3: 'cArgOptionalPIsVisibleInImage'=None) -> "bool":
        return _mm3d.cBasicGeomCap3D_PIsVisibleInImage(self, aP, arg3)

    def RoughCapteur2Terrain(self, aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_RoughCapteur2Terrain(self, aP)

    def HasOpticalCenterOfPixel(self) -> "bool":
        return _mm3d.cBasicGeomCap3D_HasOpticalCenterOfPixel(self)

    def OpticalCenterOfPixel(self, aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_OpticalCenterOfPixel(self, aP)

    def OrigineProf(self) -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_OrigineProf(self)

    def ImEtProf2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_ImEtProf2Terrain(self, aP, aZ)

    def ImEtZ2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_ImEtZ2Terrain(self, aP, aZ)

    def Diff(self, aDx: 'Pt2dr', aDy: 'Pt2dr', aDz: 'Pt2dr', aPIm: 'Pt2dr', aTer: 'Pt3dr') -> "void":
        return _mm3d.cBasicGeomCap3D_Diff(self, aDx, aDy, aDz, aPIm, aTer)
    if _newclass:
        StdGetFromFile = staticmethod(_mm3d.cBasicGeomCap3D_StdGetFromFile)
    else:
        StdGetFromFile = _mm3d.cBasicGeomCap3D_StdGetFromFile

    def DownCastCS(self) -> "CamStenope *":
        return _mm3d.cBasicGeomCap3D_DownCastCS(self)

    def DirRayonR3(self, aPIm: 'Pt2dr') -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_DirRayonR3(self, aPIm)

    def ProfondeurDeChamps(self, aP: 'Pt3dr') -> "double":
        return _mm3d.cBasicGeomCap3D_ProfondeurDeChamps(self, aP)

    def DirVisee(self) -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_DirVisee(self)

    def EpipolarEcart(self, aP1: 'Pt2dr', aCam2: 'cBasicGeomCap3D', aP2: 'Pt2dr', SauvDir: 'Pt2dr'=None) -> "double":
        return _mm3d.cBasicGeomCap3D_EpipolarEcart(self, aP1, aCam2, aP2, SauvDir)

    def ResolutionAngulaire(self) -> "double":
        return _mm3d.cBasicGeomCap3D_ResolutionAngulaire(self)

    def GetCenterAndPTerOnBundle(self, aC: 'Pt3dr', aPTer: 'Pt3dr', aPIm: 'Pt2dr') -> "void":
        return _mm3d.cBasicGeomCap3D_GetCenterAndPTerOnBundle(self, aC, aPTer, aPIm)

    def GetVeryRoughInterProf(self) -> "double":
        return _mm3d.cBasicGeomCap3D_GetVeryRoughInterProf(self)

    def GetAltiSol(self) -> "double":
        return _mm3d.cBasicGeomCap3D_GetAltiSol(self)

    def GetAltiSolMinMax(self) -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_GetAltiSolMinMax(self)

    def AltisSolIsDef(self) -> "bool":
        return _mm3d.cBasicGeomCap3D_AltisSolIsDef(self)

    def AltisSolMinMaxIsDef(self) -> "bool":
        return _mm3d.cBasicGeomCap3D_AltisSolMinMaxIsDef(self)

    def IsRPC(self) -> "bool":
        return _mm3d.cBasicGeomCap3D_IsRPC(self)

    def Save2XmlStdMMName(self, *args) -> "std::string":
        return _mm3d.cBasicGeomCap3D_Save2XmlStdMMName(self, *args)

    def Mil(self) -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_Mil(self)

    def GlobResol(self) -> "double":
        return _mm3d.cBasicGeomCap3D_GlobResol(self)

    def PMoyOfCenter(self) -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_PMoyOfCenter(self)

    def HasRoughCapteur2Terrain(self) -> "bool":
        return _mm3d.cBasicGeomCap3D_HasRoughCapteur2Terrain(self)

    def ImRef2Capteur(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_ImRef2Capteur(self, aP)

    def ResolImRefFromCapteur(self) -> "double":
        return _mm3d.cBasicGeomCap3D_ResolImRefFromCapteur(self)

    def HasPreciseCapteur2Terrain(self) -> "bool":
        return _mm3d.cBasicGeomCap3D_HasPreciseCapteur2Terrain(self)

    def PreciseCapteur2Terrain(self, aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.cBasicGeomCap3D_PreciseCapteur2Terrain(self, aP)

    def SetScanImaM2C(self, arg2: 'ElAffin2D') -> "void":
        return _mm3d.cBasicGeomCap3D_SetScanImaM2C(self, arg2)

    def SetScanImaC2M(self, arg2: 'ElAffin2D') -> "void":
        return _mm3d.cBasicGeomCap3D_SetScanImaC2M(self, arg2)

    def SetIntrImaM2C(self, arg2: 'ElAffin2D') -> "void":
        return _mm3d.cBasicGeomCap3D_SetIntrImaM2C(self, arg2)

    def SetIntrImaC2M(self, arg2: 'ElAffin2D') -> "void":
        return _mm3d.cBasicGeomCap3D_SetIntrImaC2M(self, arg2)

    def OrGlbImaM2C(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_OrGlbImaM2C(self, arg2)

    def OrGlbImaC2M(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_OrGlbImaC2M(self, arg2)

    def OrScanImaM2C(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_OrScanImaM2C(self, arg2)

    def OrIntrImaC2M(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cBasicGeomCap3D_OrIntrImaC2M(self, arg2)

    def ReCalcGlbOrInt(self) -> "void":
        return _mm3d.cBasicGeomCap3D_ReCalcGlbOrInt(self)
    __swig_destroy__ = _mm3d.delete_cBasicGeomCap3D
    __del__ = lambda self: None
cBasicGeomCap3D_swigregister = _mm3d.cBasicGeomCap3D_swigregister
cBasicGeomCap3D_swigregister(cBasicGeomCap3D)

def cBasicGeomCap3D_StdGetFromFile(arg1: 'std::string const &', aType: 'int &', aChSys: 'cSystemeCoord const *'=None) -> "cBasicGeomCap3D *":
    return _mm3d.cBasicGeomCap3D_StdGetFromFile(arg1, aType, aChSys)
cBasicGeomCap3D_StdGetFromFile = _mm3d.cBasicGeomCap3D_StdGetFromFile


def DeformCameraAffine(aXmlApInit2Cur: 'cAffinitePlane const &', aCam0: 'cBasicGeomCap3D', aName: 'std::string const &', aNameIma: 'std::string const &') -> "cBasicGeomCap3D *":
    return _mm3d.DeformCameraAffine(aXmlApInit2Cur, aCam0, aName, aNameIma)
DeformCameraAffine = _mm3d.DeformCameraAffine
class cCapture3D(cBasicGeomCap3D):
    __swig_setmethods__ = {}
    for _s in [cBasicGeomCap3D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCapture3D, name, value)
    __swig_getmethods__ = {}
    for _s in [cBasicGeomCap3D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCapture3D, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def ResolSolGlob(self) -> "double":
        return _mm3d.cCapture3D_ResolSolGlob(self)
    __swig_destroy__ = _mm3d.delete_cCapture3D
    __del__ = lambda self: None
cCapture3D_swigregister = _mm3d.cCapture3D_swigregister
cCapture3D_swigregister(cCapture3D)

class ElCamera(cCapture3D):
    __swig_setmethods__ = {}
    for _s in [cCapture3D]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElCamera, name, value)
    __swig_getmethods__ = {}
    for _s in [cCapture3D]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ElCamera, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def IsScanned(self) -> "bool const &":
        return _mm3d.ElCamera_IsScanned(self)

    def SetScanned(self, mIsSC: 'bool') -> "void":
        return _mm3d.ElCamera_SetScanned(self, mIsSC)

    def DirRayonR3(self, aPIm: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_DirRayonR3(self, aPIm)

    def SzBasicCapt3D(self) -> "Pt2di":
        return _mm3d.ElCamera_SzBasicCapt3D(self)

    def GetVeryRoughInterProf(self) -> "double":
        return _mm3d.ElCamera_GetVeryRoughInterProf(self)

    def CaptHasData(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.ElCamera_CaptHasData(self, arg2)

    def Ter2Capteur(self, aP: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElCamera_Ter2Capteur(self, aP)

    def PIsVisibleInImage(self, aP: 'Pt3dr', arg3: 'cArgOptionalPIsVisibleInImage'=None) -> "bool":
        return _mm3d.ElCamera_PIsVisibleInImage(self, aP, arg3)

    def Capteur2RayTer(self, aP: 'Pt2dr') -> "ElSeg3D":
        return _mm3d.ElCamera_Capteur2RayTer(self, aP)

    def ResolImRefFromCapteur(self) -> "double":
        return _mm3d.ElCamera_ResolImRefFromCapteur(self)

    def HasRoughCapteur2Terrain(self) -> "bool":
        return _mm3d.ElCamera_HasRoughCapteur2Terrain(self)

    def ImRef2Capteur(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_ImRef2Capteur(self, aP)

    def HasPreciseCapteur2Terrain(self) -> "bool":
        return _mm3d.ElCamera_HasPreciseCapteur2Terrain(self)

    def RoughCapteur2Terrain(self, aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_RoughCapteur2Terrain(self, aP)

    def PreciseCapteur2Terrain(self, aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_PreciseCapteur2Terrain(self, aP)

    def ResolSolOfPt(self, arg2: 'Pt3dr') -> "double":
        return _mm3d.ElCamera_ResolSolOfPt(self, arg2)

    def ResolSolGlob(self) -> "double":
        return _mm3d.ElCamera_ResolSolGlob(self)

    def ScaleAfnt(self) -> "double":
        return _mm3d.ElCamera_ScaleAfnt(self)

    def Vitesse(self) -> "Pt3dr":
        return _mm3d.ElCamera_Vitesse(self)

    def SetVitesse(self, arg2: 'Pt3dr') -> "void":
        return _mm3d.ElCamera_SetVitesse(self, arg2)

    def VitesseIsInit(self) -> "bool":
        return _mm3d.ElCamera_VitesseIsInit(self)

    def IncCentre(self) -> "Pt3dr":
        return _mm3d.ElCamera_IncCentre(self)

    def SetIncCentre(self, arg2: 'Pt3dr') -> "void":
        return _mm3d.ElCamera_SetIncCentre(self, arg2)

    def TestCam(self, aMes: 'std::string const &') -> "void":
        return _mm3d.ElCamera_TestCam(self, aMes)

    def GetTime(self) -> "double const &":
        return _mm3d.ElCamera_GetTime(self)

    def SetTime(self, arg2: 'double const &') -> "void":
        return _mm3d.ElCamera_SetTime(self, arg2)

    def ExportCalibGlob(self, aSzIm: 'Pt2di', AltiSol: 'double', Prof: 'double', AddVerif: 'int', ModMatr: 'bool', aNameAux: 'char const *', aNbVeridDet: 'Pt3di const *'=None) -> "cOrientationConique":
        return _mm3d.ElCamera_ExportCalibGlob(self, aSzIm, AltiSol, Prof, AddVerif, ModMatr, aNameAux, aNbVeridDet)

    def ExportCalibInterne2XmlStruct(self, aSzIm: 'Pt2di') -> "cCalibrationInternConique":
        return _mm3d.ElCamera_ExportCalibInterne2XmlStruct(self, aSzIm)

    def MakeVerif(self, aNbVerif: 'int', aProf: 'double', arg4: 'char const *', aNbDeterm: 'Pt3di const *'=None) -> "cVerifOrient":
        return _mm3d.ElCamera_MakeVerif(self, aNbVerif, aProf, arg4, aNbDeterm)

    def StdExportCalibGlob(self, *args) -> "cOrientationConique":
        return _mm3d.ElCamera_StdExportCalibGlob(self, *args)

    def StdExport2File(self, *args) -> "std::string":
        return _mm3d.ElCamera_StdExport2File(self, *args)

    def ImEtProf2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.ElCamera_ImEtProf2Terrain(self, aP, aZ)

    def NoDistImEtProf2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.ElCamera_NoDistImEtProf2Terrain(self, aP, aZ)

    def SetAltiSol(self, arg2: 'double') -> "void":
        return _mm3d.ElCamera_SetAltiSol(self, arg2)

    def SetProfondeur(self, arg2: 'double') -> "void":
        return _mm3d.ElCamera_SetProfondeur(self, arg2)
    if _newclass:
        ChangeSys = staticmethod(_mm3d.ElCamera_ChangeSys)
    else:
        ChangeSys = _mm3d.ElCamera_ChangeSys

    def SzDiffFinie(self) -> "double":
        return _mm3d.ElCamera_SzDiffFinie(self)

    def DirVisee(self) -> "Pt3dr":
        return _mm3d.ElCamera_DirVisee(self)

    def ProfondeurDeChamps(self, aP: 'Pt3dr') -> "double":
        return _mm3d.ElCamera_ProfondeurDeChamps(self, aP)

    def ResolutionSol(self, *args) -> "double":
        return _mm3d.ElCamera_ResolutionSol(self, *args)

    def GetAltiSol(self) -> "double":
        return _mm3d.ElCamera_GetAltiSol(self)

    def AltisSolIsDef(self) -> "bool":
        return _mm3d.ElCamera_AltisSolIsDef(self)

    def UndefAltisSol(self) -> "void":
        return _mm3d.ElCamera_UndefAltisSol(self)

    def GetProfondeur(self) -> "double":
        return _mm3d.ElCamera_GetProfondeur(self)

    def GetRoughProfondeur(self) -> "double":
        return _mm3d.ElCamera_GetRoughProfondeur(self)

    def ProfIsDef(self) -> "bool":
        return _mm3d.ElCamera_ProfIsDef(self)

    def GetTypeProj(self) -> "eTypeProj":
        return _mm3d.ElCamera_GetTypeProj(self)

    def CS(self, *args) -> "CamStenope const *":
        return _mm3d.ElCamera_CS(self, *args)

    def CSBil_SVP(self) -> "cCamStenopeBilin *":
        return _mm3d.ElCamera_CSBil_SVP(self)

    def CSBil(self) -> "cCamStenopeBilin *":
        return _mm3d.ElCamera_CSBil(self)

    def RatioInterSol(self, arg2: 'ElCamera') -> "double":
        return _mm3d.ElCamera_RatioInterSol(self, arg2)

    def EcartAngulaire(self, *args) -> "double":
        return _mm3d.ElCamera_EcartAngulaire(self, *args)

    def SomEcartAngulaire(self, *args) -> "double":
        return _mm3d.ElCamera_SomEcartAngulaire(self, *args)

    def IdentCam(self) -> "std::string const &":
        return _mm3d.ElCamera_IdentCam(self)

    def SetIdentCam(self, aName: 'std::string const &') -> "void":
        return _mm3d.ElCamera_SetIdentCam(self, aName)

    def NameIm(self) -> "std::string const &":
        return _mm3d.ElCamera_NameIm(self)

    def SetNameIm(self, aName: 'std::string const &') -> "void":
        return _mm3d.ElCamera_SetNameIm(self, aName)

    def Orient(self, *args) -> "ElRotation3D const &":
        return _mm3d.ElCamera_Orient(self, *args)

    def SetOrientation(self, arg2: 'ElRotation3D') -> "void":
        return _mm3d.ElCamera_SetOrientation(self, arg2)

    def AddToCenterOptical(self, aOffsetC: 'Pt3dr') -> "void":
        return _mm3d.ElCamera_AddToCenterOptical(self, aOffsetC)

    def MultiToRotation(self, aOffsetR: 'ElMatrixr') -> "void":
        return _mm3d.ElCamera_MultiToRotation(self, aOffsetR)

    def PseudoInter(self, aPF2A: 'Pt2dr', CamB: 'ElCamera', aPF2B: 'Pt2dr', aD: 'double *'=None) -> "Pt3dr":
        return _mm3d.ElCamera_PseudoInter(self, aPF2A, CamB, aPF2B, aD)

    def PseudoInterPixPrec(self, aPF2A: 'Pt2dr', CamB: 'ElCamera', aPF2B: 'Pt2dr', aD: 'double &') -> "Pt3dr":
        return _mm3d.ElCamera_PseudoInterPixPrec(self, aPF2A, CamB, aPF2B, aD)

    def CdgPseudoInter(self, arg2: 'ElPackHomologue', CamB: 'ElCamera', aD: 'double &') -> "Pt3dr":
        return _mm3d.ElCamera_CdgPseudoInter(self, arg2, CamB, aD)

    def EcartProj(self, *args) -> "double":
        return _mm3d.ElCamera_EcartProj(self, *args)

    def ScaleCamNorm(self) -> "double":
        return _mm3d.ElCamera_ScaleCamNorm(self)

    def TrCamNorm(self) -> "Pt2dr":
        return _mm3d.ElCamera_TrCamNorm(self)

    def R3toF2(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElCamera_R3toF2(self, arg2)

    def R3toC2(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElCamera_R3toC2(self, arg2)

    def R3toL3(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.ElCamera_R3toL3(self, arg2)

    def L3toR3(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.ElCamera_L3toR3(self, arg2)

    def DirK(self) -> "Pt3dr":
        return _mm3d.ElCamera_DirK(self)

    def F2AndZtoR3(self, aPIm: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.ElCamera_F2AndZtoR3(self, aPIm, aZ)

    def F2toC2(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_F2toC2(self, arg2)

    def F2toRayonL3(self, arg2: 'Pt2dr', aP0: 'Pt3dr', aP1: 'Pt3dr') -> "void":
        return _mm3d.ElCamera_F2toRayonL3(self, arg2, aP0, aP1)

    def PtFromPlanAndIm(self, aPlan: 'cElPlan3D const &', aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_PtFromPlanAndIm(self, aPlan, aP)

    def F2toRayonR3(self, *args) -> "ElSeg3D":
        return _mm3d.ElCamera_F2toRayonR3(self, *args)

    def F2toDirRayonL3(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_F2toDirRayonL3(self, arg2)

    def F2toDirRayonR3(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_F2toDirRayonR3(self, arg2)

    def C2toDirRayonR3(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_C2toDirRayonR3(self, arg2)

    def L3toF2(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElCamera_L3toF2(self, arg2)

    def PtDirRayonL3toF2(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_PtDirRayonL3toF2(self, arg2)

    def Pixel2Radian(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_Pixel2Radian(self, aP)

    def Radian2Pixel(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_Radian2Pixel(self, aP)

    def C2toDirRayonL3(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.ElCamera_C2toDirRayonL3(self, arg2)

    def L3toC2(self, arg2: 'Pt3dr') -> "Pt2dr":
        return _mm3d.ElCamera_L3toC2(self, arg2)

    def F2toPtDirRayonL3(self, *args) -> "std::list< Appar23,std::allocator< Appar23 > >":
        return _mm3d.ElCamera_F2toPtDirRayonL3(self, *args)

    def Devant(self, arg2: 'Pt3dr') -> "bool":
        return _mm3d.ElCamera_Devant(self, arg2)

    def TousDevant(self, arg2: 'std::list< Pt3dr,std::allocator< Pt3dr > > const &') -> "bool":
        return _mm3d.ElCamera_TousDevant(self, arg2)

    def EcProj(self, *args) -> "double":
        return _mm3d.ElCamera_EcProj(self, *args)

    def DiffR3F2(self, *args) -> "ElMatrix< double >":
        return _mm3d.ElCamera_DiffR3F2(self, *args)

    def DiffR3F2Param(self, *args) -> "ElMatrix< double >":
        return _mm3d.ElCamera_DiffR3F2Param(self, *args)

    def DistIsDirecte(self) -> "bool":
        return _mm3d.ElCamera_DistIsDirecte(self)

    def DistIsC2M(self) -> "bool":
        return _mm3d.ElCamera_DistIsC2M(self)

    def DistDirecte(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_DistDirecte(self, aP)

    def DistInverse(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_DistInverse(self, aP)

    def DistDirecteSsComplem(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_DistDirecteSsComplem(self, aP)

    def DistInverseSsComplem(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_DistInverseSsComplem(self, aP)

    def Sz(self) -> "Pt2di const &":
        return _mm3d.ElCamera_Sz(self)

    def SzPixel(self) -> "Pt2dr":
        return _mm3d.ElCamera_SzPixel(self)

    def SzPixelBasik(self) -> "Pt2dr":
        return _mm3d.ElCamera_SzPixelBasik(self)

    def SetSzPixel(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.ElCamera_SetSzPixel(self, arg2)

    def SetSz(self, aSz: 'Pt2di', AcceptInitMult: 'bool'=False) -> "void":
        return _mm3d.ElCamera_SetSz(self, aSz, AcceptInitMult)

    def SzIsInit(self) -> "bool":
        return _mm3d.ElCamera_SzIsInit(self)

    def SetParamGrid(self, arg2: 'cParamForGrid const &') -> "void":
        return _mm3d.ElCamera_SetParamGrid(self, arg2)

    def SetRayonUtile(self, aRay: 'double', aNbDisc: 'int') -> "void":
        return _mm3d.ElCamera_SetRayonUtile(self, aRay, aNbDisc)

    def BoxUtile(self) -> "Box2dr":
        return _mm3d.ElCamera_BoxUtile(self)

    def HeritComplAndSz(self, arg2: 'ElCamera') -> "void":
        return _mm3d.ElCamera_HeritComplAndSz(self, arg2)

    def CamHeritGen(self, arg2: 'ElCamera', WithCompl: 'bool', WithOrientInterne: 'bool'=True) -> "void":
        return _mm3d.ElCamera_CamHeritGen(self, arg2, WithCompl, WithOrientInterne)

    def AddCorrecRefrac(self, arg2: 'cCorrRefracAPost') -> "void":
        return _mm3d.ElCamera_AddCorrecRefrac(self, arg2)

    def AddDistCompl(self, *args) -> "void":
        return _mm3d.ElCamera_AddDistCompl(self, *args)

    def DComplC2M(self, arg2: 'Pt2dr', UseTrScN: 'bool'=True) -> "Pt2dr":
        return _mm3d.ElCamera_DComplC2M(self, arg2, UseTrScN)

    def DComplM2C(self, arg2: 'Pt2dr', UseTrScN: 'bool'=True) -> "Pt2dr":
        return _mm3d.ElCamera_DComplM2C(self, arg2, UseTrScN)

    def NormC2M(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_NormC2M(self, aP)

    def NormM2C(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_NormM2C(self, aP)

    def Get_dist(self, *args) -> "ElDistortion22_Gen const &":
        return _mm3d.ElCamera_Get_dist(self, *args)

    def DistCompl(self) -> "std::vector< ElDistortion22_Gen *,std::allocator< ElDistortion22_Gen * > > const &":
        return _mm3d.ElCamera_DistCompl(self)

    def DistComplIsDir(self) -> "std::vector< bool,std::allocator< bool > > const &":
        return _mm3d.ElCamera_DistComplIsDir(self)

    def ContourUtile(self) -> "std::vector< Pt2dr,std::allocator< Pt2dr > > const &":
        return _mm3d.ElCamera_ContourUtile(self)

    def HasRayonUtile(self) -> "bool":
        return _mm3d.ElCamera_HasRayonUtile(self)

    def IsInZoneUtile(self, aP: 'Pt2dr', Pixel: 'bool'=False) -> "bool":
        return _mm3d.ElCamera_IsInZoneUtile(self, aP, Pixel)

    def GetZoneUtilInPixel(self) -> "bool":
        return _mm3d.ElCamera_GetZoneUtilInPixel(self)

    def RayonUtile(self) -> "double":
        return _mm3d.ElCamera_RayonUtile(self)

    def HasDomaineSpecial(self) -> "bool":
        return _mm3d.ElCamera_HasDomaineSpecial(self)

    def DistPreCond(self) -> "ElDistortion22_Gen *":
        return _mm3d.ElCamera_DistPreCond(self)

    def StaticDistPreCond(self) -> "ElDistortion22_Gen *":
        return _mm3d.ElCamera_StaticDistPreCond(self)

    def IsForteDist(self) -> "bool":
        return _mm3d.ElCamera_IsForteDist(self)

    def IsGrid(self) -> "bool":
        return _mm3d.ElCamera_IsGrid(self)
    __swig_destroy__ = _mm3d.delete_ElCamera
    __del__ = lambda self: None

    def OrigineProf(self) -> "Pt3dr":
        return _mm3d.ElCamera_OrigineProf(self)

    def HasOrigineProf(self) -> "bool":
        return _mm3d.ElCamera_HasOrigineProf(self)

    def EmpriseSol(self) -> "cElPolygone const &":
        return _mm3d.ElCamera_EmpriseSol(self)

    def BoxSol(self) -> "Box2dr const &":
        return _mm3d.ElCamera_BoxSol(self)

    def IntrOrImaC2M(self) -> "cBasicGeomCap3D::tOrIntIma const &":
        return _mm3d.ElCamera_IntrOrImaC2M(self)

    def ResiduMond2Cam(self, aRes: 'Pt2dr') -> "Pt2dr":
        return _mm3d.ElCamera_ResiduMond2Cam(self, aRes)

    def InhibeScaneOri(self) -> "cBasicGeomCap3D::tOrIntIma":
        return _mm3d.ElCamera_InhibeScaneOri(self)

    def RestoreScaneOri(self, arg2: 'ElAffin2D') -> "void":
        return _mm3d.ElCamera_RestoreScaneOri(self, arg2)

    def Dist(self) -> "ElDistortion22_Gen &":
        return _mm3d.ElCamera_Dist(self)
ElCamera_swigregister = _mm3d.ElCamera_swigregister
ElCamera_swigregister(ElCamera)

def ElCamera_ChangeSys(arg2: 'std::vector< ElCamera *,std::allocator< ElCamera * > > const &', aTr3D: 'cTransfo3D', ForceRot: 'bool', AtGroundLevel: 'bool') -> "void":
    return _mm3d.ElCamera_ChangeSys(arg2, aTr3D, ForceRot, AtGroundLevel)
ElCamera_ChangeSys = _mm3d.ElCamera_ChangeSys
ElCamera.TheSzUndef = _mm3d.cvar.ElCamera_TheSzUndef

class cCameraOrtho(ElCamera):
    __swig_setmethods__ = {}
    for _s in [ElCamera]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCameraOrtho, name, value)
    __swig_getmethods__ = {}
    for _s in [ElCamera]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCameraOrtho, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        Alloc = staticmethod(_mm3d.cCameraOrtho_Alloc)
    else:
        Alloc = _mm3d.cCameraOrtho_Alloc

    def OrigineProf(self) -> "Pt3dr":
        return _mm3d.cCameraOrtho_OrigineProf(self)

    def HasOrigineProf(self) -> "bool":
        return _mm3d.cCameraOrtho_HasOrigineProf(self)

    def ResolutionSol(self, *args) -> "double":
        return _mm3d.cCameraOrtho_ResolutionSol(self, *args)

    def HasOpticalCenterOfPixel(self) -> "bool":
        return _mm3d.cCameraOrtho_HasOpticalCenterOfPixel(self)
    __swig_destroy__ = _mm3d.delete_cCameraOrtho
    __del__ = lambda self: None
cCameraOrtho_swigregister = _mm3d.cCameraOrtho_swigregister
cCameraOrtho_swigregister(cCameraOrtho)

def cCameraOrtho_Alloc(aSz: 'Pt2di') -> "cCameraOrtho *":
    return _mm3d.cCameraOrtho_Alloc(aSz)
cCameraOrtho_Alloc = _mm3d.cCameraOrtho_Alloc

class cDistPrecondRadial(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistPrecondRadial, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistPrecondRadial, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetAsPreCond(self) -> "cPreCondGrid":
        return _mm3d.cDistPrecondRadial_GetAsPreCond(self)

    def DirectAndDer(self, aP: 'Pt2dr', aGradX: 'Pt2dr', aGradY: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistPrecondRadial_DirectAndDer(self, aP, aGradX, aGradY)
    __swig_destroy__ = _mm3d.delete_cDistPrecondRadial
    __del__ = lambda self: None
cDistPrecondRadial_swigregister = _mm3d.cDistPrecondRadial_swigregister
cDistPrecondRadial_swigregister(cDistPrecondRadial)

class cDistPrecondAtgt(cDistPrecondRadial):
    __swig_setmethods__ = {}
    for _s in [cDistPrecondRadial]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistPrecondAtgt, name, value)
    __swig_getmethods__ = {}
    for _s in [cDistPrecondRadial]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistPrecondAtgt, name)
    __repr__ = _swig_repr

    def __init__(self, aFocApriori: 'double', aCentre: 'Pt2dr'):
        this = _mm3d.new_cDistPrecondAtgt(aFocApriori, aCentre)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cDistPrecondAtgt
    __del__ = lambda self: None
cDistPrecondAtgt_swigregister = _mm3d.cDistPrecondAtgt_swigregister
cDistPrecondAtgt_swigregister(cDistPrecondAtgt)

class cDistPrecond2SinAtgtS2(cDistPrecondRadial):
    __swig_setmethods__ = {}
    for _s in [cDistPrecondRadial]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistPrecond2SinAtgtS2, name, value)
    __swig_getmethods__ = {}
    for _s in [cDistPrecondRadial]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistPrecond2SinAtgtS2, name)
    __repr__ = _swig_repr

    def __init__(self, aFocApriori: 'double', aCentre: 'Pt2dr'):
        this = _mm3d.new_cDistPrecond2SinAtgtS2(aFocApriori, aCentre)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cDistPrecond2SinAtgtS2
    __del__ = lambda self: None
cDistPrecond2SinAtgtS2_swigregister = _mm3d.cDistPrecond2SinAtgtS2_swigregister
cDistPrecond2SinAtgtS2_swigregister(cDistPrecond2SinAtgtS2)

class cDistPrecondSterographique(cDistPrecondRadial):
    __swig_setmethods__ = {}
    for _s in [cDistPrecondRadial]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistPrecondSterographique, name, value)
    __swig_getmethods__ = {}
    for _s in [cDistPrecondRadial]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistPrecondSterographique, name)
    __repr__ = _swig_repr

    def __init__(self, aFocApriori: 'double', aCentre: 'Pt2dr'):
        this = _mm3d.new_cDistPrecondSterographique(aFocApriori, aCentre)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cDistPrecondSterographique
    __del__ = lambda self: None
cDistPrecondSterographique_swigregister = _mm3d.cDistPrecondSterographique_swigregister
cDistPrecondSterographique_swigregister(cDistPrecondSterographique)

class cElDistFromCam(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElDistFromCam, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cElDistFromCam, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'ElCamera', UseRayUtile: 'bool'):
        this = _mm3d.new_cElDistFromCam(arg2, UseRayUtile)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cElDistFromCam_Direct(self, arg2)

    def OwnInverse(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cElDistFromCam_OwnInverse(self, arg2)
    __swig_getmethods__["mCam"] = _mm3d.cElDistFromCam_mCam_get
    if _newclass:
        mCam = _swig_property(_mm3d.cElDistFromCam_mCam_get)

    def Diff(self, aMat: 'ElMatrixr', aP: 'Pt2dr') -> "void":
        return _mm3d.cElDistFromCam_Diff(self, aMat, aP)
    __swig_destroy__ = _mm3d.delete_cElDistFromCam
    __del__ = lambda self: None
cElDistFromCam_swigregister = _mm3d.cElDistFromCam_swigregister
cElDistFromCam_swigregister(cElDistFromCam)

class CamStenope(ElCamera):
    __swig_setmethods__ = {}
    for _s in [ElCamera]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CamStenope, name, value)
    __swig_getmethods__ = {}
    for _s in [ElCamera]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CamStenope, name)
    __repr__ = _swig_repr

    def DownCastCS(self) -> "CamStenope *":
        return _mm3d.CamStenope_DownCastCS(self)

    def Save2XmlStdMMName(self, anICNM: 'cInterfChantierNameManipulateur *', aOriOut: 'std::string const &', aNameImClip: 'std::string const &', anOrIntInit2Cur: 'ElAffin2D') -> "std::string":
        return _mm3d.CamStenope_Save2XmlStdMMName(self, anICNM, aOriOut, aNameImClip, anOrIntInit2Cur)

    def GetRoughProfondeur(self) -> "double":
        return _mm3d.CamStenope_GetRoughProfondeur(self)

    def ParamAF(self) -> "tParamAFocal const &":
        return _mm3d.CamStenope_ParamAF(self)

    def StdNormalise(self, *args) -> "void":
        return _mm3d.CamStenope_StdNormalise(self, *args)

    def UnNormalize(self) -> "void":
        return _mm3d.CamStenope_UnNormalize(self)
    if _newclass:
        StdCamFromFile = staticmethod(_mm3d.CamStenope_StdCamFromFile)
    else:
        StdCamFromFile = _mm3d.CamStenope_StdCamFromFile

    def Debug_CSDRP(self) -> "cCamStenopeDistRadPol const *":
        return _mm3d.CamStenope_Debug_CSDRP(self)

    def __init__(self, *args):
        this = _mm3d.new_CamStenope(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CanExportDistAsGrid(self) -> "bool":
        return _mm3d.CamStenope_CanExportDistAsGrid(self)

    def OrientFromPtsAppui(self, *args) -> "ElRotation3D":
        return _mm3d.CamStenope_OrientFromPtsAppui(self, *args)

    def CombinatoireOFPAGen(self, TousDevant: 'bool', NbTest: 'int', PR3: 'std::list< Pt3dr,std::allocator< Pt3dr > > const &', PF2: 'std::list< Pt2dr,std::allocator< Pt2dr > > const &', Res_Dmin: 'double *', ModeRansac: 'bool', aDirApprox: 'Pt3dr'=None) -> "ElRotation3D":
        return _mm3d.CamStenope_CombinatoireOFPAGen(self, TousDevant, NbTest, PR3, PF2, Res_Dmin, ModeRansac, aDirApprox)

    def RansacOFPA(self, TousDevant: 'bool', NbTest: 'int', P23: 'std::list< Appar23,std::allocator< Appar23 > > const &', Res_Dmin: 'double *', aDirApprox: 'Pt3dr'=None) -> "ElRotation3D":
        return _mm3d.CamStenope_RansacOFPA(self, TousDevant, NbTest, P23, Res_Dmin, aDirApprox)

    def CombinatoireOFPA(self, *args) -> "ElRotation3D":
        return _mm3d.CamStenope_CombinatoireOFPA(self, *args)

    def Set_GPS_Orientation_From_Appuis(self, aGPS: 'Pt3dr', aVApp: 'std::vector< Appar23,std::allocator< Appar23 > > const &', aNbRansac: 'int') -> "void":
        return _mm3d.CamStenope_Set_GPS_Orientation_From_Appuis(self, aGPS, aVApp, aNbRansac)

    def CastOliLib(self) -> "Ori3D_Std *":
        return _mm3d.CamStenope_CastOliLib(self)

    def NN_CastOliLib(self) -> "Ori3D_Std *":
        return _mm3d.CamStenope_NN_CastOliLib(self)

    def ResolutionPDVVerticale(self) -> "double":
        return _mm3d.CamStenope_ResolutionPDVVerticale(self)

    def ResolutionAngulaire(self) -> "double":
        return _mm3d.CamStenope_ResolutionAngulaire(self)

    def ResolutionSol(self, *args) -> "double":
        return _mm3d.CamStenope_ResolutionSol(self, *args)

    def Dupl(self) -> "CamStenope *":
        return _mm3d.CamStenope_Dupl(self)

    def Focale(self) -> "double":
        return _mm3d.CamStenope_Focale(self)

    def PP(self) -> "Pt2dr":
        return _mm3d.CamStenope_PP(self)

    def VraiOpticalCenter(self) -> "Pt3dr":
        return _mm3d.CamStenope_VraiOpticalCenter(self)

    def PseudoOpticalCenter(self) -> "Pt3dr":
        return _mm3d.CamStenope_PseudoOpticalCenter(self)

    def OpticalCenterOfPixel(self, aP: 'Pt2dr') -> "Pt3dr":
        return _mm3d.CamStenope_OpticalCenterOfPixel(self, aP)

    def OpticalVarCenterIm(self, arg2: 'Pt2dr') -> "Pt3dr":
        return _mm3d.CamStenope_OpticalVarCenterIm(self, arg2)

    def OpticalVarCenterTer(self, arg2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.CamStenope_OpticalVarCenterTer(self, arg2)

    def ImEtProf2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.CamStenope_ImEtProf2Terrain(self, aP, aZ)

    def NoDistImEtProf2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.CamStenope_NoDistImEtProf2Terrain(self, aP, aZ)

    def ImEtZ2Terrain(self, aP: 'Pt2dr', aZ: 'double') -> "Pt3dr":
        return _mm3d.CamStenope_ImEtZ2Terrain(self, aP, aZ)

    def Coins(self, aP1: 'Pt3dr', aP2: 'Pt3dr', aP3: 'Pt3dr', aP4: 'Pt3dr', aZ: 'double') -> "void":
        return _mm3d.CamStenope_Coins(self, aP1, aP2, aP3, aP4, aZ)

    def CoinsProjZ(self, aP1: 'Pt3dr', aP2: 'Pt3dr', aP3: 'Pt3dr', aP4: 'Pt3dr', aZ: 'double') -> "void":
        return _mm3d.CamStenope_CoinsProjZ(self, aP1, aP2, aP3, aP4, aZ)

    def BoxTer(self, aZ: 'double') -> "Box2dr":
        return _mm3d.CamStenope_BoxTer(self, aZ)

    def ImEtProfSpherik2Terrain(self, aPIm: 'Pt2dr', aProf: 'double const &') -> "Pt3dr":
        return _mm3d.CamStenope_ImEtProfSpherik2Terrain(self, aPIm, aProf)

    def ImDirEtProf2Terrain(self, aPIm: 'Pt2dr', aProf: 'double const &', aNormPl: 'Pt3dr') -> "Pt3dr":
        return _mm3d.CamStenope_ImDirEtProf2Terrain(self, aPIm, aProf, aNormPl)

    def Im1DirEtProf2_To_Terrain(self, p1: 'Pt2dr', ph2: 'CamStenope', prof2: 'double', aDir: 'Pt3dr') -> "Pt3dr":
        return _mm3d.CamStenope_Im1DirEtProf2_To_Terrain(self, p1, ph2, prof2, aDir)

    def Im1EtProfSpherik2_To_Terrain(self, p1: 'Pt2dr', ph2: 'CamStenope', prof2: 'double') -> "Pt3dr":
        return _mm3d.CamStenope_Im1EtProfSpherik2_To_Terrain(self, p1, ph2, prof2)

    def ExpImp2Bundle(self, aGridSz: 'Pt2di', aName: 'std::string const') -> "void":
        return _mm3d.CamStenope_ExpImp2Bundle(self, aGridSz, aName)

    def ProfInDir(self, aP: 'Pt3dr', arg3: 'Pt3dr') -> "double":
        return _mm3d.CamStenope_ProfInDir(self, aP, arg3)

    def Proj(self, *args) -> "ElProj32 const &":
        return _mm3d.CamStenope_Proj(self, *args)

    def Dist(self, *args) -> "ElDistortion22_Gen const &":
        return _mm3d.CamStenope_Dist(self, *args)

    def AllocParamInc(self, isDC2M: 'bool', arg3: 'cSetEqFormelles &') -> "cParamIntrinsequeFormel *":
        return _mm3d.CamStenope_AllocParamInc(self, isDC2M, arg3)

    def Change2Format_DRP(self, C2M: 'bool', aDegreOut: 'int', CDistPPLie: 'bool', Resol: 'double', Origine: 'Pt2dr') -> "cCamStenopeDistRadPol *":
        return _mm3d.CamStenope_Change2Format_DRP(self, C2M, aDegreOut, CDistPPLie, Resol, Origine)

    def InstanceModifParam(self, arg2: 'cCalibrationInternConique &') -> "void":
        return _mm3d.CamStenope_InstanceModifParam(self, arg2)

    def OrigineProf(self) -> "Pt3dr":
        return _mm3d.CamStenope_OrigineProf(self)

    def HasOrigineProf(self) -> "bool":
        return _mm3d.CamStenope_HasOrigineProf(self)

    def UseAFocal(self) -> "bool":
        return _mm3d.CamStenope_UseAFocal(self)
    __swig_destroy__ = _mm3d.delete_CamStenope
    __del__ = lambda self: None
CamStenope_swigregister = _mm3d.CamStenope_swigregister
CamStenope_swigregister(CamStenope)

def CamStenope_StdCamFromFile(UseGr: 'bool', arg3: 'std::string const &', anICNM: 'cInterfChantierNameManipulateur *') -> "CamStenope *":
    return _mm3d.CamStenope_StdCamFromFile(UseGr, arg3, anICNM)
CamStenope_StdCamFromFile = _mm3d.CamStenope_StdCamFromFile

class cDistStdFromCam(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistStdFromCam, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistStdFromCam, name)
    __repr__ = _swig_repr

    def __init__(self, Cam: 'ElCamera'):
        this = _mm3d.new_cDistStdFromCam(Cam)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistStdFromCam_Direct(self, arg2)

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt2dr') -> "void":
        return _mm3d.cDistStdFromCam_Diff(self, arg2, arg3)
    __swig_destroy__ = _mm3d.delete_cDistStdFromCam
    __del__ = lambda self: None
cDistStdFromCam_swigregister = _mm3d.cDistStdFromCam_swigregister
cDistStdFromCam_swigregister(cDistStdFromCam)

class cCamera_Orilib(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamera_Orilib, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamera_Orilib, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'Data_Ori3D_Std *'):
        this = _mm3d.new_cCamera_Orilib(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cCamera_Orilib
    __del__ = lambda self: None
cCamera_Orilib_swigregister = _mm3d.cCamera_Orilib_swigregister
cCamera_Orilib_swigregister(cCamera_Orilib)

class CamStenopeIdeale(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CamStenopeIdeale, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CamStenopeIdeale, name)
    __repr__ = _swig_repr
    if _newclass:
        CameraId = staticmethod(_mm3d.CamStenopeIdeale_CameraId)
    else:
        CameraId = _mm3d.CamStenopeIdeale_CameraId

    def __init__(self, *args):
        this = _mm3d.new_CamStenopeIdeale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_CamStenopeIdeale
    __del__ = lambda self: None
CamStenopeIdeale_swigregister = _mm3d.CamStenopeIdeale_swigregister
CamStenopeIdeale_swigregister(CamStenopeIdeale)

def CamStenopeIdeale_CameraId(isDistC2M: 'bool', arg3: 'ElRotation3D') -> "CamStenopeIdeale":
    return _mm3d.CamStenopeIdeale_CameraId(isDistC2M, arg3)
CamStenopeIdeale_CameraId = _mm3d.CamStenopeIdeale_CameraId

class cCamStenopeGen(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeGen, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeGen, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'CamStenope'):
        this = _mm3d.new_cCamStenopeGen(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cCamStenopeGen
    __del__ = lambda self: None
cCamStenopeGen_swigregister = _mm3d.cCamStenopeGen_swigregister
cCamStenopeGen_swigregister(cCamStenopeGen)

class cCamStenopeDistRadPol(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeDistRadPol, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeDistRadPol, name)
    __repr__ = _swig_repr

    def Debug_CSDRP(self) -> "cCamStenopeDistRadPol const *":
        return _mm3d.cCamStenopeDistRadPol_Debug_CSDRP(self)

    def __init__(self, *args):
        this = _mm3d.new_cCamStenopeDistRadPol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DRad(self, *args) -> "ElDistRadiale_PolynImpair const &":
        return _mm3d.cCamStenopeDistRadPol_DRad(self, *args)

    def write(self, *args) -> "void":
        return _mm3d.cCamStenopeDistRadPol_write(self, *args)
    if _newclass:
        read_new = staticmethod(_mm3d.cCamStenopeDistRadPol_read_new)
    else:
        read_new = _mm3d.cCamStenopeDistRadPol_read_new

    def AllocParamInc(self, isDC2M: 'bool', arg3: 'cSetEqFormelles &') -> "cParamIntrinsequeFormel *":
        return _mm3d.cCamStenopeDistRadPol_AllocParamInc(self, isDC2M, arg3)

    def AllocDRadInc(self, isDC2M: 'bool', arg3: 'cSetEqFormelles &') -> "cParamIFDistRadiale *":
        return _mm3d.cCamStenopeDistRadPol_AllocDRadInc(self, isDC2M, arg3)
    __swig_destroy__ = _mm3d.delete_cCamStenopeDistRadPol
    __del__ = lambda self: None
cCamStenopeDistRadPol_swigregister = _mm3d.cCamStenopeDistRadPol_swigregister
cCamStenopeDistRadPol_swigregister(cCamStenopeDistRadPol)

def cCamStenopeDistRadPol_read_new(*args) -> "cCamStenopeDistRadPol *":
    return _mm3d.cCamStenopeDistRadPol_read_new(*args)
cCamStenopeDistRadPol_read_new = _mm3d.cCamStenopeDistRadPol_read_new

class cDistModStdPhpgr(ElDistRadiale_PolynImpair):
    __swig_setmethods__ = {}
    for _s in [ElDistRadiale_PolynImpair]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistModStdPhpgr, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistRadiale_PolynImpair]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistModStdPhpgr, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'ElDistRadiale_PolynImpair'):
        this = _mm3d.new_cDistModStdPhpgr(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistModStdPhpgr_Direct(self, arg2)

    def Diff(self, arg2: 'ElMatrixr', arg3: 'Pt2dr') -> "void":
        return _mm3d.cDistModStdPhpgr_Diff(self, arg2, arg3)

    def OwnInverse(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cDistModStdPhpgr_OwnInverse(self, arg2)

    def GuessInv(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistModStdPhpgr_GuessInv(self, aP)

    def P1(self) -> "double &":
        return _mm3d.cDistModStdPhpgr_P1(self)

    def P2(self) -> "double &":
        return _mm3d.cDistModStdPhpgr_P2(self)

    def b1(self) -> "double &":
        return _mm3d.cDistModStdPhpgr_b1(self)

    def b2(self) -> "double &":
        return _mm3d.cDistModStdPhpgr_b2(self)

    def DRad(self, *args) -> "ElDistRadiale_PolynImpair const &":
        return _mm3d.cDistModStdPhpgr_DRad(self, *args)

    def DRADPol(self, strict: 'bool'=False) -> "ElDistRadiale_PolynImpair *":
        return _mm3d.cDistModStdPhpgr_DRADPol(self, strict)

    def ToXmlStruct(self, arg2: 'ElCamera') -> "cCalibDistortion":
        return _mm3d.cDistModStdPhpgr_ToXmlStruct(self, arg2)

    def ToXmlPhgrStdStruct(self) -> "cCalibrationInternePghrStd":
        return _mm3d.cDistModStdPhpgr_ToXmlPhgrStdStruct(self)
    __swig_destroy__ = _mm3d.delete_cDistModStdPhpgr
    __del__ = lambda self: None
cDistModStdPhpgr_swigregister = _mm3d.cDistModStdPhpgr_swigregister
cDistModStdPhpgr_swigregister(cDistModStdPhpgr)

class cCamStenopeModStdPhpgr(cCamStenopeDistRadPol):
    __swig_setmethods__ = {}
    for _s in [cCamStenopeDistRadPol]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeModStdPhpgr, name, value)
    __swig_getmethods__ = {}
    for _s in [cCamStenopeDistRadPol]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeModStdPhpgr, name)
    __repr__ = _swig_repr

    def __init__(self, DistIsC2M: 'bool', Focale: 'double', Centre: 'Pt2dr', arg5: 'cDistModStdPhpgr', ParamAF: 'DoubleVector'):
        this = _mm3d.new_cCamStenopeModStdPhpgr(DistIsC2M, Focale, Centre, arg5, ParamAF)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DModPhgrStd(self, *args) -> "cDistModStdPhpgr const &":
        return _mm3d.cCamStenopeModStdPhpgr_DModPhgrStd(self, *args)

    def Dist(self, *args) -> "ElDistortion22_Gen const &":
        return _mm3d.cCamStenopeModStdPhpgr_Dist(self, *args)

    def AllocParamInc(self, isDC2M: 'bool', arg3: 'cSetEqFormelles &') -> "cParamIntrinsequeFormel *":
        return _mm3d.cCamStenopeModStdPhpgr_AllocParamInc(self, isDC2M, arg3)

    def AllocPhgrStdInc(self, isDC2M: 'bool', arg3: 'cSetEqFormelles &') -> "cParamIFDistStdPhgr *":
        return _mm3d.cCamStenopeModStdPhpgr_AllocPhgrStdInc(self, isDC2M, arg3)
    __swig_destroy__ = _mm3d.delete_cCamStenopeModStdPhpgr
    __del__ = lambda self: None
cCamStenopeModStdPhpgr_swigregister = _mm3d.cCamStenopeModStdPhpgr_swigregister
cCamStenopeModStdPhpgr_swigregister(cCamStenopeModStdPhpgr)

class cCamStenopeDistPolyn(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeDistPolyn, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeDistPolyn, name)
    __repr__ = _swig_repr

    def __init__(self, isDistC2M: 'bool', Focale: 'double', Centre: 'Pt2dr', arg5: 'ElDistortionPolynomiale', arg6: 'DoubleVector'):
        this = _mm3d.new_cCamStenopeDistPolyn(isDistC2M, Focale, Centre, arg5, arg6)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DistPol(self) -> "ElDistortionPolynomiale const &":
        return _mm3d.cCamStenopeDistPolyn_DistPol(self)
    __swig_destroy__ = _mm3d.delete_cCamStenopeDistPolyn
    __del__ = lambda self: None
cCamStenopeDistPolyn_swigregister = _mm3d.cCamStenopeDistPolyn_swigregister
cCamStenopeDistPolyn_swigregister(cCamStenopeDistPolyn)

class cCamStenopeDistHomogr(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeDistHomogr, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeDistHomogr, name)
    __repr__ = _swig_repr

    def __init__(self, isDistC2M: 'bool', Focale: 'double', Centre: 'Pt2dr', arg5: 'cDistHomographie', arg6: 'DoubleVector'):
        this = _mm3d.new_cCamStenopeDistHomogr(isDistC2M, Focale, Centre, arg5, arg6)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Hom(self) -> "cElHomographie const &":
        return _mm3d.cCamStenopeDistHomogr_Hom(self)
    __swig_destroy__ = _mm3d.delete_cCamStenopeDistHomogr
    __del__ = lambda self: None
cCamStenopeDistHomogr_swigregister = _mm3d.cCamStenopeDistHomogr_swigregister
cCamStenopeDistHomogr_swigregister(cCamStenopeDistHomogr)

class cDistCamStenopeGrid(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistCamStenopeGrid, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistCamStenopeGrid, name)
    __repr__ = _swig_repr

    def DirectAndDer(self, aP: 'Pt2dr', aGX: 'Pt2dr', aGY: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistCamStenopeGrid_DirectAndDer(self, aP, aGX, aGY)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistCamStenopeGrid_Direct(self, arg2)

    def OwnInverse(self, arg2: 'Pt2dr') -> "bool":
        return _mm3d.cDistCamStenopeGrid_OwnInverse(self, arg2)
    if _newclass:
        Alloc = staticmethod(_mm3d.cDistCamStenopeGrid_Alloc)
    else:
        Alloc = _mm3d.cDistCamStenopeGrid_Alloc

    def __init__(self, arg2: 'ElDistortion22_Gen', arg3: 'cDbleGrid'):
        this = _mm3d.new_cDistCamStenopeGrid(arg2, arg3)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        Test = staticmethod(_mm3d.cDistCamStenopeGrid_Test)
    else:
        Test = _mm3d.cDistCamStenopeGrid_Test

    def ToXmlStruct(self, arg2: 'ElCamera') -> "cCalibDistortion":
        return _mm3d.cDistCamStenopeGrid_ToXmlStruct(self, arg2)

    def Type(self) -> "std::string":
        return _mm3d.cDistCamStenopeGrid_Type(self)
    __swig_destroy__ = _mm3d.delete_cDistCamStenopeGrid
    __del__ = lambda self: None
cDistCamStenopeGrid_swigregister = _mm3d.cDistCamStenopeGrid_swigregister
cDistCamStenopeGrid_swigregister(cDistCamStenopeGrid)

def cDistCamStenopeGrid_Alloc(P0P1IsBoxDirect: 'bool', aRayInv: 'double', arg3: 'CamStenope', aStepGr: 'Pt2dr', doDir: 'bool'=True, doInv: 'bool'=True) -> "cDistCamStenopeGrid *":
    return _mm3d.cDistCamStenopeGrid_Alloc(P0P1IsBoxDirect, aRayInv, arg3, aStepGr, doDir, doInv)
cDistCamStenopeGrid_Alloc = _mm3d.cDistCamStenopeGrid_Alloc

def cDistCamStenopeGrid_Test(aRayInv: 'double', arg3: 'CamStenope', aStepGr: 'Pt2dr') -> "void":
    return _mm3d.cDistCamStenopeGrid_Test(aRayInv, arg3, aStepGr)
cDistCamStenopeGrid_Test = _mm3d.cDistCamStenopeGrid_Test

class cCamStenopeGrid(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeGrid, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeGrid, name)
    __repr__ = _swig_repr
    if _newclass:
        Alloc = staticmethod(_mm3d.cCamStenopeGrid_Alloc)
    else:
        Alloc = _mm3d.cCamStenopeGrid_Alloc

    def __init__(self, aFoc: 'double const &', arg3: 'Pt2dr', arg4: 'cDistCamStenopeGrid', aSz: 'Pt2di', ParamAF: 'DoubleVector'):
        this = _mm3d.new_cCamStenopeGrid(aFoc, arg3, arg4, aSz, ParamAF)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def L2toF2AndDer(self, aP: 'Pt2dr', aGX: 'Pt2dr', aGY: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cCamStenopeGrid_L2toF2AndDer(self, aP, aGX, aGY)
    __swig_destroy__ = _mm3d.delete_cCamStenopeGrid
    __del__ = lambda self: None
cCamStenopeGrid_swigregister = _mm3d.cCamStenopeGrid_swigregister
cCamStenopeGrid_swigregister(cCamStenopeGrid)

def cCamStenopeGrid_Alloc(aRayonInv: 'double', arg2: 'CamStenope', aStepGr: 'Pt2dr', doDir: 'bool'=True, doInv: 'bool'=True) -> "cCamStenopeGrid *":
    return _mm3d.cCamStenopeGrid_Alloc(aRayonInv, arg2, aStepGr, doDir, doInv)
cCamStenopeGrid_Alloc = _mm3d.cCamStenopeGrid_Alloc

class CalcPtsInteret(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CalcPtsInteret, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CalcPtsInteret, name)
    __repr__ = _swig_repr
    if _newclass:
        CritereFonc = staticmethod(_mm3d.CalcPtsInteret_CritereFonc)
    else:
        CritereFonc = _mm3d.CalcPtsInteret_CritereFonc
    if _newclass:
        GetEnsPtsInteret_Size = staticmethod(_mm3d.CalcPtsInteret_GetEnsPtsInteret_Size)
    else:
        GetEnsPtsInteret_Size = _mm3d.CalcPtsInteret_GetEnsPtsInteret_Size
    if _newclass:
        GetEnsPtsInteret_Nb = staticmethod(_mm3d.CalcPtsInteret_GetEnsPtsInteret_Nb)
    else:
        GetEnsPtsInteret_Nb = _mm3d.CalcPtsInteret_GetEnsPtsInteret_Nb

    def __init__(self):
        this = _mm3d.new_CalcPtsInteret()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_CalcPtsInteret
    __del__ = lambda self: None
CalcPtsInteret_swigregister = _mm3d.CalcPtsInteret_swigregister
CalcPtsInteret_swigregister(CalcPtsInteret)

def CalcPtsInteret_CritereFonc(arg2: 'Fonc_Num') -> "Fonc_Num":
    return _mm3d.CalcPtsInteret_CritereFonc(arg2)
CalcPtsInteret_CritereFonc = _mm3d.CalcPtsInteret_CritereFonc

def CalcPtsInteret_GetEnsPtsInteret_Size(*args) -> "CalcPtsInteret::tContainerPtsInt":
    return _mm3d.CalcPtsInteret_GetEnsPtsInteret_Size(*args)
CalcPtsInteret_GetEnsPtsInteret_Size = _mm3d.CalcPtsInteret_GetEnsPtsInteret_Size

def CalcPtsInteret_GetEnsPtsInteret_Nb(*args) -> "CalcPtsInteret::tContainerPtsInt":
    return _mm3d.CalcPtsInteret_GetEnsPtsInteret_Nb(*args)
CalcPtsInteret_GetEnsPtsInteret_Nb = _mm3d.CalcPtsInteret_GetEnsPtsInteret_Nb

class cElFaisceauDr2D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElFaisceauDr2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElFaisceauDr2D, name)
    __repr__ = _swig_repr

    def PtsConvergence(self, teta0: 'double &', phi0: 'double &', OptimPhi: 'bool') -> "void":
        return _mm3d.cElFaisceauDr2D_PtsConvergence(self, teta0, phi0, OptimPhi)

    def PtsConvergenceItere(self, teta0: 'double &', phi0: 'double &', NbStep: 'int', Epsilon: 'double', OptimPhi: 'bool', DeltaResidu: 'double'=-1) -> "void":
        return _mm3d.cElFaisceauDr2D_PtsConvergenceItere(self, teta0, phi0, NbStep, Epsilon, OptimPhi, DeltaResidu)

    def ResiduConvergence(self, teta: 'double', phi: 'double') -> "double":
        return _mm3d.cElFaisceauDr2D_ResiduConvergence(self, teta, phi)

    def AddFaisceau(self, aP0: 'Pt2dr', aDir: 'Pt2dr', aPds: 'double') -> "void":
        return _mm3d.cElFaisceauDr2D_AddFaisceau(self, aP0, aDir, aPds)

    def TetaDirectionInf(self) -> "double":
        return _mm3d.cElFaisceauDr2D_TetaDirectionInf(self)

    def CalibrDistRadiale(self, aC0: 'Pt2dr', CentreMobile: 'bool', TetaEpip: 'double &', PhiEpip: 'double &', Coeffs: 'DoubleVector') -> "void":
        return _mm3d.cElFaisceauDr2D_CalibrDistRadiale(self, aC0, CentreMobile, TetaEpip, PhiEpip, Coeffs)

    def __init__(self):
        this = _mm3d.new_cElFaisceauDr2D()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cElFaisceauDr2D
    __del__ = lambda self: None
cElFaisceauDr2D_swigregister = _mm3d.cElFaisceauDr2D_swigregister
cElFaisceauDr2D_swigregister(cElFaisceauDr2D)

class cElemMepRelCoplan(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cElemMepRelCoplan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cElemMepRelCoplan, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'cElHomographie', arg3: 'ElRotation3D'):
        this = _mm3d.new_cElemMepRelCoplan(arg2, arg3)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ToGivenProf(self, aProProf: 'double') -> "cElemMepRelCoplan":
        return _mm3d.cElemMepRelCoplan_ToGivenProf(self, aProProf)

    def PhysOk(self) -> "bool":
        return _mm3d.cElemMepRelCoplan_PhysOk(self)

    def Show(self) -> "void":
        return _mm3d.cElemMepRelCoplan_Show(self)

    def AngTot(self) -> "double":
        return _mm3d.cElemMepRelCoplan_AngTot(self)

    def Ang1(self) -> "double":
        return _mm3d.cElemMepRelCoplan_Ang1(self)

    def Ang2(self) -> "double":
        return _mm3d.cElemMepRelCoplan_Ang2(self)

    def Rot(self) -> "ElRotation3D const &":
        return _mm3d.cElemMepRelCoplan_Rot(self)

    def TestSol(self) -> "double":
        return _mm3d.cElemMepRelCoplan_TestSol(self)

    def TestPack(self, arg2: 'ElPackHomologue') -> "void":
        return _mm3d.cElemMepRelCoplan_TestPack(self, arg2)

    def Norm(self) -> "Pt3dr":
        return _mm3d.cElemMepRelCoplan_Norm(self)

    def DPlan(self) -> "double":
        return _mm3d.cElemMepRelCoplan_DPlan(self)

    def DistanceEuclid(self) -> "double":
        return _mm3d.cElemMepRelCoplan_DistanceEuclid(self)

    def DPlan2(self) -> "double":
        return _mm3d.cElemMepRelCoplan_DPlan2(self)

    def ImCam1(self, aP1: 'Pt2dr') -> "Pt3dr":
        return _mm3d.cElemMepRelCoplan_ImCam1(self, aP1)

    def HomCam2Plan(self, aResidu: 'double *'=None) -> "cElHomographie":
        return _mm3d.cElemMepRelCoplan_HomCam2Plan(self, aResidu)

    def P0(self) -> "Pt3dr const &":
        return _mm3d.cElemMepRelCoplan_P0(self)

    def P1(self) -> "Pt3dr const &":
        return _mm3d.cElemMepRelCoplan_P1(self)

    def P2(self) -> "Pt3dr const &":
        return _mm3d.cElemMepRelCoplan_P2(self)

    def ToR1(self, aP2: 'Pt3dr') -> "Pt3dr":
        return _mm3d.cElemMepRelCoplan_ToR1(self, aP2)
    __swig_destroy__ = _mm3d.delete_cElemMepRelCoplan
    __del__ = lambda self: None
cElemMepRelCoplan_swigregister = _mm3d.cElemMepRelCoplan_swigregister
cElemMepRelCoplan_swigregister(cElemMepRelCoplan)

class cResMepRelCoplan(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cResMepRelCoplan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cResMepRelCoplan, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cResMepRelCoplan()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def RefBestSol(self) -> "cElemMepRelCoplan &":
        return _mm3d.cResMepRelCoplan_RefBestSol(self)

    def PtrBestSol(self) -> "cElemMepRelCoplan *":
        return _mm3d.cResMepRelCoplan_PtrBestSol(self)

    def AddSol(self, arg2: 'cElemMepRelCoplan') -> "void":
        return _mm3d.cResMepRelCoplan_AddSol(self, arg2)

    def LRot(self) -> "std::list< ElRotation3D,std::allocator< ElRotation3D > > const &":
        return _mm3d.cResMepRelCoplan_LRot(self)

    def VElOk(self) -> "std::vector< cElemMepRelCoplan,std::allocator< cElemMepRelCoplan > > const &":
        return _mm3d.cResMepRelCoplan_VElOk(self)

    def LElem(self) -> "std::list< cElemMepRelCoplan,std::allocator< cElemMepRelCoplan > > const &":
        return _mm3d.cResMepRelCoplan_LElem(self)
    __swig_destroy__ = _mm3d.delete_cResMepRelCoplan
    __del__ = lambda self: None
cResMepRelCoplan_swigregister = _mm3d.cResMepRelCoplan_swigregister
cResMepRelCoplan_swigregister(cResMepRelCoplan)

class cCiblePolygoneEtal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCiblePolygoneEtal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cCiblePolygoneEtal, name)
    __repr__ = _swig_repr
    ePerfect = _mm3d.cCiblePolygoneEtal_ePerfect
    eBeurk = _mm3d.cCiblePolygoneEtal_eBeurk

    def SetPos(self, aP: 'Pt3dr') -> "void":
        return _mm3d.cCiblePolygoneEtal_SetPos(self, aP)

    def Pos(self) -> "Pt3dr":
        return _mm3d.cCiblePolygoneEtal_Pos(self)

    def Ind(self) -> "cCiblePolygoneEtal::tInd":
        return _mm3d.cCiblePolygoneEtal_Ind(self)

    def Mire(self) -> "cMirePolygonEtal const &":
        return _mm3d.cCiblePolygoneEtal_Mire(self)

    def Qual(self) -> "cCiblePolygoneEtal::tQualCible":
        return _mm3d.cCiblePolygoneEtal_Qual(self)

    def __init__(self, *args):
        this = _mm3d.new_cCiblePolygoneEtal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CC(self) -> "cCibleCalib *":
        return _mm3d.cCiblePolygoneEtal_CC(self)

    def Order(self) -> "int":
        return _mm3d.cCiblePolygoneEtal_Order(self)
    __swig_destroy__ = _mm3d.delete_cCiblePolygoneEtal
    __del__ = lambda self: None
cCiblePolygoneEtal_swigregister = _mm3d.cCiblePolygoneEtal_swigregister
cCiblePolygoneEtal_swigregister(cCiblePolygoneEtal)

class cPolygoneEtal(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cPolygoneEtal, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cPolygoneEtal, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def AddCible(self, arg2: 'cCiblePolygoneEtal') -> "void":
        return _mm3d.cPolygoneEtal_AddCible(self, arg2)

    def Cible(self, arg2: 'cCiblePolygoneEtal::tInd') -> "cCiblePolygoneEtal const &":
        return _mm3d.cPolygoneEtal_Cible(self, arg2)
    __swig_destroy__ = _mm3d.delete_cPolygoneEtal
    __del__ = lambda self: None
    if _newclass:
        IGN = staticmethod(_mm3d.cPolygoneEtal_IGN)
    else:
        IGN = _mm3d.cPolygoneEtal_IGN
    if _newclass:
        FromName = staticmethod(_mm3d.cPolygoneEtal_FromName)
    else:
        FromName = _mm3d.cPolygoneEtal_FromName

    def ListeCible(self) -> "cPolygoneEtal::tContCible const &":
        return _mm3d.cPolygoneEtal_ListeCible(self)

    def PC(self) -> "cPolygoneCalib *":
        return _mm3d.cPolygoneEtal_PC(self)

    def SetPC(self, arg2: 'cPolygoneCalib *') -> "void":
        return _mm3d.cPolygoneEtal_SetPC(self, arg2)
cPolygoneEtal_swigregister = _mm3d.cPolygoneEtal_swigregister
cPolygoneEtal_swigregister(cPolygoneEtal)

def cPolygoneEtal_IGN() -> "cPolygoneEtal *":
    return _mm3d.cPolygoneEtal_IGN()
cPolygoneEtal_IGN = _mm3d.cPolygoneEtal_IGN

def cPolygoneEtal_FromName(arg2: 'std::string const &', aParam: 'cComplParamEtalPoly const *') -> "cPolygoneEtal *":
    return _mm3d.cPolygoneEtal_FromName(arg2, aParam)
cPolygoneEtal_FromName = _mm3d.cPolygoneEtal_FromName

class cPointeEtalonage(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cPointeEtalonage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cPointeEtalonage, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'cCiblePolygoneEtal::tInd', arg3: 'Pt2dr', arg4: 'cPolygoneEtal'):
        this = _mm3d.new_cPointeEtalonage(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def PosIm(self) -> "Pt2dr":
        return _mm3d.cPointeEtalonage_PosIm(self)

    def PosTer(self) -> "Pt3dr":
        return _mm3d.cPointeEtalonage_PosTer(self)

    def SetPosIm(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.cPointeEtalonage_SetPosIm(self, arg2)

    def Cible(self) -> "cCiblePolygoneEtal const &":
        return _mm3d.cPointeEtalonage_Cible(self)

    def UseIt(self) -> "bool":
        return _mm3d.cPointeEtalonage_UseIt(self)

    def Pds(self) -> "double":
        return _mm3d.cPointeEtalonage_Pds(self)
    __swig_destroy__ = _mm3d.delete_cPointeEtalonage
    __del__ = lambda self: None
cPointeEtalonage_swigregister = _mm3d.cPointeEtalonage_swigregister
cPointeEtalonage_swigregister(cPointeEtalonage)

class cSetPointes1Im(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cSetPointes1Im, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cSetPointes1Im, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'cPolygoneEtal', arg3: 'std::string const &', SVP: 'bool'=False):
        this = _mm3d.new_cSetPointes1Im(arg2, arg3, SVP)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Pointes(self) -> "cSetPointes1Im::tCont &":
        return _mm3d.cSetPointes1Im_Pointes(self)

    def PointeOfId(self, arg2: 'cCiblePolygoneEtal::tInd') -> "cPointeEtalonage &":
        return _mm3d.cSetPointes1Im_PointeOfId(self, arg2)

    def PointeOfIdSvp(self, arg2: 'cCiblePolygoneEtal::tInd') -> "cPointeEtalonage *":
        return _mm3d.cSetPointes1Im_PointeOfIdSvp(self, arg2)

    def RemoveCibles(self, IndToRemove: 'IntVector') -> "void":
        return _mm3d.cSetPointes1Im_RemoveCibles(self, IndToRemove)

    def InitFromFile(self, arg2: 'cPolygoneEtal', aFp: 'ELISE_fp &', InPK1: 'bool') -> "bool":
        return _mm3d.cSetPointes1Im_InitFromFile(self, arg2, aFp, InPK1)
    __swig_destroy__ = _mm3d.delete_cSetPointes1Im
    __del__ = lambda self: None
cSetPointes1Im_swigregister = _mm3d.cSetPointes1Im_swigregister
cSetPointes1Im_swigregister(cSetPointes1Im)

class cSetNImSetPointes(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cSetNImSetPointes, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cSetNImSetPointes, name)
    __repr__ = _swig_repr

    def __init__(self, arg2: 'cPolygoneEtal', arg3: 'std::string const &', SVP: 'bool'=False):
        this = _mm3d.new_cSetNImSetPointes(arg2, arg3, SVP)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Pointes(self) -> "cSetNImSetPointes::tCont &":
        return _mm3d.cSetNImSetPointes_Pointes(self)

    def NbPointes(self) -> "int":
        return _mm3d.cSetNImSetPointes_NbPointes(self)
    __swig_destroy__ = _mm3d.delete_cSetNImSetPointes
    __del__ = lambda self: None
cSetNImSetPointes_swigregister = _mm3d.cSetNImSetPointes_swigregister
cSetNImSetPointes_swigregister(cSetNImSetPointes)

class cDbleGrid(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDbleGrid, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDbleGrid, name)
    __repr__ = _swig_repr

    def Focale(self) -> "double":
        return _mm3d.cDbleGrid_Focale(self)

    def PP(self) -> "Pt2dr":
        return _mm3d.cDbleGrid_PP(self)

    def P0_Dir(self) -> "Pt2dr const &":
        return _mm3d.cDbleGrid_P0_Dir(self)

    def P1_Dir(self) -> "Pt2dr const &":
        return _mm3d.cDbleGrid_P1_Dir(self)

    def Step_Dir(self) -> "Pt2dr const &":
        return _mm3d.cDbleGrid_Step_Dir(self)
    if _newclass:
        StdGridPhotogram = staticmethod(_mm3d.cDbleGrid_StdGridPhotogram)
    else:
        StdGridPhotogram = _mm3d.cDbleGrid_StdGridPhotogram
    if _newclass:
        read = staticmethod(_mm3d.cDbleGrid_read)
    else:
        read = _mm3d.cDbleGrid_read

    def write(self, *args) -> "void":
        return _mm3d.cDbleGrid_write(self, *args)
    __swig_destroy__ = _mm3d.delete_cDbleGrid
    __del__ = lambda self: None

    def ValueAndDer(self, aRealP: 'Pt2dr', aGradX: 'Pt2dr', aGradY: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDbleGrid_ValueAndDer(self, aRealP, aGradX, aGradY)

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDbleGrid_Direct(self, arg2)

    def GrDir(self, *args) -> "PtImGrid &":
        return _mm3d.cDbleGrid_GrDir(self, *args)

    def GrInv(self, *args) -> "PtImGrid &":
        return _mm3d.cDbleGrid_GrInv(self, *args)

    def SetTrChScaleDir(self, aChScale: 'double', aTr: 'Pt2dr') -> "void":
        return _mm3d.cDbleGrid_SetTrChScaleDir(self, aChScale, aTr)

    def SetTrChScaleInv(self, aChScale: 'double', aTr: 'Pt2dr') -> "void":
        return _mm3d.cDbleGrid_SetTrChScaleInv(self, aChScale, aTr)

    def __init__(self, *args):
        this = _mm3d.new_cDbleGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def PutXMWithData(self, aFileXML: 'cElXMLFileIn &', aNameDir: 'std::string const &') -> "void":
        return _mm3d.cDbleGrid_PutXMWithData(self, aFileXML, aNameDir)

    def StepAdapted(self) -> "bool":
        return _mm3d.cDbleGrid_StepAdapted(self)

    def SaveXML(self, arg2: 'std::string const &') -> "void":
        return _mm3d.cDbleGrid_SaveXML(self, arg2)
cDbleGrid_swigregister = _mm3d.cDbleGrid_swigregister
cDbleGrid_swigregister(cDbleGrid)

def cDbleGrid_StdGridPhotogram(aName: 'std::string const &', aSzDisc: 'int'=30) -> "cDbleGrid *":
    return _mm3d.cDbleGrid_StdGridPhotogram(aName, aSzDisc)
cDbleGrid_StdGridPhotogram = _mm3d.cDbleGrid_StdGridPhotogram

def cDbleGrid_read(*args) -> "cDbleGrid *":
    return _mm3d.cDbleGrid_read(*args)
cDbleGrid_read = _mm3d.cDbleGrid_read

class cEqTrianguApparImage(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cEqTrianguApparImage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cEqTrianguApparImage, name)
    __repr__ = _swig_repr

    def __init__(self, aCapa: 'int'):
        this = _mm3d.new_cEqTrianguApparImage(aCapa)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cEqTrianguApparImage
    __del__ = lambda self: None

    def Reset(self) -> "void":
        return _mm3d.cEqTrianguApparImage_Reset(self)

    def Close(self) -> "void":
        return _mm3d.cEqTrianguApparImage_Close(self)

    def Add(self, aI: 'double', aJ: 'double', aDxJ: 'double', aDyJ: 'double', aPdsA: 'double', aPdsB: 'double', aPdsC: 'double') -> "void":
        return _mm3d.cEqTrianguApparImage_Add(self, aI, aJ, aDxJ, aDyJ, aPdsA, aPdsB, aPdsC)

    def SetDer(self, aCste: 'double &', aDer: 'double *', aK: 'int') -> "void":
        return _mm3d.cEqTrianguApparImage_SetDer(self, aCste, aDer, aK)
cEqTrianguApparImage_swigregister = _mm3d.cEqTrianguApparImage_swigregister
cEqTrianguApparImage_swigregister(cEqTrianguApparImage)


def RotationCart2RTL(*args) -> "ElRotation3D":
    return _mm3d.RotationCart2RTL(*args)
RotationCart2RTL = _mm3d.RotationCart2RTL
class cAnalyseZoneLiaison(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cAnalyseZoneLiaison, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cAnalyseZoneLiaison, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cAnalyseZoneLiaison()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddPt(self, arg2: 'Pt2dr') -> "void":
        return _mm3d.cAnalyseZoneLiaison_AddPt(self, arg2)

    def Reset(self) -> "void":
        return _mm3d.cAnalyseZoneLiaison_Reset(self)

    def Score(self, ExposantDist: 'double', ExposantPds: 'double') -> "double":
        return _mm3d.cAnalyseZoneLiaison_Score(self, ExposantDist, ExposantPds)

    def VPts(self) -> "std::vector< Pt2dr,std::allocator< Pt2dr > > const &":
        return _mm3d.cAnalyseZoneLiaison_VPts(self)
    __swig_destroy__ = _mm3d.delete_cAnalyseZoneLiaison
    __del__ = lambda self: None
cAnalyseZoneLiaison_swigregister = _mm3d.cAnalyseZoneLiaison_swigregister
cAnalyseZoneLiaison_swigregister(cAnalyseZoneLiaison)

class cCS_MapIm2PlanProj(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCS_MapIm2PlanProj, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCS_MapIm2PlanProj, name)
    __repr__ = _swig_repr

    def __init__(self, pCam: 'CamStenope'):
        this = _mm3d.new_cCS_MapIm2PlanProj(pCam)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Direct(self, aP: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cCS_MapIm2PlanProj_Direct(self, aP)
    __swig_destroy__ = _mm3d.delete_cCS_MapIm2PlanProj
    __del__ = lambda self: None
cCS_MapIm2PlanProj_swigregister = _mm3d.cCS_MapIm2PlanProj_swigregister
cCS_MapIm2PlanProj_swigregister(cCS_MapIm2PlanProj)


def LocPxFileMatch(aDir: 'std::string const &', aNum: 'int', aDeZoom: 'int') -> "std::string":
    return _mm3d.LocPxFileMatch(aDir, aNum, aDeZoom)
LocPxFileMatch = _mm3d.LocPxFileMatch

def LocPx2FileMatch(aDir: 'std::string const &', aNum: 'int', aDeZoom: 'int') -> "std::string":
    return _mm3d.LocPx2FileMatch(aDir, aNum, aDeZoom)
LocPx2FileMatch = _mm3d.LocPx2FileMatch

def LocMasqFileMatch(aDirM: 'std::string const &', aNum: 'int') -> "std::string":
    return _mm3d.LocMasqFileMatch(aDirM, aNum)
LocMasqFileMatch = _mm3d.LocMasqFileMatch

def LocCorFileMatch(aDir: 'std::string const &', aNum: 'int') -> "std::string":
    return _mm3d.LocCorFileMatch(aDir, aNum)
LocCorFileMatch = _mm3d.LocCorFileMatch

def LocDirMec2Im(Im1: 'std::string const &', Im2: 'std::string const &') -> "std::string":
    return _mm3d.LocDirMec2Im(Im1, Im2)
LocDirMec2Im = _mm3d.LocDirMec2Im

def StdNameImDeZoom(Im1: 'std::string const &', aDeZoom: 'int') -> "std::string":
    return _mm3d.StdNameImDeZoom(Im1, aDeZoom)
StdNameImDeZoom = _mm3d.StdNameImDeZoom

def StdCpleEpip(aDir: 'std::string', aNameOri: 'std::string', aNameIm1: 'std::string', aNameIm2: 'std::string') -> "cCpleEpip *":
    return _mm3d.StdCpleEpip(aDir, aNameOri, aNameIm1, aNameIm2)
StdCpleEpip = _mm3d.StdCpleEpip

def CamCompatible_doublegrid(aNameFile: 'std::string const &') -> "CamStenope *":
    return _mm3d.CamCompatible_doublegrid(aNameFile)
CamCompatible_doublegrid = _mm3d.CamCompatible_doublegrid
class cTxtCam(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTxtCam, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cTxtCam, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _mm3d.new_cTxtCam()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetVitesse(self, aV: 'Pt3dr') -> "void":
        return _mm3d.cTxtCam_SetVitesse(self, aV)
    __swig_setmethods__["mNameIm"] = _mm3d.cTxtCam_mNameIm_set
    __swig_getmethods__["mNameIm"] = _mm3d.cTxtCam_mNameIm_get
    if _newclass:
        mNameIm = _swig_property(_mm3d.cTxtCam_mNameIm_get, _mm3d.cTxtCam_mNameIm_set)
    __swig_setmethods__["mNameOri"] = _mm3d.cTxtCam_mNameOri_set
    __swig_getmethods__["mNameOri"] = _mm3d.cTxtCam_mNameOri_get
    if _newclass:
        mNameOri = _swig_property(_mm3d.cTxtCam_mNameOri_get, _mm3d.cTxtCam_mNameOri_set)
    __swig_setmethods__["mCam"] = _mm3d.cTxtCam_mCam_set
    __swig_getmethods__["mCam"] = _mm3d.cTxtCam_mCam_get
    if _newclass:
        mCam = _swig_property(_mm3d.cTxtCam_mCam_get, _mm3d.cTxtCam_mCam_set)
    __swig_setmethods__["mRefCam"] = _mm3d.cTxtCam_mRefCam_set
    __swig_getmethods__["mRefCam"] = _mm3d.cTxtCam_mRefCam_get
    if _newclass:
        mRefCam = _swig_property(_mm3d.cTxtCam_mRefCam_get, _mm3d.cTxtCam_mRefCam_set)
    __swig_setmethods__["mOC"] = _mm3d.cTxtCam_mOC_set
    __swig_getmethods__["mOC"] = _mm3d.cTxtCam_mOC_get
    if _newclass:
        mOC = _swig_property(_mm3d.cTxtCam_mOC_get, _mm3d.cTxtCam_mOC_set)
    __swig_setmethods__["mPrio"] = _mm3d.cTxtCam_mPrio_set
    __swig_getmethods__["mPrio"] = _mm3d.cTxtCam_mPrio_get
    if _newclass:
        mPrio = _swig_property(_mm3d.cTxtCam_mPrio_get, _mm3d.cTxtCam_mPrio_set)
    __swig_setmethods__["mSelC"] = _mm3d.cTxtCam_mSelC_set
    __swig_getmethods__["mSelC"] = _mm3d.cTxtCam_mSelC_get
    if _newclass:
        mSelC = _swig_property(_mm3d.cTxtCam_mSelC_get, _mm3d.cTxtCam_mSelC_set)
    __swig_setmethods__["mC"] = _mm3d.cTxtCam_mC_set
    __swig_getmethods__["mC"] = _mm3d.cTxtCam_mC_get
    if _newclass:
        mC = _swig_property(_mm3d.cTxtCam_mC_get, _mm3d.cTxtCam_mC_set)
    __swig_setmethods__["mV"] = _mm3d.cTxtCam_mV_set
    __swig_getmethods__["mV"] = _mm3d.cTxtCam_mV_get
    if _newclass:
        mV = _swig_property(_mm3d.cTxtCam_mV_get, _mm3d.cTxtCam_mV_set)
    __swig_setmethods__["mWPK"] = _mm3d.cTxtCam_mWPK_set
    __swig_getmethods__["mWPK"] = _mm3d.cTxtCam_mWPK_get
    if _newclass:
        mWPK = _swig_property(_mm3d.cTxtCam_mWPK_get, _mm3d.cTxtCam_mWPK_set)
    __swig_setmethods__["mVIsCalc"] = _mm3d.cTxtCam_mVIsCalc_set
    __swig_getmethods__["mVIsCalc"] = _mm3d.cTxtCam_mVIsCalc_get
    if _newclass:
        mVIsCalc = _swig_property(_mm3d.cTxtCam_mVIsCalc_get, _mm3d.cTxtCam_mVIsCalc_set)
    __swig_setmethods__["mNum"] = _mm3d.cTxtCam_mNum_set
    __swig_getmethods__["mNum"] = _mm3d.cTxtCam_mNum_get
    if _newclass:
        mNum = _swig_property(_mm3d.cTxtCam_mNum_get, _mm3d.cTxtCam_mNum_set)
    __swig_setmethods__["mNumBande"] = _mm3d.cTxtCam_mNumBande_set
    __swig_getmethods__["mNumBande"] = _mm3d.cTxtCam_mNumBande_get
    if _newclass:
        mNumBande = _swig_property(_mm3d.cTxtCam_mNumBande_get, _mm3d.cTxtCam_mNumBande_set)
    __swig_setmethods__["mTime"] = _mm3d.cTxtCam_mTime_set
    __swig_getmethods__["mTime"] = _mm3d.cTxtCam_mTime_get
    if _newclass:
        mTime = _swig_property(_mm3d.cTxtCam_mTime_get, _mm3d.cTxtCam_mTime_set)
    __swig_setmethods__["mMTD"] = _mm3d.cTxtCam_mMTD_set
    __swig_getmethods__["mMTD"] = _mm3d.cTxtCam_mMTD_get
    if _newclass:
        mMTD = _swig_property(_mm3d.cTxtCam_mMTD_get, _mm3d.cTxtCam_mMTD_set)
    __swig_destroy__ = _mm3d.delete_cTxtCam
    __del__ = lambda self: None
cTxtCam_swigregister = _mm3d.cTxtCam_swigregister
cTxtCam_swigregister(cTxtCam)

class cCmpPtrCam(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCmpPtrCam, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cCmpPtrCam, name)
    __repr__ = _swig_repr

    def __call__(self, aC1: 'cTxtCam', aC2: 'cTxtCam') -> "bool":
        return _mm3d.cCmpPtrCam___call__(self, aC1, aC2)

    def __init__(self):
        this = _mm3d.new_cCmpPtrCam()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cCmpPtrCam
    __del__ = lambda self: None
cCmpPtrCam_swigregister = _mm3d.cCmpPtrCam_swigregister
cCmpPtrCam_swigregister(cCmpPtrCam)

class cDistorBilin(ElDistortion22_Gen):
    __swig_setmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cDistorBilin, name, value)
    __swig_getmethods__ = {}
    for _s in [ElDistortion22_Gen]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cDistorBilin, name)
    __repr__ = _swig_repr

    def __init__(self, aSz: 'Pt2dr', aP0: 'Pt2dr', aNb: 'Pt2di'):
        this = _mm3d.new_cDistorBilin(aSz, aP0, aNb)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Direct(self, arg2: 'Pt2dr') -> "Pt2dr":
        return _mm3d.cDistorBilin_Direct(self, arg2)

    def Dist(self, *args) -> "Pt2dr const &":
        return _mm3d.cDistorBilin_Dist(self, *args)

    def Nb(self) -> "Pt2di const &":
        return _mm3d.cDistorBilin_Nb(self)

    def ToXmlStruct(self, arg2: 'ElCamera') -> "cCalibDistortion":
        return _mm3d.cDistorBilin_ToXmlStruct(self, arg2)

    def ToXmlGridStruct(self) -> "cCalibrationInterneGridDef":
        return _mm3d.cDistorBilin_ToXmlGridStruct(self)
    if _newclass:
        FromXmlGridStuct = staticmethod(_mm3d.cDistorBilin_FromXmlGridStuct)
    else:
        FromXmlGridStuct = _mm3d.cDistorBilin_FromXmlGridStuct

    def AcceptScaling(self) -> "bool":
        return _mm3d.cDistorBilin_AcceptScaling(self)

    def AcceptTranslate(self) -> "bool":
        return _mm3d.cDistorBilin_AcceptTranslate(self)

    def V_SetScalingTranslate(self, arg2: 'double const &', arg3: 'Pt2dr') -> "void":
        return _mm3d.cDistorBilin_V_SetScalingTranslate(self, arg2, arg3)
    __swig_destroy__ = _mm3d.delete_cDistorBilin
    __del__ = lambda self: None
cDistorBilin_swigregister = _mm3d.cDistorBilin_swigregister
cDistorBilin_swigregister(cDistorBilin)

def cDistorBilin_FromXmlGridStuct(arg2: 'cCalibrationInterneGridDef const &') -> "cDistorBilin":
    return _mm3d.cDistorBilin_FromXmlGridStuct(arg2)
cDistorBilin_FromXmlGridStuct = _mm3d.cDistorBilin_FromXmlGridStuct

class cCamStenopeBilin(CamStenope):
    __swig_setmethods__ = {}
    for _s in [CamStenope]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCamStenopeBilin, name, value)
    __swig_getmethods__ = {}
    for _s in [CamStenope]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, cCamStenopeBilin, name)
    __repr__ = _swig_repr

    def __init__(self, Focale: 'double', Centre: 'Pt2dr', aDBL: 'cDistorBilin'):
        this = _mm3d.new_cCamStenopeBilin(Focale, Centre, aDBL)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dist(self, *args) -> "ElDistortion22_Gen &":
        return _mm3d.cCamStenopeBilin_Dist(self, *args)

    def DBL(self) -> "cDistorBilin const &":
        return _mm3d.cCamStenopeBilin_DBL(self)

    def CSBil_SVP(self) -> "cCamStenopeBilin *":
        return _mm3d.cCamStenopeBilin_CSBil_SVP(self)
    __swig_destroy__ = _mm3d.delete_cCamStenopeBilin
    __del__ = lambda self: None
cCamStenopeBilin_swigregister = _mm3d.cCamStenopeBilin_swigregister
cCamStenopeBilin_swigregister(cCamStenopeBilin)


def QuickD48EProjCostMEP(*args) -> "double":
    return _mm3d.QuickD48EProjCostMEP(*args)
QuickD48EProjCostMEP = _mm3d.QuickD48EProjCostMEP

def ProjCostMEP(*args) -> "double":
    return _mm3d.ProjCostMEP(*args)
ProjCostMEP = _mm3d.ProjCostMEP

def DistDroiteCostMEP(*args) -> "double":
    return _mm3d.DistDroiteCostMEP(*args)
DistDroiteCostMEP = _mm3d.DistDroiteCostMEP

def PVCostMEP(*args) -> "double":
    return _mm3d.PVCostMEP(*args)
PVCostMEP = _mm3d.PVCostMEP

def LinearCostMEP(*args) -> "double":
    return _mm3d.LinearCostMEP(*args)
LinearCostMEP = _mm3d.LinearCostMEP

def MedianNuage(aPack: 'ElPackHomologue', aRot: 'ElRotation3D') -> "Pt3dr":
    return _mm3d.MedianNuage(aPack, aRot)
MedianNuage = _mm3d.MedianNuage

def InitPackME(aVP1: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aVP2: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aVPds: 'DoubleVector', aPack: 'ElPackHomologue') -> "void":
    return _mm3d.InitPackME(aVP1, aVP2, aVPds, aPack)
InitPackME = _mm3d.InitPackME
class cInterfBundle2Image(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cInterfBundle2Image, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cInterfBundle2Image, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def ErrInitRobuste(self, aRot: 'ElRotation3D', aProp: 'double'=0.75) -> "double":
        return _mm3d.cInterfBundle2Image_ErrInitRobuste(self, aRot, aProp)

    def OneIterEq(self, aRot: 'ElRotation3D', anErrStd: 'double &') -> "ElRotation3D":
        return _mm3d.cInterfBundle2Image_OneIterEq(self, aRot, anErrStd)

    def ResiduEq(self, aRot: 'ElRotation3D', anErrStd: 'double const &') -> "double":
        return _mm3d.cInterfBundle2Image_ResiduEq(self, aRot, anErrStd)
    if _newclass:
        LineariseAngle = staticmethod(_mm3d.cInterfBundle2Image_LineariseAngle)
    else:
        LineariseAngle = _mm3d.cInterfBundle2Image_LineariseAngle
    if _newclass:
        LinearDet = staticmethod(_mm3d.cInterfBundle2Image_LinearDet)
    else:
        LinearDet = _mm3d.cInterfBundle2Image_LinearDet
    if _newclass:
        Bundle = staticmethod(_mm3d.cInterfBundle2Image_Bundle)
    else:
        Bundle = _mm3d.cInterfBundle2Image_Bundle
    __swig_destroy__ = _mm3d.delete_cInterfBundle2Image
    __del__ = lambda self: None

    def VIB2I_NameType(self) -> "std::string const &":
        return _mm3d.cInterfBundle2Image_VIB2I_NameType(self)

    def VIB2I_PondK(self, aK: 'int const &') -> "double":
        return _mm3d.cInterfBundle2Image_VIB2I_PondK(self, aK)

    def VIB2I_ErrorK(self, aRot: 'ElRotation3D', aK: 'int const &') -> "double":
        return _mm3d.cInterfBundle2Image_VIB2I_ErrorK(self, aRot, aK)

    def VIB2I_AddObsK(self, aK: 'int const &', aPds: 'double const &') -> "double":
        return _mm3d.cInterfBundle2Image_VIB2I_AddObsK(self, aK, aPds)

    def VIB2I_InitNewRot(self, aRot: 'ElRotation3D') -> "void":
        return _mm3d.cInterfBundle2Image_VIB2I_InitNewRot(self, aRot)

    def VIB2I_Solve(self) -> "ElRotation3D":
        return _mm3d.cInterfBundle2Image_VIB2I_Solve(self)
cInterfBundle2Image_swigregister = _mm3d.cInterfBundle2Image_swigregister
cInterfBundle2Image_swigregister(cInterfBundle2Image)

def cInterfBundle2Image_LineariseAngle(aPack: 'ElPackHomologue', aFoc: 'double', UseAccelCste0: 'bool') -> "cInterfBundle2Image *":
    return _mm3d.cInterfBundle2Image_LineariseAngle(aPack, aFoc, UseAccelCste0)
cInterfBundle2Image_LineariseAngle = _mm3d.cInterfBundle2Image_LineariseAngle

def cInterfBundle2Image_LinearDet(aPack: 'ElPackHomologue', aFoc: 'double') -> "cInterfBundle2Image *":
    return _mm3d.cInterfBundle2Image_LinearDet(aPack, aFoc)
cInterfBundle2Image_LinearDet = _mm3d.cInterfBundle2Image_LinearDet

def cInterfBundle2Image_Bundle(aPack: 'ElPackHomologue', aFoc: 'double', UseAccelCoordCste: 'bool') -> "cInterfBundle2Image *":
    return _mm3d.cInterfBundle2Image_Bundle(aPack, aFoc, UseAccelCoordCste)
cInterfBundle2Image_Bundle = _mm3d.cInterfBundle2Image_Bundle

class cResMepCoc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cResMepCoc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cResMepCoc, name)
    __repr__ = _swig_repr

    def __init__(self, aMat: 'ElMatrixr', aCostRPur: 'double', aR: 'ElRotation3D', aCostVraiRot: 'double', aPMed: 'Pt3dr'):
        this = _mm3d.new_cResMepCoc(aMat, aCostRPur, aR, aCostVraiRot, aPMed)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["mMat"] = _mm3d.cResMepCoc_mMat_set
    __swig_getmethods__["mMat"] = _mm3d.cResMepCoc_mMat_get
    if _newclass:
        mMat = _swig_property(_mm3d.cResMepCoc_mMat_get, _mm3d.cResMepCoc_mMat_set)
    __swig_setmethods__["mCostRPure"] = _mm3d.cResMepCoc_mCostRPure_set
    __swig_getmethods__["mCostRPure"] = _mm3d.cResMepCoc_mCostRPure_get
    if _newclass:
        mCostRPure = _swig_property(_mm3d.cResMepCoc_mCostRPure_get, _mm3d.cResMepCoc_mCostRPure_set)
    __swig_setmethods__["mSolRot"] = _mm3d.cResMepCoc_mSolRot_set
    __swig_getmethods__["mSolRot"] = _mm3d.cResMepCoc_mSolRot_get
    if _newclass:
        mSolRot = _swig_property(_mm3d.cResMepCoc_mSolRot_get, _mm3d.cResMepCoc_mSolRot_set)
    __swig_setmethods__["mCostVraiRot"] = _mm3d.cResMepCoc_mCostVraiRot_set
    __swig_getmethods__["mCostVraiRot"] = _mm3d.cResMepCoc_mCostVraiRot_get
    if _newclass:
        mCostVraiRot = _swig_property(_mm3d.cResMepCoc_mCostVraiRot_get, _mm3d.cResMepCoc_mCostVraiRot_set)
    __swig_setmethods__["mPMed"] = _mm3d.cResMepCoc_mPMed_set
    __swig_getmethods__["mPMed"] = _mm3d.cResMepCoc_mPMed_get
    if _newclass:
        mPMed = _swig_property(_mm3d.cResMepCoc_mPMed_get, _mm3d.cResMepCoc_mPMed_set)
    __swig_destroy__ = _mm3d.delete_cResMepCoc
    __del__ = lambda self: None
cResMepCoc_swigregister = _mm3d.cResMepCoc_swigregister
cResMepCoc_swigregister(cResMepCoc)


def MEPCoCentrik(Quick: 'bool', aPack: 'ElPackHomologue', aFoc: 'double', aRef: 'ElRotation3D', Show: 'bool') -> "cResMepCoc":
    return _mm3d.MEPCoCentrik(Quick, aPack, aFoc, aRef, Show)
MEPCoCentrik = _mm3d.MEPCoCentrik

def SysAddEqMatEss(aPds: 'double const &', aP1: 'Pt2dr', aP2: 'Pt2dr', aSys: 'L2SysSurResol &') -> "void":
    return _mm3d.SysAddEqMatEss(aPds, aP1, aP2, aSys)
SysAddEqMatEss = _mm3d.SysAddEqMatEss

def ME_Lign2Mat(aSol: 'double const *') -> "ElMatrix< double >":
    return _mm3d.ME_Lign2Mat(aSol)
ME_Lign2Mat = _mm3d.ME_Lign2Mat

def MatEss2Rot(aMEss: 'ElMatrixr', aPack: 'ElPackHomologue') -> "ElRotation3D":
    return _mm3d.MatEss2Rot(aMEss, aPack)
MatEss2Rot = _mm3d.MatEss2Rot

def DistRot(*args) -> "double":
    return _mm3d.DistRot(*args)
DistRot = _mm3d.DistRot

def NEW_SignInters(aPack: 'ElPackHomologue', aR2to1: 'ElRotation3D', NbP1: 'int &', NbP2: 'int &') -> "double":
    return _mm3d.NEW_SignInters(aPack, aR2to1, NbP1, NbP2)
NEW_SignInters = _mm3d.NEW_SignInters

def NEW_MatEss2Rot(aMEss: 'ElMatrixr', aPack: 'ElPackHomologue', aDistMin: 'double *'=None) -> "ElRotation3D":
    return _mm3d.NEW_MatEss2Rot(aMEss, aPack, aDistMin)
NEW_MatEss2Rot = _mm3d.NEW_MatEss2Rot

def TestBundle3Image(aFoc: 'double', aR12: 'ElRotation3D', aR13: 'ElRotation3D', aH123: 'tMultiplePF const &', aH12: 'tMultiplePF const &', aH13: 'tMultiplePF const &', aH23: 'tMultiplePF const &', aPds3: 'double') -> "void":
    return _mm3d.TestBundle3Image(aFoc, aR12, aR13, aH123, aH12, aH13, aH23, aPds3)
TestBundle3Image = _mm3d.TestBundle3Image
class cParamCtrlSB3I(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cParamCtrlSB3I, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cParamCtrlSB3I, name)
    __repr__ = _swig_repr

    def __init__(self, aNbIter: 'int', FilterOutlayer: 'bool'=True, aResStop: 'double'=-1):
        this = _mm3d.new_cParamCtrlSB3I(aNbIter, FilterOutlayer, aResStop)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_getmethods__["mNbIter"] = _mm3d.cParamCtrlSB3I_mNbIter_get
    if _newclass:
        mNbIter = _swig_property(_mm3d.cParamCtrlSB3I_mNbIter_get)
    __swig_getmethods__["mResiduStop"] = _mm3d.cParamCtrlSB3I_mResiduStop_get
    if _newclass:
        mResiduStop = _swig_property(_mm3d.cParamCtrlSB3I_mResiduStop_get)
    __swig_getmethods__["mFilterOutlayer"] = _mm3d.cParamCtrlSB3I_mFilterOutlayer_get
    if _newclass:
        mFilterOutlayer = _swig_property(_mm3d.cParamCtrlSB3I_mFilterOutlayer_get)
    __swig_setmethods__["mRes3"] = _mm3d.cParamCtrlSB3I_mRes3_set
    __swig_getmethods__["mRes3"] = _mm3d.cParamCtrlSB3I_mRes3_get
    if _newclass:
        mRes3 = _swig_property(_mm3d.cParamCtrlSB3I_mRes3_get, _mm3d.cParamCtrlSB3I_mRes3_set)
    __swig_setmethods__["mRes2"] = _mm3d.cParamCtrlSB3I_mRes2_set
    __swig_getmethods__["mRes2"] = _mm3d.cParamCtrlSB3I_mRes2_get
    if _newclass:
        mRes2 = _swig_property(_mm3d.cParamCtrlSB3I_mRes2_get, _mm3d.cParamCtrlSB3I_mRes2_set)
    __swig_destroy__ = _mm3d.delete_cParamCtrlSB3I
    __del__ = lambda self: None
cParamCtrlSB3I_swigregister = _mm3d.cParamCtrlSB3I_swigregister
cParamCtrlSB3I_swigregister(cParamCtrlSB3I)


def SolveBundle3Image(aFoc: 'double', aR12: 'ElRotation3D', aR13: 'ElRotation3D', aPMed: 'Pt3dr', aBOnH: 'double &', aH123: 'tMultiplePF const &', aH12: 'tMultiplePF const &', aH13: 'tMultiplePF const &', aH23: 'tMultiplePF const &', aPds3: 'double', aParam: 'cParamCtrlSB3I') -> "bool":
    return _mm3d.SolveBundle3Image(aFoc, aR12, aR13, aPMed, aBOnH, aH123, aH12, aH13, aH23, aPds3, aParam)
SolveBundle3Image = _mm3d.SolveBundle3Image

def Merge2Pack(aVP1: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aVP2: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aSeuil: 'int', aPack1: 'ElPackHomologue', aPack2: 'ElPackHomologue') -> "void":
    return _mm3d.Merge2Pack(aVP1, aVP2, aSeuil, aPack1, aPack2)
Merge2Pack = _mm3d.Merge2Pack

def Merge3Pack(aVP1: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aVP2: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aVP3: 'std::vector< Pt2dr,std::allocator< Pt2dr > > &', aSeuil: 'int', aV12: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', aV21: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', aV13: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', aV31: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', aV23: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', aV32: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &') -> "void":
    return _mm3d.Merge3Pack(aVP1, aVP2, aVP3, aSeuil, aV12, aV21, aV13, aV31, aV23, aV32)
Merge3Pack = _mm3d.Merge3Pack

def VRotB3(aR12: 'ElRotation3D', aR13: 'ElRotation3D') -> "std::vector< ElRotation3D,std::allocator< ElRotation3D > >":
    return _mm3d.VRotB3(aR12, aR13)
VRotB3 = _mm3d.VRotB3

def QualInterSeg(aVR: 'std::vector< ElRotation3D,std::allocator< ElRotation3D > > const &', aVPMul: 'tMultiplePF const &') -> "double":
    return _mm3d.QualInterSeg(aVR, aVPMul)
QualInterSeg = _mm3d.QualInterSeg

def InterSeg(aVR: 'std::vector< ElRotation3D,std::allocator< ElRotation3D > > const &', aVP: 'std::vector< Pt2dr,std::allocator< Pt2dr > > const &', Ok: 'bool &', aResidu: 'double *') -> "Pt3dr":
    return _mm3d.InterSeg(aVR, aVP, Ok, aResidu)
InterSeg = _mm3d.InterSeg

def OrientTomasiKanade(aPrec: 'double &', aVPF3: 'tMultiplePF const &', aNbMin: 'int', aNbMax: 'int', aPrecCible: 'double', aVRotInit: 'std::vector< ElRotation3D,std::allocator< ElRotation3D > > *') -> "std::vector< ElRotation3D,std::allocator< ElRotation3D > >":
    return _mm3d.OrientTomasiKanade(aPrec, aVPF3, aNbMin, aNbMax, aPrecCible, aVRotInit)
OrientTomasiKanade = _mm3d.OrientTomasiKanade
NbCamTest = _mm3d.NbCamTest
NbRecHom = _mm3d.NbRecHom
NbMinPts2Im = _mm3d.NbMinPts2Im
NbMinPts2Im_AllSel = _mm3d.NbMinPts2Im_AllSel
TNbCaseP1 = _mm3d.TNbCaseP1
TQuant = _mm3d.TQuant
TQuantBsH = _mm3d.TQuantBsH
TBSurHLim = _mm3d.TBSurHLim
TAttenDens = _mm3d.TAttenDens
TGainSeuil = _mm3d.TGainSeuil
NbMaxATT = _mm3d.NbMaxATT
FactAttCohMed = _mm3d.FactAttCohMed

def ToStdPack(arg1: 'tMergeLPackH const *', PondInvNorm: 'bool', PdsSingle: 'double'=0.1) -> "ElPackHomologue":
    return _mm3d.ToStdPack(arg1, PondInvNorm, PdsSingle)
ToStdPack = _mm3d.ToStdPack

def PackReduit(*args) -> "ElPackHomologue":
    return _mm3d.PackReduit(*args)
PackReduit = _mm3d.PackReduit
class cCommonMartiniAppli(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cCommonMartiniAppli, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cCommonMartiniAppli, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mNameOriCalib"] = _mm3d.cCommonMartiniAppli_mNameOriCalib_set
    __swig_getmethods__["mNameOriCalib"] = _mm3d.cCommonMartiniAppli_mNameOriCalib_get
    if _newclass:
        mNameOriCalib = _swig_property(_mm3d.cCommonMartiniAppli_mNameOriCalib_get, _mm3d.cCommonMartiniAppli_mNameOriCalib_set)
    __swig_setmethods__["mPrefHom"] = _mm3d.cCommonMartiniAppli_mPrefHom_set
    __swig_getmethods__["mPrefHom"] = _mm3d.cCommonMartiniAppli_mPrefHom_get
    if _newclass:
        mPrefHom = _swig_property(_mm3d.cCommonMartiniAppli_mPrefHom_get, _mm3d.cCommonMartiniAppli_mPrefHom_set)
    __swig_setmethods__["mExtName"] = _mm3d.cCommonMartiniAppli_mExtName_set
    __swig_getmethods__["mExtName"] = _mm3d.cCommonMartiniAppli_mExtName_get
    if _newclass:
        mExtName = _swig_property(_mm3d.cCommonMartiniAppli_mExtName_get, _mm3d.cCommonMartiniAppli_mExtName_set)
    __swig_setmethods__["mExpTxt"] = _mm3d.cCommonMartiniAppli_mExpTxt_set
    __swig_getmethods__["mExpTxt"] = _mm3d.cCommonMartiniAppli_mExpTxt_get
    if _newclass:
        mExpTxt = _swig_property(_mm3d.cCommonMartiniAppli_mExpTxt_get, _mm3d.cCommonMartiniAppli_mExpTxt_set)
    __swig_setmethods__["mInOri"] = _mm3d.cCommonMartiniAppli_mInOri_set
    __swig_getmethods__["mInOri"] = _mm3d.cCommonMartiniAppli_mInOri_get
    if _newclass:
        mInOri = _swig_property(_mm3d.cCommonMartiniAppli_mInOri_get, _mm3d.cCommonMartiniAppli_mInOri_set)
    __swig_setmethods__["mOriOut"] = _mm3d.cCommonMartiniAppli_mOriOut_set
    __swig_getmethods__["mOriOut"] = _mm3d.cCommonMartiniAppli_mOriOut_get
    if _newclass:
        mOriOut = _swig_property(_mm3d.cCommonMartiniAppli_mOriOut_get, _mm3d.cCommonMartiniAppli_mOriOut_set)
    __swig_setmethods__["mOriGPS"] = _mm3d.cCommonMartiniAppli_mOriGPS_set
    __swig_getmethods__["mOriGPS"] = _mm3d.cCommonMartiniAppli_mOriGPS_get
    if _newclass:
        mOriGPS = _swig_property(_mm3d.cCommonMartiniAppli_mOriGPS_get, _mm3d.cCommonMartiniAppli_mOriGPS_set)
    __swig_setmethods__["mOriCheck"] = _mm3d.cCommonMartiniAppli_mOriCheck_set
    __swig_getmethods__["mOriCheck"] = _mm3d.cCommonMartiniAppli_mOriCheck_get
    if _newclass:
        mOriCheck = _swig_property(_mm3d.cCommonMartiniAppli_mOriCheck_get, _mm3d.cCommonMartiniAppli_mOriCheck_set)
    __swig_setmethods__["mDebug"] = _mm3d.cCommonMartiniAppli_mDebug_set
    __swig_getmethods__["mDebug"] = _mm3d.cCommonMartiniAppli_mDebug_get
    if _newclass:
        mDebug = _swig_property(_mm3d.cCommonMartiniAppli_mDebug_get, _mm3d.cCommonMartiniAppli_mDebug_set)
    __swig_setmethods__["mAcceptUnSym"] = _mm3d.cCommonMartiniAppli_mAcceptUnSym_set
    __swig_getmethods__["mAcceptUnSym"] = _mm3d.cCommonMartiniAppli_mAcceptUnSym_get
    if _newclass:
        mAcceptUnSym = _swig_property(_mm3d.cCommonMartiniAppli_mAcceptUnSym_get, _mm3d.cCommonMartiniAppli_mAcceptUnSym_set)
    __swig_setmethods__["mQuick"] = _mm3d.cCommonMartiniAppli_mQuick_set
    __swig_getmethods__["mQuick"] = _mm3d.cCommonMartiniAppli_mQuick_get
    if _newclass:
        mQuick = _swig_property(_mm3d.cCommonMartiniAppli_mQuick_get, _mm3d.cCommonMartiniAppli_mQuick_set)
    __swig_setmethods__["mShow"] = _mm3d.cCommonMartiniAppli_mShow_set
    __swig_getmethods__["mShow"] = _mm3d.cCommonMartiniAppli_mShow_get
    if _newclass:
        mShow = _swig_property(_mm3d.cCommonMartiniAppli_mShow_get, _mm3d.cCommonMartiniAppli_mShow_set)
    __swig_setmethods__["mTStdNbMaxTriplet"] = _mm3d.cCommonMartiniAppli_mTStdNbMaxTriplet_set
    __swig_getmethods__["mTStdNbMaxTriplet"] = _mm3d.cCommonMartiniAppli_mTStdNbMaxTriplet_get
    if _newclass:
        mTStdNbMaxTriplet = _swig_property(_mm3d.cCommonMartiniAppli_mTStdNbMaxTriplet_get, _mm3d.cCommonMartiniAppli_mTStdNbMaxTriplet_set)
    __swig_setmethods__["mTQuickNbMaxTriplet"] = _mm3d.cCommonMartiniAppli_mTQuickNbMaxTriplet_set
    __swig_getmethods__["mTQuickNbMaxTriplet"] = _mm3d.cCommonMartiniAppli_mTQuickNbMaxTriplet_get
    if _newclass:
        mTQuickNbMaxTriplet = _swig_property(_mm3d.cCommonMartiniAppli_mTQuickNbMaxTriplet_get, _mm3d.cCommonMartiniAppli_mTQuickNbMaxTriplet_set)
    __swig_setmethods__["mTNbMinTriplet"] = _mm3d.cCommonMartiniAppli_mTNbMinTriplet_set
    __swig_getmethods__["mTNbMinTriplet"] = _mm3d.cCommonMartiniAppli_mTNbMinTriplet_get
    if _newclass:
        mTNbMinTriplet = _swig_property(_mm3d.cCommonMartiniAppli_mTNbMinTriplet_get, _mm3d.cCommonMartiniAppli_mTNbMinTriplet_set)

    def ModeNO(self) -> "eTypeModeNO":
        return _mm3d.cCommonMartiniAppli_ModeNO(self)

    def NM(self, aDir: 'std::string const &') -> "cNewO_NameManager *":
        return _mm3d.cCommonMartiniAppli_NM(self, aDir)

    def ArgCMA(self) -> "LArgMain &":
        return _mm3d.cCommonMartiniAppli_ArgCMA(self)

    def ComParam(self) -> "std::string":
        return _mm3d.cCommonMartiniAppli_ComParam(self)

    def __init__(self):
        this = _mm3d.new_cCommonMartiniAppli()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GpsIsInit(self) -> "bool":
        return _mm3d.cCommonMartiniAppli_GpsIsInit(self)

    def CheckIsInit(self) -> "bool":
        return _mm3d.cCommonMartiniAppli_CheckIsInit(self)

    def GpsVal(self, arg2: 'cNewO_OneIm') -> "Pt3dr":
        return _mm3d.cCommonMartiniAppli_GpsVal(self, arg2)

    def CamCheck(self, arg2: 'cNewO_OneIm') -> "CamStenope *":
        return _mm3d.cCommonMartiniAppli_CamCheck(self, arg2)
    __swig_destroy__ = _mm3d.delete_cCommonMartiniAppli
    __del__ = lambda self: None
cCommonMartiniAppli_swigregister = _mm3d.cCommonMartiniAppli_swigregister
cCommonMartiniAppli_swigregister(cCommonMartiniAppli)

class cNewO_OneIm(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cNewO_OneIm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cNewO_OneIm, name)
    __repr__ = _swig_repr

    def __init__(self, aNM: 'cNewO_NameManager', aName: 'std::string const &', WithOri: 'bool'=True):
        this = _mm3d.new_cNewO_OneIm(aNM, aName, WithOri)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CS(self) -> "CamStenope *":
        return _mm3d.cNewO_OneIm_CS(self)

    def Name(self) -> "std::string const &":
        return _mm3d.cNewO_OneIm_Name(self)

    def NM(self, *args) -> "cNewO_NameManager &":
        return _mm3d.cNewO_OneIm_NM(self, *args)
    __swig_destroy__ = _mm3d.delete_cNewO_OneIm
    __del__ = lambda self: None
cNewO_OneIm_swigregister = _mm3d.cNewO_OneIm_swigregister
cNewO_OneIm_swigregister(cNewO_OneIm)

class cNOCompPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cNOCompPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cNOCompPair, name)
    __repr__ = _swig_repr

    def __init__(self, aP1: 'Pt2dr', aP2: 'Pt2dr', aPds: 'double const &'):
        this = _mm3d.new_cNOCompPair(aP1, aP2, aPds)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["mP1"] = _mm3d.cNOCompPair_mP1_set
    __swig_getmethods__["mP1"] = _mm3d.cNOCompPair_mP1_get
    if _newclass:
        mP1 = _swig_property(_mm3d.cNOCompPair_mP1_get, _mm3d.cNOCompPair_mP1_set)
    __swig_setmethods__["mP2"] = _mm3d.cNOCompPair_mP2_set
    __swig_getmethods__["mP2"] = _mm3d.cNOCompPair_mP2_get
    if _newclass:
        mP2 = _swig_property(_mm3d.cNOCompPair_mP2_get, _mm3d.cNOCompPair_mP2_set)
    __swig_setmethods__["mPds"] = _mm3d.cNOCompPair_mPds_set
    __swig_getmethods__["mPds"] = _mm3d.cNOCompPair_mPds_get
    if _newclass:
        mPds = _swig_property(_mm3d.cNOCompPair_mPds_get, _mm3d.cNOCompPair_mPds_set)
    __swig_setmethods__["mLastPdsOfErr"] = _mm3d.cNOCompPair_mLastPdsOfErr_set
    __swig_getmethods__["mLastPdsOfErr"] = _mm3d.cNOCompPair_mLastPdsOfErr_get
    if _newclass:
        mLastPdsOfErr = _swig_property(_mm3d.cNOCompPair_mLastPdsOfErr_get, _mm3d.cNOCompPair_mLastPdsOfErr_set)
    __swig_setmethods__["mQ1"] = _mm3d.cNOCompPair_mQ1_set
    __swig_getmethods__["mQ1"] = _mm3d.cNOCompPair_mQ1_get
    if _newclass:
        mQ1 = _swig_property(_mm3d.cNOCompPair_mQ1_get, _mm3d.cNOCompPair_mQ1_set)
    __swig_setmethods__["mQ2"] = _mm3d.cNOCompPair_mQ2_set
    __swig_getmethods__["mQ2"] = _mm3d.cNOCompPair_mQ2_get
    if _newclass:
        mQ2 = _swig_property(_mm3d.cNOCompPair_mQ2_get, _mm3d.cNOCompPair_mQ2_set)
    __swig_setmethods__["mQ2R"] = _mm3d.cNOCompPair_mQ2R_set
    __swig_getmethods__["mQ2R"] = _mm3d.cNOCompPair_mQ2R_get
    if _newclass:
        mQ2R = _swig_property(_mm3d.cNOCompPair_mQ2R_get, _mm3d.cNOCompPair_mQ2R_set)
    __swig_setmethods__["mU1vQ2R"] = _mm3d.cNOCompPair_mU1vQ2R_set
    __swig_getmethods__["mU1vQ2R"] = _mm3d.cNOCompPair_mU1vQ2R_get
    if _newclass:
        mU1vQ2R = _swig_property(_mm3d.cNOCompPair_mU1vQ2R_get, _mm3d.cNOCompPair_mU1vQ2R_set)
    __swig_destroy__ = _mm3d.delete_cNOCompPair
    __del__ = lambda self: None
cNOCompPair_swigregister = _mm3d.cNOCompPair_swigregister
cNOCompPair_swigregister(cNOCompPair)

class cNewO_OrInit2Im(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cNewO_OrInit2Im, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cNewO_OrInit2Im, name)
    __repr__ = _swig_repr

    def __init__(self, GenereOri: 'bool', aQuick: 'bool', aI1: 'cNewO_OneIm', aI2: 'cNewO_OneIm', aMergeTieP: 'tMergeLPackH *', aTestSol: 'ElRotation3D', aInOri: 'ElRotation3D', Show: 'bool', aHPP: 'bool', aSelAllIm: 'bool', arg12: 'cCommonMartiniAppli'):
        this = _mm3d.new_cNewO_OrInit2Im(GenereOri, aQuick, aI1, aI2, aMergeTieP, aTestSol, aInOri, Show, aHPP, aSelAllIm, arg12)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ExactCost(self, aRot: 'ElRotation3D', aTetaMax: 'double') -> "double":
        return _mm3d.cNewO_OrInit2Im_ExactCost(self, aRot, aTetaMax)

    def PixExactCost(self, aRot: 'ElRotation3D', aTetaMax: 'double') -> "double":
        return _mm3d.cNewO_OrInit2Im_PixExactCost(self, aRot, aTetaMax)

    def XmlRes(self) -> "cXml_Ori2Im const &":
        return _mm3d.cNewO_OrInit2Im_XmlRes(self)

    def DoExpMM(self, *args) -> "void":
        return _mm3d.cNewO_OrInit2Im_DoExpMM(self, *args)
    __swig_destroy__ = _mm3d.delete_cNewO_OrInit2Im
    __del__ = lambda self: None
cNewO_OrInit2Im_swigregister = _mm3d.cNewO_OrInit2Im_swigregister
cNewO_OrInit2Im_swigregister(cNewO_OrInit2Im)

class cNewO_NameManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cNewO_NameManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cNewO_NameManager, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _mm3d.new_cNewO_NameManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CamOfName(self, aName: 'std::string const &') -> "CamStenope *":
        return _mm3d.cNewO_NameManager_CamOfName(self, aName)

    def PackOfName(self, aN1: 'std::string const &', aN2: 'std::string const &') -> "ElPackHomologue":
        return _mm3d.cNewO_NameManager_PackOfName(self, aN1, aN2)

    def NameOriOut(self, aNameIm: 'std::string const &') -> "std::string":
        return _mm3d.cNewO_NameManager_NameOriOut(self, aNameIm)

    def KeySetCpleOri(self) -> "std::string":
        return _mm3d.cNewO_NameManager_KeySetCpleOri(self)

    def KeyAssocCpleOri(self) -> "std::string":
        return _mm3d.cNewO_NameManager_KeyAssocCpleOri(self)

    def NameXmlOri2Im(self, *args) -> "std::string":
        return _mm3d.cNewO_NameManager_NameXmlOri2Im(self, *args)

    def GetOri2Im(self, aN1: 'std::string const &', aN2: 'std::string const &') -> "cXml_Ori2Im":
        return _mm3d.cNewO_NameManager_GetOri2Im(self, aN1, aN2)

    def NameTimingOri2Im(self) -> "std::string":
        return _mm3d.cNewO_NameManager_NameTimingOri2Im(self)

    def Dir(self) -> "std::string const &":
        return _mm3d.cNewO_NameManager_Dir(self)

    def CamOriOfName(self, aName: 'std::string const &', anOri: 'std::string const &') -> "CamStenope *":
        return _mm3d.cNewO_NameManager_CamOriOfName(self, aName, anOri)

    def CamOriOfNameSVP(self, aName: 'std::string const &', anOri: 'std::string const &') -> "CamStenope *":
        return _mm3d.cNewO_NameManager_CamOriOfNameSVP(self, aName, anOri)

    def OriCal(self) -> "std::string const &":
        return _mm3d.cNewO_NameManager_OriCal(self)

    def OriOut(self) -> "std::string const &":
        return _mm3d.cNewO_NameManager_OriOut(self)

    def ICNM(self) -> "cInterfChantierNameManipulateur *":
        return _mm3d.cNewO_NameManager_ICNM(self)

    def Dir3P(self, WithMakeDir: 'bool'=False) -> "std::string":
        return _mm3d.cNewO_NameManager_Dir3P(self, WithMakeDir)

    def Dir3POneImage(self, *args) -> "std::string":
        return _mm3d.cNewO_NameManager_Dir3POneImage(self, *args)

    def ListeCompleteTripletTousOri(self, aN1: 'std::string const &', aN2: 'std::string const &') -> "std::list< std::string,std::allocator< std::string > >":
        return _mm3d.cNewO_NameManager_ListeCompleteTripletTousOri(self, aN1, aN2)

    def NameTripletsOfCple(self, arg2: 'cNewO_OneIm', arg3: 'cNewO_OneIm', Bin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameTripletsOfCple(self, arg2, arg3, Bin)

    def Dir3PDeuxImage(self, *args) -> "std::string":
        return _mm3d.cNewO_NameManager_Dir3PDeuxImage(self, *args)

    def NameHomFloat(self, *args) -> "std::string":
        return _mm3d.cNewO_NameManager_NameHomFloat(self, *args)

    def NameListeImOrientedWith(self, arg2: 'std::string const &', Bin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameListeImOrientedWith(self, arg2, Bin)

    def RecNameListeImOrientedWith(self, arg2: 'std::string const &', Bin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_RecNameListeImOrientedWith(self, arg2, Bin)

    def ListeImOrientedWith(self, aName: 'std::string const &') -> "std::list< std::string,std::allocator< std::string > >":
        return _mm3d.cNewO_NameManager_ListeImOrientedWith(self, aName)

    def Liste2SensImOrientedWith(self, aName: 'std::string const &') -> "std::list< std::string,std::allocator< std::string > >":
        return _mm3d.cNewO_NameManager_Liste2SensImOrientedWith(self, aName)

    def OutPutCamera(self, aName: 'std::string const &') -> "CamStenope *":
        return _mm3d.cNewO_NameManager_OutPutCamera(self, aName)

    def CalibrationCamera(self, aName: 'std::string const &') -> "CamStenope *":
        return _mm3d.cNewO_NameManager_CalibrationCamera(self, aName)

    def CamOriRel(self, aN1: 'std::string const &', aN2: 'std::string const &') -> "std::pair< CamStenope *,CamStenope * >":
        return _mm3d.cNewO_NameManager_CamOriRel(self, aN1, aN2)

    def ResVINM(self, arg2: 'std::string const &', arg3: 'std::string const &') -> "cResVINM":
        return _mm3d.cNewO_NameManager_ResVINM(self, arg2, arg3)

    def OriCam2On1(self, aN1: 'std::string const &', aN2: 'std::string const &', OK: 'bool &') -> "ElRotation3D":
        return _mm3d.cNewO_NameManager_OriCam2On1(self, aN1, aN2, OK)

    def NameListeCpleOriented(self, Bin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameListeCpleOriented(self, Bin)

    def NameListeCpleConnected(self, Bin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameListeCpleConnected(self, Bin)

    def NameRatafiaSom(self, aName: 'std::string const &', Bin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameRatafiaSom(self, aName, Bin)

    def OriRelTripletFromExisting(self, Ori: 'std::string const &', aNameI1: 'std::string const &', aNameI2: 'std::string const &', aNameI3: 'std::string const &', Ok: 'bool &') -> "std::pair< ElRotation3D,ElRotation3D >":
        return _mm3d.cNewO_NameManager_OriRelTripletFromExisting(self, Ori, aNameI1, aNameI2, aNameI3, Ok)

    def LoadHomFloats(self, *args) -> "void":
        return _mm3d.cNewO_NameManager_LoadHomFloats(self, *args)

    def GenLoadHomFloats(self, aNameH: 'std::string const &', aVP1: 'std::vector< Pt2df,std::allocator< Pt2df > > *', aVP2: 'std::vector< Pt2df,std::allocator< Pt2df > > *', SVP: 'bool') -> "void":
        return _mm3d.cNewO_NameManager_GenLoadHomFloats(self, aNameH, aVP1, aVP2, SVP)

    def NameHomTriplet(self, *args) -> "std::string":
        return _mm3d.cNewO_NameManager_NameHomTriplet(self, *args)

    def NameOriInitTriplet(self, ModeBin: 'bool', arg3: 'cNewO_OneIm', arg4: 'cNewO_OneIm', arg5: 'cNewO_OneIm', WithMakeDir: 'bool'=False) -> "std::string":
        return _mm3d.cNewO_NameManager_NameOriInitTriplet(self, ModeBin, arg3, arg4, arg5, WithMakeDir)

    def NameOriOptimTriplet(self, *args) -> "std::string":
        return _mm3d.cNewO_NameManager_NameOriOptimTriplet(self, *args)

    def NameOriGenTriplet(self, Quick: 'bool', ModeBin: 'bool', arg4: 'cNewO_OneIm', arg5: 'cNewO_OneIm', arg6: 'cNewO_OneIm') -> "std::string":
        return _mm3d.cNewO_NameManager_NameOriGenTriplet(self, Quick, ModeBin, arg4, arg5, arg6)

    def NameTopoTriplet(self, ModeBin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameTopoTriplet(self, ModeBin)

    def NameCpleOfTopoTriplet(self, ModeBin: 'bool') -> "std::string":
        return _mm3d.cNewO_NameManager_NameCpleOfTopoTriplet(self, ModeBin)

    def LoadTriplet(self, *args) -> "bool":
        return _mm3d.cNewO_NameManager_LoadTriplet(self, *args)

    def WriteTriplet(self, aNameFile: 'std::string const &', arg3: 'tCVP2f &', arg4: 'tCVP2f &', arg5: 'tCVP2f &', arg6: 'tCVUI1 &') -> "void":
        return _mm3d.cNewO_NameManager_WriteTriplet(self, aNameFile, arg3, arg4, arg5, arg6)

    def WriteCouple(self, aNameFile: 'std::string const &', arg3: 'tCVP2f &', arg4: 'tCVP2f &', arg5: 'tCVUI1 &') -> "void":
        return _mm3d.cNewO_NameManager_WriteCouple(self, aNameFile, arg3, arg4, arg5)
    __swig_destroy__ = _mm3d.delete_cNewO_NameManager
    __del__ = lambda self: None
cNewO_NameManager_swigregister = _mm3d.cNewO_NameManager_swigregister
cNewO_NameManager_swigregister(cNewO_NameManager)


def AddSegOfRot(aV1: 'std::vector< Pt3dr,std::allocator< Pt3dr > > &', aV2: 'std::vector< Pt3dr,std::allocator< Pt3dr > > &', aR: 'ElRotation3D', aP: 'Pt2df const &') -> "void":
    return _mm3d.AddSegOfRot(aV1, aV2, aR, aP)
AddSegOfRot = _mm3d.AddSegOfRot

def Residu(anIm: 'cNewO_OneIm', aR: 'ElRotation3D', aPTer: 'Pt3dr', aP: 'Pt2df const &') -> "double":
    return _mm3d.Residu(anIm, aR, aPTer, aP)
Residu = _mm3d.Residu
class cResIPR(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cResIPR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cResIPR, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mVSel"] = _mm3d.cResIPR_mVSel_set
    __swig_getmethods__["mVSel"] = _mm3d.cResIPR_mVSel_get
    if _newclass:
        mVSel = _swig_property(_mm3d.cResIPR_mVSel_get, _mm3d.cResIPR_mVSel_set)
    __swig_setmethods__["mMoyDistNN"] = _mm3d.cResIPR_mMoyDistNN_set
    __swig_getmethods__["mMoyDistNN"] = _mm3d.cResIPR_mMoyDistNN_get
    if _newclass:
        mMoyDistNN = _swig_property(_mm3d.cResIPR_mMoyDistNN_get, _mm3d.cResIPR_mMoyDistNN_set)

    def __init__(self):
        this = _mm3d.new_cResIPR()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cResIPR
    __del__ = lambda self: None
cResIPR_swigregister = _mm3d.cResIPR_swigregister
cResIPR_swigregister(cResIPR)


def cResIPRIdent(aNb: 'int') -> "cResIPR":
    return _mm3d.cResIPRIdent(aNb)
cResIPRIdent = _mm3d.cResIPRIdent

def IndPackReduit(*args) -> "cResIPR":
    return _mm3d.IndPackReduit(*args)
IndPackReduit = _mm3d.IndPackReduit

def ToTypeNO(arg1: 'std::string const &') -> "eTypeModeNO":
    return _mm3d.ToTypeNO(arg1)
ToTypeNO = _mm3d.ToTypeNO
class cExeParalByPaquets(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cExeParalByPaquets, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cExeParalByPaquets, name)
    __repr__ = _swig_repr

    def __init__(self, aMes: 'std::string const &', anEstimNbCom: 'int'):
        this = _mm3d.new_cExeParalByPaquets(aMes, anEstimNbCom)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCom(self, aCom: 'std::string const &') -> "void":
        return _mm3d.cExeParalByPaquets_AddCom(self, aCom)
    __swig_destroy__ = _mm3d.delete_cExeParalByPaquets
    __del__ = lambda self: None
cExeParalByPaquets_swigregister = _mm3d.cExeParalByPaquets_swigregister
cExeParalByPaquets_swigregister(cExeParalByPaquets)
TheStdModeNewOri = cvar.TheStdModeNewOri


def DefaultCamera(aName: 'std::string const &') -> "CamStenope *":
    return _mm3d.DefaultCamera(aName)
DefaultCamera = _mm3d.DefaultCamera

def MakeFileXML(*args) -> "void":
    return _mm3d.MakeFileXML(*args)
MakeFileXML = _mm3d.MakeFileXML
class cXml_TopoTriplet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cXml_TopoTriplet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cXml_TopoTriplet, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mGXml"] = _mm3d.cXml_TopoTriplet_mGXml_set
    __swig_getmethods__["mGXml"] = _mm3d.cXml_TopoTriplet_mGXml_get
    if _newclass:
        mGXml = _swig_property(_mm3d.cXml_TopoTriplet_mGXml_get, _mm3d.cXml_TopoTriplet_mGXml_set)

    def Triplets(self, *args) -> "std::list< cXml_OneTriplet,std::allocator< cXml_OneTriplet > > const &":
        return _mm3d.cXml_TopoTriplet_Triplets(self, *args)

    def __init__(self):
        this = _mm3d.new_cXml_TopoTriplet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cXml_TopoTriplet
    __del__ = lambda self: None
cXml_TopoTriplet_swigregister = _mm3d.cXml_TopoTriplet_swigregister
cXml_TopoTriplet_swigregister(cXml_TopoTriplet)

class cXml_OneTriplet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cXml_OneTriplet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cXml_OneTriplet, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mGXml"] = _mm3d.cXml_OneTriplet_mGXml_set
    __swig_getmethods__["mGXml"] = _mm3d.cXml_OneTriplet_mGXml_get
    if _newclass:
        mGXml = _swig_property(_mm3d.cXml_OneTriplet_mGXml_get, _mm3d.cXml_OneTriplet_mGXml_set)

    def Name1(self) -> "std::string":
        return _mm3d.cXml_OneTriplet_Name1(self)

    def Name2(self) -> "std::string":
        return _mm3d.cXml_OneTriplet_Name2(self)

    def Name3(self) -> "std::string":
        return _mm3d.cXml_OneTriplet_Name3(self)

    def __init__(self):
        this = _mm3d.new_cXml_OneTriplet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cXml_OneTriplet
    __del__ = lambda self: None
cXml_OneTriplet_swigregister = _mm3d.cXml_OneTriplet_swigregister
cXml_OneTriplet_swigregister(cXml_OneTriplet)

class cXml_Ori3ImInit(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cXml_Ori3ImInit, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cXml_Ori3ImInit, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mGXml"] = _mm3d.cXml_Ori3ImInit_mGXml_set
    __swig_getmethods__["mGXml"] = _mm3d.cXml_Ori3ImInit_mGXml_get
    if _newclass:
        mGXml = _swig_property(_mm3d.cXml_Ori3ImInit_mGXml_get, _mm3d.cXml_Ori3ImInit_mGXml_set)

    def Ori2On1(self, *args) -> "cXml_Rotation const &":
        return _mm3d.cXml_Ori3ImInit_Ori2On1(self, *args)

    def Ori3On1(self, *args) -> "cXml_Rotation const &":
        return _mm3d.cXml_Ori3ImInit_Ori3On1(self, *args)

    def NbTriplet(self) -> "int":
        return _mm3d.cXml_Ori3ImInit_NbTriplet(self)

    def ResiduTriplet(self, *args) -> "double const &":
        return _mm3d.cXml_Ori3ImInit_ResiduTriplet(self, *args)

    def BSurH(self) -> "double":
        return _mm3d.cXml_Ori3ImInit_BSurH(self)

    def PMed(self, *args) -> "Pt3dr const &":
        return _mm3d.cXml_Ori3ImInit_PMed(self, *args)

    def Elips(self, *args) -> "cXml_Elips3D const &":
        return _mm3d.cXml_Ori3ImInit_Elips(self, *args)

    def __init__(self):
        this = _mm3d.new_cXml_Ori3ImInit()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cXml_Ori3ImInit
    __del__ = lambda self: None
cXml_Ori3ImInit_swigregister = _mm3d.cXml_Ori3ImInit_swigregister
cXml_Ori3ImInit_swigregister(cXml_Ori3ImInit)

class cXml_Rotation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cXml_Rotation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cXml_Rotation, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mGXml"] = _mm3d.cXml_Rotation_mGXml_set
    __swig_getmethods__["mGXml"] = _mm3d.cXml_Rotation_mGXml_get
    if _newclass:
        mGXml = _swig_property(_mm3d.cXml_Rotation_mGXml_get, _mm3d.cXml_Rotation_mGXml_set)

    def Ori(self) -> "cTypeCodageMatr":
        return _mm3d.cXml_Rotation_Ori(self)

    def Centre(self) -> "Pt3dr":
        return _mm3d.cXml_Rotation_Centre(self)

    def __init__(self):
        this = _mm3d.new_cXml_Rotation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cXml_Rotation
    __del__ = lambda self: None
cXml_Rotation_swigregister = _mm3d.cXml_Rotation_swigregister
cXml_Rotation_swigregister(cXml_Rotation)

class cTypeCodageMatr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cTypeCodageMatr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cTypeCodageMatr, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mGXml"] = _mm3d.cTypeCodageMatr_mGXml_set
    __swig_getmethods__["mGXml"] = _mm3d.cTypeCodageMatr_mGXml_get
    if _newclass:
        mGXml = _swig_property(_mm3d.cTypeCodageMatr_mGXml_get, _mm3d.cTypeCodageMatr_mGXml_set)

    def L1(self) -> "Pt3dr":
        return _mm3d.cTypeCodageMatr_L1(self)

    def L2(self) -> "Pt3dr":
        return _mm3d.cTypeCodageMatr_L2(self)

    def L3(self) -> "Pt3dr":
        return _mm3d.cTypeCodageMatr_L3(self)

    def TrueRot(self, *args) -> "cTplValGesInit< bool > const &":
        return _mm3d.cTypeCodageMatr_TrueRot(self, *args)

    def __init__(self):
        this = _mm3d.new_cTypeCodageMatr()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_cTypeCodageMatr
    __del__ = lambda self: None
cTypeCodageMatr_swigregister = _mm3d.cTypeCodageMatr_swigregister
cTypeCodageMatr_swigregister(cTypeCodageMatr)

def xml_init(*args) -> "void":
    return _mm3d.xml_init(*args)
xml_init = _mm3d.xml_init

class Pt2di(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pt2di, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pt2di, name)
    if _newclass:
        El0 = staticmethod(_mm3d.Pt2di_El0)
    else:
        El0 = _mm3d.Pt2di_El0
    __swig_setmethods__["x"] = _mm3d.Pt2di_x_set
    __swig_getmethods__["x"] = _mm3d.Pt2di_x_get
    if _newclass:
        x = _swig_property(_mm3d.Pt2di_x_get, _mm3d.Pt2di_x_set)
    __swig_setmethods__["y"] = _mm3d.Pt2di_y_set
    __swig_getmethods__["y"] = _mm3d.Pt2di_y_get
    if _newclass:
        y = _swig_property(_mm3d.Pt2di_y_get, _mm3d.Pt2di_y_set)

    def __init__(self, *args):
        this = _mm3d.new_Pt2di(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        IP2ToThisT = staticmethod(_mm3d.Pt2di_IP2ToThisT)
    else:
        IP2ToThisT = _mm3d.Pt2di_IP2ToThisT
    if _newclass:
        RP2ToThisT = staticmethod(_mm3d.Pt2di_RP2ToThisT)
    else:
        RP2ToThisT = _mm3d.Pt2di_RP2ToThisT
    if _newclass:
        FP2ToThisT = staticmethod(_mm3d.Pt2di_FP2ToThisT)
    else:
        FP2ToThisT = _mm3d.Pt2di_FP2ToThisT
    if _newclass:
        FromPolar = staticmethod(_mm3d.Pt2di_FromPolar)
    else:
        FromPolar = _mm3d.Pt2di_FromPolar
    if _newclass:
        polar = staticmethod(_mm3d.Pt2di_polar)
    else:
        polar = _mm3d.Pt2di_polar

    def ToPtProvR(self) -> "Pt2d< int >::TypeProvPtScalR":
        return _mm3d.Pt2di_ToPtProvR(self)

    def __neg__(self) -> "Pt2d< int >":
        return _mm3d.Pt2di___neg__(self)

    def yx(self) -> "Pt2d< int >":
        return _mm3d.Pt2di_yx(self)

    def conj(self) -> "Pt2d< int >":
        return _mm3d.Pt2di_conj(self)

    def inv(self) -> "Pt2d< ElStdTypeScal< int >::TypeScalReel >":
        return _mm3d.Pt2di_inv(self)

    def Square(self) -> "Pt2d< int >":
        return _mm3d.Pt2di_Square(self)

    def XtY(self) -> "int":
        return _mm3d.Pt2di_XtY(self)

    def __add__(self, p2: 'Pt2di') -> "Pt2d< int >":
        return _mm3d.Pt2di___add__(self, p2)

    def __sub__(self, p2: 'Pt2di') -> "Pt2d< int >":
        return _mm3d.Pt2di___sub__(self, p2)

    def mcbyc(self, p2: 'Pt2di') -> "Pt2d< int >":
        return _mm3d.Pt2di_mcbyc(self, p2)

    def dcbyc(self, p2: 'Pt2di') -> "Pt2d< int >":
        return _mm3d.Pt2di_dcbyc(self, p2)

    def SetSup(self, p: 'Pt2di') -> "void":
        return _mm3d.Pt2di_SetSup(self, p)

    def SetInf(self, p: 'Pt2di') -> "void":
        return _mm3d.Pt2di_SetInf(self, p)

    def RatioMin(self, p: 'Pt2di') -> "Pt2d< int >::TypeScalReel":
        return _mm3d.Pt2di_RatioMin(self, p)

    def __iadd__(self, p2: 'Pt2di') -> "Pt2d< int > &":
        return _mm3d.Pt2di___iadd__(self, p2)

    def __isub__(self, p2: 'Pt2di') -> "Pt2d< int > &":
        return _mm3d.Pt2di___isub__(self, p2)

    def __eq__(self, p2: 'Pt2di') -> "ElStdTypeScal< int >::TypeBool":
        return _mm3d.Pt2di___eq__(self, p2)

    def __ne__(self, p2: 'Pt2di') -> "ElStdTypeScal< int >::TypeBool":
        return _mm3d.Pt2di___ne__(self, p2)

    def __lt__(self, p2: 'Pt2di') -> "ElStdTypeScal< int >::TypeBool":
        return _mm3d.Pt2di___lt__(self, p2)

    def xety_inf_ou_egal(self, p2: 'Pt2di') -> "ElStdTypeScal< int >::TypeBool":
        return _mm3d.Pt2di_xety_inf_ou_egal(self, p2)

    def __mul__(self, *args) -> "Pt2d< ElStdTypeScal< int >::TypeScalReel >":
        return _mm3d.Pt2di___mul__(self, *args)

    def __truediv__(self, *args):
        return _mm3d.Pt2di___truediv__(self, *args)
    __div__ = __truediv__



    def mul(self, aL: 'int const &') -> "Pt2d< int >":
        return _mm3d.Pt2di_mul(self, aL)

    def div(self, aL: 'int const &') -> "Pt2d< int >":
        return _mm3d.Pt2di_div(self, aL)

    def __xor__(self, p2: 'Pt2di') -> "int":
        return _mm3d.Pt2di___xor__(self, p2)

    def in_box(self, p0: 'Pt2di', p1: 'Pt2di') -> "ElStdTypeScal< int >::TypeBool":
        return _mm3d.Pt2di_in_box(self, p0, p1)

    def in_sect_angulaire(self, p1: 'Pt2di', p2: 'Pt2di') -> "bool":
        return _mm3d.Pt2di_in_sect_angulaire(self, p1, p2)

    def to_tab(self, t: 'int (&)[2]') -> "void":
        return _mm3d.Pt2di_to_tab(self, t)
    if _newclass:
        FromTab = staticmethod(_mm3d.Pt2di_FromTab)
    else:
        FromTab = _mm3d.Pt2di_FromTab

    def ToTab(self) -> "std::vector< int,std::allocator< int > >":
        return _mm3d.Pt2di_ToTab(self)

    def sigma(self) -> "Output":
        return _mm3d.Pt2di_sigma(self)

    def VMax(self) -> "Output":
        return _mm3d.Pt2di_VMax(self)

    def VMin(self) -> "Output":
        return _mm3d.Pt2di_VMin(self)

    def WhichMax(self) -> "Output":
        return _mm3d.Pt2di_WhichMax(self)

    def WhichMin(self) -> "Output":
        return _mm3d.Pt2di_WhichMin(self)

    def AbsP(self) -> "Pt2d< int >":
        return _mm3d.Pt2di_AbsP(self)

    def __repr__(self) -> "char *":
        return _mm3d.Pt2di___repr__(self)
    __swig_destroy__ = _mm3d.delete_Pt2di
    __del__ = lambda self: None
Pt2di_swigregister = _mm3d.Pt2di_swigregister
Pt2di_swigregister(Pt2di)

def Pt2di_El0() -> "Pt2d< int >":
    return _mm3d.Pt2di_El0()
Pt2di_El0 = _mm3d.Pt2di_El0

def Pt2di_IP2ToThisT(aP: 'Pt2di') -> "Pt2d< int >":
    return _mm3d.Pt2di_IP2ToThisT(aP)
Pt2di_IP2ToThisT = _mm3d.Pt2di_IP2ToThisT

def Pt2di_RP2ToThisT(aP: 'Pt2dr') -> "Pt2d< int >":
    return _mm3d.Pt2di_RP2ToThisT(aP)
Pt2di_RP2ToThisT = _mm3d.Pt2di_RP2ToThisT

def Pt2di_FP2ToThisT(aP: 'Pt2d< float > const &') -> "Pt2d< int >":
    return _mm3d.Pt2di_FP2ToThisT(aP)
Pt2di_FP2ToThisT = _mm3d.Pt2di_FP2ToThisT

def Pt2di_FromPolar(rho: 'double', teta: 'double') -> "Pt2d< int >":
    return _mm3d.Pt2di_FromPolar(rho, teta)
Pt2di_FromPolar = _mm3d.Pt2di_FromPolar

def Pt2di_polar(p: 'Pt2dr', AngDef: 'double') -> "Pt2d< double >":
    return _mm3d.Pt2di_polar(p, AngDef)
Pt2di_polar = _mm3d.Pt2di_polar

def Pt2di_FromTab(*args) -> "Pt2d< int >":
    return _mm3d.Pt2di_FromTab(*args)
Pt2di_FromTab = _mm3d.Pt2di_FromTab

class Pt2dr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pt2dr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pt2dr, name)
    if _newclass:
        El0 = staticmethod(_mm3d.Pt2dr_El0)
    else:
        El0 = _mm3d.Pt2dr_El0
    __swig_setmethods__["x"] = _mm3d.Pt2dr_x_set
    __swig_getmethods__["x"] = _mm3d.Pt2dr_x_get
    if _newclass:
        x = _swig_property(_mm3d.Pt2dr_x_get, _mm3d.Pt2dr_x_set)
    __swig_setmethods__["y"] = _mm3d.Pt2dr_y_set
    __swig_getmethods__["y"] = _mm3d.Pt2dr_y_get
    if _newclass:
        y = _swig_property(_mm3d.Pt2dr_y_get, _mm3d.Pt2dr_y_set)

    def __init__(self, *args):
        this = _mm3d.new_Pt2dr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        IP2ToThisT = staticmethod(_mm3d.Pt2dr_IP2ToThisT)
    else:
        IP2ToThisT = _mm3d.Pt2dr_IP2ToThisT
    if _newclass:
        RP2ToThisT = staticmethod(_mm3d.Pt2dr_RP2ToThisT)
    else:
        RP2ToThisT = _mm3d.Pt2dr_RP2ToThisT
    if _newclass:
        FP2ToThisT = staticmethod(_mm3d.Pt2dr_FP2ToThisT)
    else:
        FP2ToThisT = _mm3d.Pt2dr_FP2ToThisT
    if _newclass:
        FromPolar = staticmethod(_mm3d.Pt2dr_FromPolar)
    else:
        FromPolar = _mm3d.Pt2dr_FromPolar
    if _newclass:
        polar = staticmethod(_mm3d.Pt2dr_polar)
    else:
        polar = _mm3d.Pt2dr_polar

    def ToPtProvR(self) -> "Pt2d< double >::TypeProvPtScalR":
        return _mm3d.Pt2dr_ToPtProvR(self)

    def __neg__(self) -> "Pt2d< double >":
        return _mm3d.Pt2dr___neg__(self)

    def yx(self) -> "Pt2d< double >":
        return _mm3d.Pt2dr_yx(self)

    def conj(self) -> "Pt2d< double >":
        return _mm3d.Pt2dr_conj(self)

    def inv(self) -> "Pt2d< ElStdTypeScal< double >::TypeScalReel >":
        return _mm3d.Pt2dr_inv(self)

    def Square(self) -> "Pt2d< double >":
        return _mm3d.Pt2dr_Square(self)

    def XtY(self) -> "double":
        return _mm3d.Pt2dr_XtY(self)

    def __add__(self, p2: 'Pt2dr') -> "Pt2d< double >":
        return _mm3d.Pt2dr___add__(self, p2)

    def __sub__(self, p2: 'Pt2dr') -> "Pt2d< double >":
        return _mm3d.Pt2dr___sub__(self, p2)

    def mcbyc(self, p2: 'Pt2dr') -> "Pt2d< double >":
        return _mm3d.Pt2dr_mcbyc(self, p2)

    def dcbyc(self, p2: 'Pt2dr') -> "Pt2d< double >":
        return _mm3d.Pt2dr_dcbyc(self, p2)

    def SetSup(self, p: 'Pt2dr') -> "void":
        return _mm3d.Pt2dr_SetSup(self, p)

    def SetInf(self, p: 'Pt2dr') -> "void":
        return _mm3d.Pt2dr_SetInf(self, p)

    def RatioMin(self, p: 'Pt2dr') -> "Pt2d< double >::TypeScalReel":
        return _mm3d.Pt2dr_RatioMin(self, p)

    def __iadd__(self, p2: 'Pt2dr') -> "Pt2d< double > &":
        return _mm3d.Pt2dr___iadd__(self, p2)

    def __isub__(self, p2: 'Pt2dr') -> "Pt2d< double > &":
        return _mm3d.Pt2dr___isub__(self, p2)

    def __eq__(self, p2: 'Pt2dr') -> "ElStdTypeScal< double >::TypeBool":
        return _mm3d.Pt2dr___eq__(self, p2)

    def __ne__(self, p2: 'Pt2dr') -> "ElStdTypeScal< double >::TypeBool":
        return _mm3d.Pt2dr___ne__(self, p2)

    def __lt__(self, p2: 'Pt2dr') -> "ElStdTypeScal< double >::TypeBool":
        return _mm3d.Pt2dr___lt__(self, p2)

    def xety_inf_ou_egal(self, p2: 'Pt2dr') -> "ElStdTypeScal< double >::TypeBool":
        return _mm3d.Pt2dr_xety_inf_ou_egal(self, p2)

    def __mul__(self, *args) -> "Pt2d< ElStdTypeScal< double >::TypeScalReel >":
        return _mm3d.Pt2dr___mul__(self, *args)

    def __truediv__(self, *args):
        return _mm3d.Pt2dr___truediv__(self, *args)
    __div__ = __truediv__



    def mul(self, aL: 'double const &') -> "Pt2d< double >":
        return _mm3d.Pt2dr_mul(self, aL)

    def div(self, aL: 'double const &') -> "Pt2d< double >":
        return _mm3d.Pt2dr_div(self, aL)

    def __xor__(self, p2: 'Pt2dr') -> "double":
        return _mm3d.Pt2dr___xor__(self, p2)

    def in_box(self, p0: 'Pt2dr', p1: 'Pt2dr') -> "ElStdTypeScal< double >::TypeBool":
        return _mm3d.Pt2dr_in_box(self, p0, p1)

    def in_sect_angulaire(self, p1: 'Pt2dr', p2: 'Pt2dr') -> "bool":
        return _mm3d.Pt2dr_in_sect_angulaire(self, p1, p2)

    def to_tab(self, t: 'double (&)[2]') -> "void":
        return _mm3d.Pt2dr_to_tab(self, t)
    if _newclass:
        FromTab = staticmethod(_mm3d.Pt2dr_FromTab)
    else:
        FromTab = _mm3d.Pt2dr_FromTab

    def ToTab(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.Pt2dr_ToTab(self)

    def sigma(self) -> "Output":
        return _mm3d.Pt2dr_sigma(self)

    def VMax(self) -> "Output":
        return _mm3d.Pt2dr_VMax(self)

    def VMin(self) -> "Output":
        return _mm3d.Pt2dr_VMin(self)

    def WhichMax(self) -> "Output":
        return _mm3d.Pt2dr_WhichMax(self)

    def WhichMin(self) -> "Output":
        return _mm3d.Pt2dr_WhichMin(self)

    def AbsP(self) -> "Pt2d< double >":
        return _mm3d.Pt2dr_AbsP(self)

    def __repr__(self) -> "char *":
        return _mm3d.Pt2dr___repr__(self)
    __swig_destroy__ = _mm3d.delete_Pt2dr
    __del__ = lambda self: None
Pt2dr_swigregister = _mm3d.Pt2dr_swigregister
Pt2dr_swigregister(Pt2dr)

def Pt2dr_El0() -> "Pt2d< double >":
    return _mm3d.Pt2dr_El0()
Pt2dr_El0 = _mm3d.Pt2dr_El0

def Pt2dr_IP2ToThisT(aP: 'Pt2di') -> "Pt2d< double >":
    return _mm3d.Pt2dr_IP2ToThisT(aP)
Pt2dr_IP2ToThisT = _mm3d.Pt2dr_IP2ToThisT

def Pt2dr_RP2ToThisT(aP: 'Pt2dr') -> "Pt2d< double >":
    return _mm3d.Pt2dr_RP2ToThisT(aP)
Pt2dr_RP2ToThisT = _mm3d.Pt2dr_RP2ToThisT

def Pt2dr_FP2ToThisT(aP: 'Pt2d< float > const &') -> "Pt2d< double >":
    return _mm3d.Pt2dr_FP2ToThisT(aP)
Pt2dr_FP2ToThisT = _mm3d.Pt2dr_FP2ToThisT

def Pt2dr_FromPolar(rho: 'double', teta: 'double') -> "Pt2d< double >":
    return _mm3d.Pt2dr_FromPolar(rho, teta)
Pt2dr_FromPolar = _mm3d.Pt2dr_FromPolar

def Pt2dr_polar(p: 'Pt2dr', AngDef: 'double') -> "Pt2d< double >":
    return _mm3d.Pt2dr_polar(p, AngDef)
Pt2dr_polar = _mm3d.Pt2dr_polar

def pt_set_min_max(*args) -> "void":
    return _mm3d.pt_set_min_max(*args)
pt_set_min_max = _mm3d.pt_set_min_max

def Pt2dr_FromTab(*args) -> "Pt2d< double >":
    return _mm3d.Pt2dr_FromTab(*args)
Pt2dr_FromTab = _mm3d.Pt2dr_FromTab

class Pt3dr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pt3dr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pt3dr, name)
    __swig_setmethods__["x"] = _mm3d.Pt3dr_x_set
    __swig_getmethods__["x"] = _mm3d.Pt3dr_x_get
    if _newclass:
        x = _swig_property(_mm3d.Pt3dr_x_get, _mm3d.Pt3dr_x_set)
    __swig_setmethods__["y"] = _mm3d.Pt3dr_y_set
    __swig_getmethods__["y"] = _mm3d.Pt3dr_y_get
    if _newclass:
        y = _swig_property(_mm3d.Pt3dr_y_get, _mm3d.Pt3dr_y_set)
    __swig_setmethods__["z"] = _mm3d.Pt3dr_z_set
    __swig_getmethods__["z"] = _mm3d.Pt3dr_z_get
    if _newclass:
        z = _swig_property(_mm3d.Pt3dr_z_get, _mm3d.Pt3dr_z_set)
    if _newclass:
        P3ToThisT = staticmethod(_mm3d.Pt3dr_P3ToThisT)
    else:
        P3ToThisT = _mm3d.Pt3dr_P3ToThisT

    def __init__(self, *args):
        this = _mm3d.new_Pt3dr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __add__(self, p2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.Pt3dr___add__(self, p2)

    def __mul__(self, arg2: 'double') -> "Pt3d< double >":
        return _mm3d.Pt3dr___mul__(self, arg2)

    def __truediv__(self, *args):
        return _mm3d.Pt3dr___truediv__(self, *args)
    __div__ = __truediv__



    def __sub__(self, p2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.Pt3dr___sub__(self, p2)

    def __neg__(self) -> "Pt3d< double >":
        return _mm3d.Pt3dr___neg__(self)

    def __eq__(self, p2: 'Pt3dr') -> "ElStdTypeScal< double >::TypeBool":
        return _mm3d.Pt3dr___eq__(self, p2)

    def __xor__(self, p2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.Pt3dr___xor__(self, p2)

    def to_tab(self, t: 'double (&)[3]') -> "void":
        return _mm3d.Pt3dr_to_tab(self, t)

    def ToTab(self) -> "std::vector< double,std::allocator< double > >":
        return _mm3d.Pt3dr_ToTab(self)
    if _newclass:
        FromTab = staticmethod(_mm3d.Pt3dr_FromTab)
    else:
        FromTab = _mm3d.Pt3dr_FromTab

    def AbsP(self) -> "Pt3d< double >":
        return _mm3d.Pt3dr_AbsP(self)

    def sigma(self) -> "Output":
        return _mm3d.Pt3dr_sigma(self)

    def VMax(self) -> "Output":
        return _mm3d.Pt3dr_VMax(self)

    def VMin(self) -> "Output":
        return _mm3d.Pt3dr_VMin(self)

    def WhichMax(self) -> "Output":
        return _mm3d.Pt3dr_WhichMax(self)

    def WhichMin(self) -> "Output":
        return _mm3d.Pt3dr_WhichMin(self)
    if _newclass:
        instantiate = staticmethod(_mm3d.Pt3dr_instantiate)
    else:
        instantiate = _mm3d.Pt3dr_instantiate
    if _newclass:
        TyFromSpherique = staticmethod(_mm3d.Pt3dr_TyFromSpherique)
    else:
        TyFromSpherique = _mm3d.Pt3dr_TyFromSpherique

    def __repr__(self) -> "char *":
        return _mm3d.Pt3dr___repr__(self)
    __swig_destroy__ = _mm3d.delete_Pt3dr
    __del__ = lambda self: None
Pt3dr_swigregister = _mm3d.Pt3dr_swigregister
Pt3dr_swigregister(Pt3dr)

def Pt3dr_P3ToThisT(*args) -> "Pt3d< double >":
    return _mm3d.Pt3dr_P3ToThisT(*args)
Pt3dr_P3ToThisT = _mm3d.Pt3dr_P3ToThisT

def Pt3dr_FromTab(*args) -> "Pt3d< double >":
    return _mm3d.Pt3dr_FromTab(*args)
Pt3dr_FromTab = _mm3d.Pt3dr_FromTab

def Pt3dr_instantiate() -> "double":
    return _mm3d.Pt3dr_instantiate()
Pt3dr_instantiate = _mm3d.Pt3dr_instantiate

def Pt3dr_TyFromSpherique(Rho: 'double', Teta: 'double', Phi: 'double') -> "Pt3d< double >":
    return _mm3d.Pt3dr_TyFromSpherique(Rho, Teta, Phi)
Pt3dr_TyFromSpherique = _mm3d.Pt3dr_TyFromSpherique

class ElRotation3D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElRotation3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElRotation3D, name)
    __repr__ = _swig_repr

    def inv(self) -> "TplElRotation3D< double >":
        return _mm3d.ElRotation3D_inv(self)

    def __mul__(self, arg2: 'ElRotation3D') -> "TplElRotation3D< double >":
        return _mm3d.ElRotation3D___mul__(self, arg2)

    def __init__(self, *args):
        this = _mm3d.new_ElRotation3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ImAff(self, arg2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.ElRotation3D_ImAff(self, arg2)

    def ImRecAff(self, arg2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.ElRotation3D_ImRecAff(self, arg2)

    def ImVect(self, arg2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.ElRotation3D_ImVect(self, arg2)

    def IRecVect(self, arg2: 'Pt3dr') -> "Pt3d< double >":
        return _mm3d.ElRotation3D_IRecVect(self, arg2)

    def DiffParamEn1pt(self, arg2: 'Pt3dr') -> "ElMatrix< double >":
        return _mm3d.ElRotation3D_DiffParamEn1pt(self, arg2)

    def Mat(self) -> "ElMatrix< double > const &":
        return _mm3d.ElRotation3D_Mat(self)

    def tr(self, *args) -> "Pt3d< double > &":
        return _mm3d.ElRotation3D_tr(self, *args)

    def teta01(self) -> "double const &":
        return _mm3d.ElRotation3D_teta01(self)

    def teta02(self) -> "double const &":
        return _mm3d.ElRotation3D_teta02(self)

    def teta12(self) -> "double const &":
        return _mm3d.ElRotation3D_teta12(self)

    def IsTrueRot(self) -> "bool":
        return _mm3d.ElRotation3D_IsTrueRot(self)
    __swig_destroy__ = _mm3d.delete_ElRotation3D
    __del__ = lambda self: None
ElRotation3D_swigregister = _mm3d.ElRotation3D_swigregister
ElRotation3D_swigregister(ElRotation3D)
ElRotation3D.Id = _mm3d.cvar.ElRotation3D_Id

class ElMatrixr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ElMatrixr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ElMatrixr, name)
    __repr__ = _swig_repr

    def ResizeInside(self, TX: 'int', TY: 'int') -> "void":
        return _mm3d.ElMatrixr_ResizeInside(self, TX, TY)

    def GetCol(self, *args) -> "void":
        return _mm3d.ElMatrixr_GetCol(self, *args)

    def GetLig(self, *args) -> "void":
        return _mm3d.ElMatrixr_GetLig(self, *args)

    def __init__(self, *args):
        this = _mm3d.new_ElMatrixr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mm3d.delete_ElMatrixr
    __del__ = lambda self: None

    def sub_mat(self, aCol: 'int', aLig: 'int', aNbCol: 'int', aNbLig: 'int') -> "ElMatrix< double >":
        return _mm3d.ElMatrixr_sub_mat(self, aCol, aLig, aNbCol, aNbLig)

    def ExtensionId(self, ExtAvant: 'int', ExtApres: 'int') -> "ElMatrix< double >":
        return _mm3d.ElMatrixr_ExtensionId(self, ExtAvant, ExtApres)

    def set_to_size(self, *args) -> "void":
        return _mm3d.ElMatrixr_set_to_size(self, *args)

    def set_shift_mat_permut(self, ShiftPremierCol: 'int') -> "void":
        return _mm3d.ElMatrixr_set_shift_mat_permut(self, ShiftPremierCol)
    if _newclass:
        transposition = staticmethod(_mm3d.ElMatrixr_transposition)
    else:
        transposition = _mm3d.ElMatrixr_transposition

    def data(self) -> "double **":
        return _mm3d.ElMatrixr_data(self)

    def same_size(self, arg2: 'ElMatrixr') -> "bool":
        return _mm3d.ElMatrixr_same_size(self, arg2)

    def __call__(self, *args) -> "double const &":
        return _mm3d.ElMatrixr___call__(self, *args)

    def tx(self) -> "int":
        return _mm3d.ElMatrixr_tx(self)

    def ty(self) -> "int":
        return _mm3d.ElMatrixr_ty(self)

    def Sz(self) -> "Pt2di":
        return _mm3d.ElMatrixr_Sz(self)

    def ProdCC(self, arg2: 'ElMatrixr', x1: 'int', x2: 'int') -> "double":
        return _mm3d.ElMatrixr_ProdCC(self, arg2, x1, x2)

    def ProdLL(self, arg2: 'ElMatrixr', y1: 'int', y2: 'int') -> "double":
        return _mm3d.ElMatrixr_ProdLL(self, arg2, y1, y2)

    def ProdLC(self, arg2: 'ElMatrixr', y1: 'int', x2: 'int') -> "double":
        return _mm3d.ElMatrixr_ProdLC(self, arg2, y1, x2)

    def SetLine(self, NL: 'int', arg3: 'double const *') -> "void":
        return _mm3d.ElMatrixr_SetLine(self, NL, arg3)

    def GetLine(self, NL: 'int', arg3: 'double *') -> "void":
        return _mm3d.ElMatrixr_GetLine(self, NL, arg3)

    def mul(self, *args) -> "void":
        return _mm3d.ElMatrixr_mul(self, *args)

    def __mul__(self, *args) -> "ElMatrix< double >":
        return _mm3d.ElMatrixr___mul__(self, *args)

    def __imul__(self, arg2: 'double const &') -> "void":
        return _mm3d.ElMatrixr___imul__(self, arg2)

    def __iadd__(self, arg2: 'ElMatrixr') -> "void":
        return _mm3d.ElMatrixr___iadd__(self, arg2)

    def Det(self) -> "double":
        return _mm3d.ElMatrixr_Det(self)

    def Trace(self) -> "double":
        return _mm3d.ElMatrixr_Trace(self)

    def add(self, m1: 'ElMatrixr', m2: 'ElMatrixr') -> "void":
        return _mm3d.ElMatrixr_add(self, m1, m2)

    def __add__(self, arg2: 'ElMatrixr') -> "ElMatrix< double >":
        return _mm3d.ElMatrixr___add__(self, arg2)

    def sub(self, m1: 'ElMatrixr', m2: 'ElMatrixr') -> "void":
        return _mm3d.ElMatrixr_sub(self, m1, m2)

    def __sub__(self, arg2: 'ElMatrixr') -> "ElMatrix< double >":
        return _mm3d.ElMatrixr___sub__(self, arg2)

    def self_transpose(self) -> "void":
        return _mm3d.ElMatrixr_self_transpose(self)

    def SymetriseParleBas(self) -> "void":
        return _mm3d.ElMatrixr_SymetriseParleBas(self)

    def transpose(self, *args) -> "ElMatrix< double >":
        return _mm3d.ElMatrixr_transpose(self, *args)
    if _newclass:
        Rotation3D = staticmethod(_mm3d.ElMatrixr_Rotation3D)
    else:
        Rotation3D = _mm3d.ElMatrixr_Rotation3D
    if _newclass:
        Rotation = staticmethod(_mm3d.ElMatrixr_Rotation)
    else:
        Rotation = _mm3d.ElMatrixr_Rotation
    if _newclass:
        PermRot = staticmethod(_mm3d.ElMatrixr_PermRot)
    else:
        PermRot = _mm3d.ElMatrixr_PermRot
    if _newclass:
        DerRotation = staticmethod(_mm3d.ElMatrixr_DerRotation)
    else:
        DerRotation = _mm3d.ElMatrixr_DerRotation
    if _newclass:
        DDteta01 = staticmethod(_mm3d.ElMatrixr_DDteta01)
    else:
        DDteta01 = _mm3d.ElMatrixr_DDteta01
    if _newclass:
        DDteta02 = staticmethod(_mm3d.ElMatrixr_DDteta02)
    else:
        DDteta02 = _mm3d.ElMatrixr_DDteta02
    if _newclass:
        DDteta12 = staticmethod(_mm3d.ElMatrixr_DDteta12)
    else:
        DDteta12 = _mm3d.ElMatrixr_DDteta12

    def ColSchmidtOrthog(self, iter: 'int'=1) -> "ElMatrix< double >":
        return _mm3d.ElMatrixr_ColSchmidtOrthog(self, iter)

    def SetColSchmidtOrthog(self, iter: 'int'=1) -> "void":
        return _mm3d.ElMatrixr_SetColSchmidtOrthog(self, iter)

    def scal(self, m2: 'ElMatrixr') -> "double":
        return _mm3d.ElMatrixr_scal(self, m2)

    def L2(self, *args) -> "double":
        return _mm3d.ElMatrixr_L2(self, *args)

    def NormC(self, x: 'int') -> "double":
        return _mm3d.ElMatrixr_NormC(self, x)
ElMatrixr_swigregister = _mm3d.ElMatrixr_swigregister
ElMatrixr_swigregister(ElMatrixr)

def ElMatrixr_transposition(aN: 'int', aK1: 'int', aK2: 'int') -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_transposition(aN, aK1, aK2)
ElMatrixr_transposition = _mm3d.ElMatrixr_transposition

def ElMatrixr_Rotation3D(teta: 'double', aNumAxeInv: 'int') -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_Rotation3D(teta, aNumAxeInv)
ElMatrixr_Rotation3D = _mm3d.ElMatrixr_Rotation3D

def ElMatrixr_Rotation(*args) -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_Rotation(*args)
ElMatrixr_Rotation = _mm3d.ElMatrixr_Rotation

def ElMatrixr_PermRot(*args) -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_PermRot(*args)
ElMatrixr_PermRot = _mm3d.ElMatrixr_PermRot

def ElMatrixr_DerRotation(sz: 'int', teta: 'double', k1: 'int', k2: 'int') -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_DerRotation(sz, teta, k1, k2)
ElMatrixr_DerRotation = _mm3d.ElMatrixr_DerRotation

def ElMatrixr_DDteta01(teta12: 'double', teta13: 'double', teta23: 'double') -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_DDteta01(teta12, teta13, teta23)
ElMatrixr_DDteta01 = _mm3d.ElMatrixr_DDteta01

def ElMatrixr_DDteta02(teta12: 'double', teta13: 'double', teta23: 'double') -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_DDteta02(teta12, teta13, teta23)
ElMatrixr_DDteta02 = _mm3d.ElMatrixr_DDteta02

def ElMatrixr_DDteta12(teta12: 'double', teta13: 'double', teta23: 'double') -> "ElMatrix< double >":
    return _mm3d.ElMatrixr_DDteta12(teta12, teta13, teta23)
ElMatrixr_DDteta12 = _mm3d.ElMatrixr_DDteta12


print("MicMac Python3 API")
mm3d_init();

# This file is compatible with both classic and new-style classes.


